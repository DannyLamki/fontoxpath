id-rename-expr-06,The target expression is allowed to be updating in version 3.0
id-transform-expr-013,Error XUST0002 is no longer available in version 3.0.
=====================TESTS ABOVE HAVE BEEN MARKED MANUALLY=====================
variable-declaration-01,Error: XPST0003: Unable to parse XPath: "(: Name: variable-declaration-01 :) (: Description: Variable declaration with an updating expression rhs. :)  (: insert-start :) declare variable $employees external; (: insert-end :)  declare variable $upd := insert node <employee/> into $employees/employees;  $upd ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: variable-declaration-01 :) (: Description: Variable declaration with an updating expression rhs. :)  (: insert-start :) declare variable $employees external; (: insert-end :)  declare variable $upd := insert [Error is around here]node <employee/> into $employees/employees;  $upd
variable-declaration-02,Error: XPST0003: Unable to parse XPath: "(: Name: variable-declaration-01 :) (: Description: Variable declaration with an updating expression rhs. :)  (: insert-start :) declare variable $employees external; (: insert-end :)  declare variable $upd := insert node <employee/> into $employees/employees;  $upd ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: variable-declaration-01 :) (: Description: Variable declaration with an updating expression rhs. :)  (: insert-start :) declare variable $employees external; (: insert-end :)  declare variable $upd := insert [Error is around here]node <employee/> into $employees/employees;  $upd
id-function-declaration-01,Error: XPST0003: Unable to parse XPath: "(: Name: id-function-declaration-01 :) (: Description: Evaluation of insert expression used with function declaration. :) (: Function is declared "updating" and enclosed expression is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  declare updating function     local:insertFunction($e as element())     {    let $e1 := $e    return      insert node <hours>21</hours> as last into $e1    };     let $arg1 := $input-context/works[1]/employee[1] return   local:insertFunction($arg1)". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "context", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "option", "or", "to", "treat", "union", "variable", "|", "||", or end of input but "u" found. (: Name: id-function-declaration-01 :) (: Description: Evaluation of insert expression used with function declaration. :) (: Function is declared "updating" and enclosed expression is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  declare [Error is around here]updating function     local:insertFunction($e as element())     {    let $e1 := $e    return      insert node <hours>21</hours> as last into $e1    };     let $arg1 := $input-context/works[1]/employee[1] return   local:insertFunction($arg1)
id-function-declaration-02,Error: XPST0003: Unable to parse XPath: "(: Name: id-function-declaration-02 :) (: Description: Evaluation of insert expression used with function declaration. :) (: Function is declared not "updating" an not external and enclosed expression :) (: is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   declare function     local:insertFunction($e as element())     {    let $e1 := $e    return      insert node <hour>20</hour> into $e1    };     let $arg1 := $input-context/employees[1]/employee[1] return   local:insertFunction($arg1)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or "}" but "n" found. (: Name: id-function-declaration-02 :) (: Description: Evaluation of insert expression used with function declaration. :) (: Function is declared not "updating" an not external and enclosed expression :) (: is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   declare function     local:insertFunction($e as element())     {    let $e1 := $e    return      insert [Error is around here]node <hour>20</hour> into $e1    };     let $arg1 := $input-context/employees[1]/employee[1] return   local:insertFunction($arg1)
id-function-declaration-03,Error: XPST0003: Unable to parse XPath: "(: Name: id-function-declaration-03 :) (: Description: Evaluation of insert expression used with function declaration. :) (: Function is declared "updating" and not external and enclosed expression :) (: is the empty sequence.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   declare updating function     local:insertFunction($e as element())     {      ()    };  let $arg1 := $input-context/works[1]/employee[3]   return   local:insertFunction($arg1)". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "context", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "option", "or", "to", "treat", "union", "variable", "|", "||", or end of input but "u" found. (: Name: id-function-declaration-03 :) (: Description: Evaluation of insert expression used with function declaration. :) (: Function is declared "updating" and not external and enclosed expression :) (: is the empty sequence.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   declare [Error is around here]updating function     local:insertFunction($e as element())     {      ()    };  let $arg1 := $input-context/works[1]/employee[3]   return   local:insertFunction($arg1)
id-function-declaration-04,Error: XPST0003: Unable to parse XPath: "(: Name: id-function-declaration-04 :) (: Description: Evaluation of insert expression used with function declaration. :) (: Function is declared "updating" and not external and enclosed expression :) (: is call to fn:error.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   declare updating function     local:insertFunction($e as element())     {     fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))    };     let $arg1 := $input-context/works[1]/employee[3]     return   local:insertFunction($arg1)". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "context", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "option", "or", "to", "treat", "union", "variable", "|", "||", or end of input but "u" found. (: Name: id-function-declaration-04 :) (: Description: Evaluation of insert expression used with function declaration. :) (: Function is declared "updating" and not external and enclosed expression :) (: is call to fn:error.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   declare [Error is around here]updating function     local:insertFunction($e as element())     {     fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))    };     let $arg1 := $input-context/works[1]/employee[3]     return   local:insertFunction($arg1)
id-function-declaration-05,Error: XPST0003: Unable to parse XPath: "(: Name: id-function-declaration-05 :) (: Description: Evaluation of usage of mathematical expression used with function declaration. :) (: Function is declared "updating" and not external and enclosed expression :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   declare updating function     local:insertFunction($e as xs:integer)     {    let $e1 := $e    return      $e1 + $e         };     let $arg1 := xs:integer($input-context/employees[1]/salary[1])    return   local:insertFunction($arg1)". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "context", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "option", "or", "to", "treat", "union", "variable", "|", "||", or end of input but "u" found. (: Name: id-function-declaration-05 :) (: Description: Evaluation of usage of mathematical expression used with function declaration. :) (: Function is declared "updating" and not external and enclosed expression :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   declare [Error is around here]updating function     local:insertFunction($e as xs:integer)     {    let $e1 := $e    return      $e1 + $e         };     let $arg1 := xs:integer($input-context/employees[1]/salary[1])    return   local:insertFunction($arg1)
id-function-declaration-06,Error: XPST0003: Unable to parse XPath: "(: Name: id-function-declaration-06 :) (: Description: Evaluation of a delete expression used with function declaration. :) (: Function is declared not "updating" an not external and enclosed expression :) (: is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   declare updating function     local:insertFunction($e as element())     {    let $e1 := $e    return      delete node $e/hours[1]    };     let $arg1 := $input-context/works[1]/employee[2] return   local:insertFunction($arg1)". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "context", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "option", "or", "to", "treat", "union", "variable", "|", "||", or end of input but "u" found. (: Name: id-function-declaration-06 :) (: Description: Evaluation of a delete expression used with function declaration. :) (: Function is declared not "updating" an not external and enclosed expression :) (: is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   declare [Error is around here]updating function     local:insertFunction($e as element())     {    let $e1 := $e    return      delete node $e/hours[1]    };     let $arg1 := $input-context/works[1]/employee[2] return   local:insertFunction($arg1)
id-function-declaration-07,Error: XPST0003: Unable to parse XPath: "(: Name: id-function-declaration-07 :) (: Description: Evaluation of a delete expression used with function declaration. :) (: Function is declared "updating" and enclosed expression is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   declare function     local:insertFunction($e as element())     {    let $e1 := $e    return      delete node $e/salary[1]    };     let $arg1 := $input-context/employees[1]/employee[1] return   local:insertFunction($arg1)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or "}" but "n" found. (: Name: id-function-declaration-07 :) (: Description: Evaluation of a delete expression used with function declaration. :) (: Function is declared "updating" and enclosed expression is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   declare function     local:insertFunction($e as element())     {    let $e1 := $e    return      delete [Error is around here]node $e/salary[1]    };     let $arg1 := $input-context/employees[1]/employee[1] return   local:insertFunction($arg1)
id-function-declaration-08,Error: XPST0003: Unable to parse XPath: "(: Name: id-function-declaration-08 :) (: Description: Evaluation of a replace expression used with function declaration. :) (: Function is declared "updating" and enclosed expression is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   declare updating function     local:replaceFunction($e as element())     {    let $e1 := $e       return      replace value of node $e1/hours[1] with $e1/hours[2]    };     let $arg1 := $input-context/works[1]/employee[2] return   local:replaceFunction($arg1)". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "context", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "option", "or", "to", "treat", "union", "variable", "|", "||", or end of input but "u" found. (: Name: id-function-declaration-08 :) (: Description: Evaluation of a replace expression used with function declaration. :) (: Function is declared "updating" and enclosed expression is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   declare [Error is around here]updating function     local:replaceFunction($e as element())     {    let $e1 := $e       return      replace value of node $e1/hours[1] with $e1/hours[2]    };     let $arg1 := $input-context/works[1]/employee[2] return   local:replaceFunction($arg1)
id-function-declaration-09,Error: Should throw error XUST0001.: expected 'The expression (: Name: id-function-declaration-09 :)\n(: Description: Evaluation of a replace expression used with function declaration. :)\n(: Function is declared not "updating" an not external and enclosed expression :)\n(: is an updating expression.  :)\n\n(: insert-start :)\ndeclare variable $input-context external;\n(: insert-end :)\n\n\ndeclare function \n   local:replaceFunction($e as element()) \n   {\n   let $e1 := $e    \n   return\n     replace value of node $e1/employee[1]/salary[1] with $e1/employee[2]/salary[1]\n   };\n   \nlet $arg1 := $input-context/employees[1]\nreturn\n  local:replaceFunction($arg1) is not updating and can not be executed as an updating expression.' to equal 'XUST0001'
id-function-declaration-010,Error: XPST0003: Unable to parse XPath: "(: Name: id-function-declaration-010 :) (: Description: Evaluation of a rename expression used with function declaration. :) (: Function is declared "updating" and enclosed expression is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   declare updating function     local:renameFunction($e as element())     {    let $e1 := $e     return      rename node $e1/hours[1] as "hours-1"    };     let $arg1 := $input-context/works[1]/employee[3] return   local:renameFunction($arg1)". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "context", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "option", "or", "to", "treat", "union", "variable", "|", "||", or end of input but "u" found. (: Name: id-function-declaration-010 :) (: Description: Evaluation of a rename expression used with function declaration. :) (: Function is declared "updating" and enclosed expression is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   declare [Error is around here]updating function     local:renameFunction($e as element())     {    let $e1 := $e     return      rename node $e1/hours[1] as "hours-1"    };     let $arg1 := $input-context/works[1]/employee[3] return   local:renameFunction($arg1)
id-function-declaration-011,Error: Should throw error XUST0001.: expected 'The expression (: Name: id-function-declaration-011 :)\n(: Description: Evaluation of a rename expression used with function declaration. :)\n(: Function is declared not "updating" an not external and enclosed expression :)\n(: is an updating expression.  :)\n\n(: insert-start :)\ndeclare variable $input-context external;\n(: insert-end :)\n\n\ndeclare function \n   local:renameFunction($e as element()) \n   {\n   let $e1 := $e    \n   return\n     rename node $e1/salary[1] as "salary-1"\n   };\n   \nlet $arg1 := $input-context/employees[1]/employee[3]\nreturn\n  local:renameFunction($arg1) is not updating and can not be executed as an updating expression.' to equal 'XUST0001'
id-function-declaration-012,Error: XPST0003: Unable to parse XPath: "(: Name: id-function-declaration-012 :) (: Description: Evaluation of a transform expression used with function declaration. :) (: Function is declared "updating" and enclosed expression is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   declare updating function     local:transformFunction($e as element())     {    let $e1 := $e    return      copy $newVar := $e1 modify delete node $newVar/hours[1] return $newVar    };     let $arg1 := $input-context/works[1]/employee[2] return   local:transformFunction($arg1)". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "context", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "option", "or", "to", "treat", "union", "variable", "|", "||", or end of input but "u" found. (: Name: id-function-declaration-012 :) (: Description: Evaluation of a transform expression used with function declaration. :) (: Function is declared "updating" and enclosed expression is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   declare [Error is around here]updating function     local:transformFunction($e as element())     {    let $e1 := $e    return      copy $newVar := $e1 modify delete node $newVar/hours[1] return $newVar    };     let $arg1 := $input-context/works[1]/employee[2] return   local:transformFunction($arg1)
id-function-declaration-013,Error: XPST0003: Unable to parse XPath: "(: Name: id-function-declaration-013 :) (: Description: Evaluation of a transform expression used with function declaration. :) (: Function is declared not "updating" an not external and enclosed expression :) (: is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  declare function     local:transformFunction($e as element())     {      copy $newVar := $e modify delete node $newVar/employee[4] return $newVar    };     let $arg1 := $input-context/employees[1] return   local:transformFunction($arg1)". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-function-declaration-013 :) (: Description: Evaluation of a transform expression used with function declaration. :) (: Function is declared not "updating" an not external and enclosed expression :) (: is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  declare function     local:transformFunction($e as element())     {      copy $newVar := $e modify delete [Error is around here]node $newVar/employee[4] return $newVar    };     let $arg1 := $input-context/employees[1] return   local:transformFunction($arg1)
id-function-declaration-014,Error: XPST0003: Unable to parse XPath: "(: Name: id-function-declaration-014 :) (: Description: Evaluation of a function declaration declared as updating, :) (: and a return type is specified. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  declare updating function     local:transformFunction($e as element()) as element()     {    let $e1 := $e    return      copy $newVar := $e1 modify delete node $newVar/salary[1] return $newVar    };     let $arg1 := $input-context/employees[1]/employee[1] return   local:transformFunction($arg1)". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "context", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "option", "or", "to", "treat", "union", "variable", "|", "||", or end of input but "u" found. (: Name: id-function-declaration-014 :) (: Description: Evaluation of a function declaration declared as updating, :) (: and a return type is specified. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  declare [Error is around here]updating function     local:transformFunction($e as element()) as element()     {    let $e1 := $e    return      copy $newVar := $e1 modify delete node $newVar/salary[1] return $newVar    };     let $arg1 := $input-context/employees[1]/employee[1] return   local:transformFunction($arg1)
id-function-declaration-015,Error: XPST0003: Unable to parse XPath: "(: Name: id-function-declaration-015 :) (: Description: Invalid use of an updating expression within an updating function. :) (: Function is declared "updating" and enclosed expression is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  declare updating function     local:insertFunction($e as element())     {    let $e1 := delete nodes $e/*/*    return      insert node <hours>21</hours> as last into $e    };     let $arg1 := $input-context/works[1]/employee[1] return   local:insertFunction($arg1)". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "context", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "option", "or", "to", "treat", "union", "variable", "|", "||", or end of input but "u" found. (: Name: id-function-declaration-015 :) (: Description: Invalid use of an updating expression within an updating function. :) (: Function is declared "updating" and enclosed expression is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  declare [Error is around here]updating function     local:insertFunction($e as element())     {    let $e1 := delete nodes $e/*/*    return      insert node <hours>21</hours> as last into $e    };     let $arg1 := $input-context/works[1]/employee[1] return   local:insertFunction($arg1)
id-function-declaration-016,Error: XPST0003: Unable to parse XPath: "(: Name: id-function-declaration-016 :) (: Description: Invalid use of a non-updating expression within an updating function. :) (: Function is declared "updating" and enclosed expression is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  declare updating function     local:insertFunction($e as element())     {    if (current-date() gt xs:date('1900-01-01'))    then      insert node <hours>21</hours> as last into $e    else      'exit'    };     let $arg1 := $input-context/works[1]/employee[1] return   local:insertFunction($arg1)". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "context", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "option", "or", "to", "treat", "union", "variable", "|", "||", or end of input but "u" found. (: Name: id-function-declaration-016 :) (: Description: Invalid use of a non-updating expression within an updating function. :) (: Function is declared "updating" and enclosed expression is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  declare [Error is around here]updating function     local:insertFunction($e as element())     {    if (current-date() gt xs:date('1900-01-01'))    then      insert node <hours>21</hours> as last into $e    else      'exit'    };     let $arg1 := $input-context/works[1]/employee[1] return   local:insertFunction($arg1)
id-function-declaration-017,Error: XPST0003: Unable to parse XPath: "(: Name: id-function-declaration-017 :) (: Description: Recursive updating function. :)   declare updating function local:increase($e as element(b)?, $amount as xs:integer)     {      if ($e) then (         replace value of node $e with ($e + $amount),         local:increase($e/../b[.>>$e][1], $amount+1)         (: i.e. $e/following-sibling::b[1], but we're not allowed to use the following-sibling axis: see bug 8251 :)      ) else ()    };     let $a1 :=    <a>{for $i in 1 to 100 return <b>{$i}</b>}</a> let $a2 :=     copy $a3 := $a1    modify local:increase($a3/b[1], 1)    return $a3 return <totals>{sum($a1/b/xs:integer(.)), sum($a2/b/xs:integer(.))}</totals>". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "u" found. (: Name: id-function-declaration-017 :) (: Description: Recursive updating function. :)   declare [Error is around here]updating function local:increase($e as element(b)?, $amount as xs:integer)     {      if ($e) then (         replace value of node $e with ($e + $amount),         local:increase($e/../b[.>>$e][1], $amount+1)         (: i.e. $e/following-sibling::b[1], but we're not allowed to use the following-sibling axis: see bug 8251 :)      ) else ()    };     let $a1 :=    <a>{for $i in 1 to 100 return <b>{$i}</b>}</a> let $a2 :=     copy $a3 := $a1    modify local:increase($a3/b[1], 1)    return $a3 return <totals>{sum($a1/b/xs:integer(.)), sum($a2/b/xs:integer(.))}</totals>
function-declaration-01,Error: Should throw error XUST0001.: expected 'The expression (: Name: function-declaration-01 :)\n(: Description: Function declaration, non-updating, with updating expression. :)\n\n(: insert-start :)\ndeclare variable $employees external;\n(: insert-end :)\n\ndeclare function local:test ($emp)\n   { replace value of node $emp/salary with 200000 };\n\nlocal:test($employees/employees/*[1])\n is not updating and can not be executed as an updating expression.' to equal 'XUST0001'
function-declaration-02,Error: XPST0003: Unable to parse XPath: "(: Name: function-declaration-02 :) (: Description: Function declaration, updating, with return type. :)  (: insert-start :) declare variable $employees external; (: insert-end :)  declare updating function local:test ($emp) as xs:integer    { replace value of node $emp/salary with 200000 };  local:test($employees/employees/*[1]) ". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "context", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "option", "or", "to", "treat", "union", "variable", "|", "||", or end of input but "u" found. (: Name: function-declaration-02 :) (: Description: Function declaration, updating, with return type. :)  (: insert-start :) declare variable $employees external; (: insert-end :)  declare [Error is around here]updating function local:test ($emp) as xs:integer    { replace value of node $emp/salary with 200000 };  local:test($employees/employees/*[1])
function-declaration-03,Error: XPST0003: Unable to parse XPath: "(: Name: function-declaration-03 :) (: Description: Function declaration, updating, with simple expression. :)  (: insert-start :) declare variable $employees external; (: insert-end :)  declare updating function local:test ($emp)    { 12 };  local:test($employees/employees/*[1]) ". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "context", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "option", "or", "to", "treat", "union", "variable", "|", "||", or end of input but "u" found. (: Name: function-declaration-03 :) (: Description: Function declaration, updating, with simple expression. :)  (: insert-start :) declare variable $employees external; (: insert-end :)  declare [Error is around here]updating function local:test ($emp)    { 12 };  local:test($employees/employees/*[1])
function-declaration-04,Error: XPST0003: Unable to parse XPath: "(: Name: function-declaration-04 :) (: Description: Function declaration, updating, with vacuous expression. :)  (: insert-start :) declare variable $employees external; (: insert-end :)  declare updating function local:test ($emp)    { () };  local:test($employees/employees/*[1]) ". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "context", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "option", "or", "to", "treat", "union", "variable", "|", "||", or end of input but "u" found. (: Name: function-declaration-04 :) (: Description: Function declaration, updating, with vacuous expression. :)  (: insert-start :) declare variable $employees external; (: insert-end :)  declare [Error is around here]updating function local:test ($emp)    { () };  local:test($employees/employees/*[1])
id-insert-expr-01,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-01 :) (: Description: Evaluation of simple insert expression that uses "after" :) (: clause of element bound to a variable. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return insert node <hours>25</hours> after $var/hours[1]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-01 :) (: Description: Evaluation of simple insert expression that uses "after" :) (: clause of element bound to a variable. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return insert [Error is around here]node <hours>25</hours> after $var/hours[1]
id-insert-expr-02,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-02 :) (: Description: Evaluation of simple insert expression that uses "before" clause only of element bound to a :) (: variable. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[1] return    insert node <hours>15</hours> before $var/hours[1]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-02 :) (: Description: Evaluation of simple insert expression that uses "before" clause only of element bound to a :) (: variable. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[1] return    insert [Error is around here]node <hours>15</hours> before $var/hours[1]
id-insert-expr-03,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-03 :) (: Description: Evaluation of simple insert expression that uses "as first and "into"" clauses of element bound to a :) (: variable. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[3] return    insert node <hours>15</hours> as first into $var/hours". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-03 :) (: Description: Evaluation of simple insert expression that uses "as first and "into"" clauses of element bound to a :) (: variable. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[3] return    insert [Error is around here]node <hours>15</hours> as first into $var/hours
id-insert-expr-04,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-04 :) (: Description: Evaluation of simple insert expression that uses "as last" and "into"" clauses of element bound to a :) (: variable. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[3] return    insert node <hours>15</hours> as last into $var/hours". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-04 :) (: Description: Evaluation of simple insert expression that uses "as last" and "into"" clauses of element bound to a :) (: variable. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[3] return    insert [Error is around here]node <hours>15</hours> as last into $var/hours
id-insert-expr-05,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-05 :) (: Description: Evaluation of simple insert expression that uses "into" clause only for element bound to a :) (: variable. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[3] return    insert node <hours>15</hours> into $var/hours". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-05 :) (: Description: Evaluation of simple insert expression that uses "into" clause only for element bound to a :) (: variable. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[3] return    insert [Error is around here]node <hours>15</hours> into $var/hours
id-insert-expr-06,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-06 :) (: Description: Evaluation of simple insert expression that uses "after" clause only for an attribute. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[3] return    insert node attribute type {"Part Time"} after $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-06 :) (: Description: Evaluation of simple insert expression that uses "after" clause only for an attribute. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[3] return    insert [Error is around here]node attribute type {"Part Time"} after $var
id-insert-expr-07,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-07 :) (: Description: Evaluation of simple insert expression that uses "before" clause only for an attribute. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[3] return    insert node attribute type {"Part Time"} before $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-07 :) (: Description: Evaluation of simple insert expression that uses "before" clause only for an attribute. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[3] return    insert [Error is around here]node attribute type {"Part Time"} before $var
id-insert-expr-08,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-08 :) (: Description: Evaluation of simple insert expression that uses "as first" and "into" clause only for an attribute. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[4] return    insert node attribute type {"Part Time"} as first into $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-08 :) (: Description: Evaluation of simple insert expression that uses "as first" and "into" clause only for an attribute. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[4] return    insert [Error is around here]node attribute type {"Part Time"} as first into $var
id-insert-expr-09,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-09 :) (: Description: Evaluation of simple insert expression that uses "as last" and "into" clause only for an attribute. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[4] return    insert node attribute type {"Part Time"} as last into $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-09 :) (: Description: Evaluation of simple insert expression that uses "as last" and "into" clause only for an attribute. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[4] return    insert [Error is around here]node attribute type {"Part Time"} as last into $var
id-insert-expr-010,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-010 :) (: Description: Evaluation of simple insert expression that uses "into" clause only for an attribute. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[4] return    insert node attribute type {"Part Time"} into $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-010 :) (: Description: Evaluation of simple insert expression that uses "into" clause only for an attribute. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[4] return    insert [Error is around here]node attribute type {"Part Time"} into $var
id-insert-expr-011,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-011 :) (: Description: Evaluation of simple insert expression that uses "after" clause only for a comment node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[1]/hours[1] return    insert node <!-- A Comment Node --> after $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-011 :) (: Description: Evaluation of simple insert expression that uses "after" clause only for a comment node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[1]/hours[1] return    insert [Error is around here]node <!-- A Comment Node --> after $var
id-insert-expr-012,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-012 :) (: Description: Evaluation of simple insert expression that uses "before" clause only for a comment node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[1]/hours[1] return    insert node <!-- A Comment Node --> before $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-012 :) (: Description: Evaluation of simple insert expression that uses "before" clause only for a comment node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[1]/hours[1] return    insert [Error is around here]node <!-- A Comment Node --> before $var
id-insert-expr-013,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-013 :) (: Description: Evaluation of simple insert expression that uses "as first" and "into" clauses for a comment node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[1]/hours[1] return    insert node <!-- A Comment Node --> as first into $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-013 :) (: Description: Evaluation of simple insert expression that uses "as first" and "into" clauses for a comment node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[1]/hours[1] return    insert [Error is around here]node <!-- A Comment Node --> as first into $var
id-insert-expr-014,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-014 :) (: Description: Evaluation of simple insert expression that uses "as last" and "into" clauses for a comment node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[1]/hours[1] return    insert node <!-- A Comment Node --> as last into $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-014 :) (: Description: Evaluation of simple insert expression that uses "as last" and "into" clauses for a comment node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[1]/hours[1] return    insert [Error is around here]node <!-- A Comment Node --> as last into $var
id-insert-expr-015,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-015 :) (: Description: Evaluation of simple insert expression that uses "into" clause only for a comment node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[1]/hours[1] return    insert node <!-- A Comment Node --> into $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-015 :) (: Description: Evaluation of simple insert expression that uses "into" clause only for a comment node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1]/employee[1]/hours[1] return    insert [Error is around here]node <!-- A Comment Node --> into $var
id-insert-expr-016,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-016 :) (: Description: Evaluation of simple insert expression that uses "before" clause to insert element :) (: into a variable bound to an external source. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    insert node <hours>15</hours> before $var/hours[1]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-016 :) (: Description: Evaluation of simple insert expression that uses "before" clause to insert element :) (: into a variable bound to an external source. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    insert [Error is around here]node <hours>15</hours> before $var/hours[1]
id-insert-expr-017,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-017 :) (: Description: Evaluation of simple insert expression that uses "after" clause to insert element :) (: into a variable bound to an external source. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[3] return    insert node <hours>15</hours> after $var/hours[1]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-017 :) (: Description: Evaluation of simple insert expression that uses "after" clause to insert element :) (: into a variable bound to an external source. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[3] return    insert [Error is around here]node <hours>15</hours> after $var/hours[1]
id-insert-expr-018,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-018 :) (: Description: Evaluation of simple insert expression that uses "as first" and "into" clauses to insert element :) (: into a variable bound to an xml source. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1]/hours[1] return   insert node <hours>15</hours> as first into $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-018 :) (: Description: Evaluation of simple insert expression that uses "as first" and "into" clauses to insert element :) (: into a variable bound to an xml source. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1]/hours[1] return   insert [Error is around here]node <hours>15</hours> as first into $var
id-insert-expr-019,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-019 :) (: Description: Evaluation of simple insert expression that uses "as last" and "into" clauses to insert element :) (: into a variable bound to an xml source. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1]/hours[1] return    insert node <hours>15</hours> as last into $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-019 :) (: Description: Evaluation of simple insert expression that uses "as last" and "into" clauses to insert element :) (: into a variable bound to an xml source. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1]/hours[1] return    insert [Error is around here]node <hours>15</hours> as last into $var
id-insert-expr-020,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-020 :) (: Description: Evaluation of simple insert expression that uses "into" clause only to insert element :) (: into a variable bound to an xml source. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return    insert node <hours>15</hours> into $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-020 :) (: Description: Evaluation of simple insert expression that uses "into" clause only to insert element :) (: into a variable bound to an xml source. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return    insert [Error is around here]node <hours>15</hours> into $var
id-insert-expr-021,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-021 :) (: Description: Evaluation of simple insert expression that uses "after" clause only to insert a sequence :) (: of element nodes into a element from an xml source. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2]/hours[1] return   insert node (<hours>15</hours>,<hours>20</hours>) after $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-021 :) (: Description: Evaluation of simple insert expression that uses "after" clause only to insert a sequence :) (: of element nodes into a element from an xml source. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2]/hours[1] return   insert [Error is around here]node (<hours>15</hours>,<hours>20</hours>) after $var
id-insert-expr-022,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-022 :) (: Description: Evaluation of simple insert expression that uses "into" clause only to insert a sequence :) (: of elements into an XML data source :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return    insert node (<hours>15</hours>,<hours>20</hours>) into $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-022 :) (: Description: Evaluation of simple insert expression that uses "into" clause only to insert a sequence :) (: of elements into an XML data source :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return    insert [Error is around here]node (<hours>15</hours>,<hours>20</hours>) into $var
id-insert-expr-023,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-023 :) (: Description: Evaluation of simple insert expression where source expression is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return    insert node (insert node <salary>150000</salary> into $var) into $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-023 :) (: Description: Evaluation of simple insert expression where source expression is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return    insert [Error is around here]node (insert node <salary>150000</salary> into $var) into $var
id-insert-expr-024,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-024 :) (: Description: Evaluation of simple insert expression where target expression is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return    insert node <salary>100000</salary> into (insert node <salary>150000</salary> into $var)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-024 :) (: Description: Evaluation of simple insert expression where target expression is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return    insert [Error is around here]node <salary>100000</salary> into (insert node <salary>150000</salary> into $var)
id-insert-expr-025,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-025 :) (: Description: Evaluation of simple insert expression where both the source and the target expressions updating  :) (: expressions. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return    insert node (insert node <salary>50000</salary> into $var) into (insert node <salary>56000</salary> into $var)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-025 :) (: Description: Evaluation of simple insert expression where both the source and the target expressions updating  :) (: expressions. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return    insert [Error is around here]node (insert node <salary>50000</salary> into $var) into (insert node <salary>56000</salary> into $var)
id-insert-expr-026,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-026 :) (: Description: Evaluation of insert expression where the source expression have a sequence of an attribute following :) (: an element node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return    insert node (<salary>10000</salary>, attribute myAttr {"my Value"} ) into $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-026 :) (: Description: Evaluation of insert expression where the source expression have a sequence of an attribute following :) (: an element node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return    insert [Error is around here]node (<salary>10000</salary>, attribute myAttr {"my Value"} ) into $var
id-insert-expr-027,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-027 :) (: Description: Evaluation of insert expression where the target expression is a sequence of nodes. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := ($input-context/employees[1]/employee[1],$input-context/employees[1]/employee[2]) return    insert node <salary>100000</salary> into $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-027 :) (: Description: Evaluation of insert expression where the target expression is a sequence of nodes. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := ($input-context/employees[1]/employee[1],$input-context/employees[1]/employee[2]) return    insert [Error is around here]node <salary>100000</salary> into $var
id-insert-expr-028,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-028 :) (: Description: Evaluation of insert expression where the target expression is the empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return    insert node <salary>100000</salary> into ()". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-028 :) (: Description: Evaluation of insert expression where the target expression is the empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return    insert [Error is around here]node <salary>100000</salary> into ()
id-insert-expr-029,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-029 :) (: Description: Evaluation of insert expression where the target expression evaluates to a number. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return    insert node <salary>100000</salary> into xs:int(2 + 2)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-029 :) (: Description: Evaluation of insert expression where the target expression evaluates to a number. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return    insert [Error is around here]node <salary>100000</salary> into xs:int(2 + 2)
id-insert-expr-030,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-030 :) (: Description: Evaluation of insert expression where the source expression evaluates to a number. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return   insert node xs:integer(1 + 1) into $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-030 :) (: Description: Evaluation of insert expression where the source expression evaluates to a number. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return   insert [Error is around here]node xs:integer(1 + 1) into $var
id-insert-expr-031,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-031 :) (: Description: Evaluation of insert expression where the target expression is a complex expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    insert node <hours>20</hours> after $var/hours[xs:integer(9-3) idiv 6]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-031 :) (: Description: Evaluation of insert expression where the target expression is a complex expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    insert [Error is around here]node <hours>20</hours> after $var/hours[xs:integer(9-3) idiv 6]
id-insert-expr-032,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-032 :) (: Description: Evaluation of insert expression where a sequence of attributes is inserted as first. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    insert node (attribute type  {"Part Time"}, attribute age {"26"}) as first into $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-032 :) (: Description: Evaluation of insert expression where a sequence of attributes is inserted as first. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    insert [Error is around here]node (attribute type  {"Part Time"}, attribute age {"26"}) as first into $var
id-insert-expr-033,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-033 :) (: Description: Evaluation of insert expression where a sequence of attributes is inserted as last. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    insert node (attribute type  {"Part Time"}, attribute age {"26"}) as last into $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-033 :) (: Description: Evaluation of insert expression where a sequence of attributes is inserted as last. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    insert [Error is around here]node (attribute type  {"Part Time"}, attribute age {"26"}) as last into $var
id-insert-expr-034,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-034 :) (: Description: Evaluation of insert expression where a sequence of elements is inserted as first. Make sure order is mantained. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    insert node (<type>Part Time</type>,<age>26</age>) as first into $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-034 :) (: Description: Evaluation of insert expression where a sequence of elements is inserted as first. Make sure order is mantained. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    insert [Error is around here]node (<type>Part Time</type>,<age>26</age>) as first into $var
id-insert-expr-035,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-035 :) (: Description: Evaluation of insert expression where a sequence of elements is inserted as last. Make sure order is mantained. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    insert node (<type>Part Time</type>,<age>26</age>) as last into $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-035 :) (: Description: Evaluation of insert expression where a sequence of elements is inserted as last. Make sure order is mantained. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    insert [Error is around here]node (<type>Part Time</type>,<age>26</age>) as last into $var
id-insert-expr-036,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-036 :) (: Description: Evaluation of insert expression where a sequence of elements is inserted as using "before" clause. Make sure order is mantained. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    insert node (<type>Part Time</type>,<age>26</age>) before $var/empnum[1]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-036 :) (: Description: Evaluation of insert expression where a sequence of elements is inserted as using "before" clause. Make sure order is mantained. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    insert [Error is around here]node (<type>Part Time</type>,<age>26</age>) before $var/empnum[1]
id-insert-expr-037,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-036 :) (: Description: Evaluation of insert expression where a sequence of elements is inserted as using "before" clause. Make sure order is mantained. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    insert node (<type>Part Time</type>,<age>26</age>) before $var/empnum[1]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-036 :) (: Description: Evaluation of insert expression where a sequence of elements is inserted as using "before" clause. Make sure order is mantained. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    insert [Error is around here]node (<type>Part Time</type>,<age>26</age>) before $var/empnum[1]
id-insert-expr-038,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-038 :) (: Description: Evaluation of insert expression where a sequence of comments is inserted as using "before" clause. Make sure order is mantained. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return   insert node (<!-- First Inserted Comment -->,<!-- Second Inserted Comment -->) before $var/empnum[1]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-038 :) (: Description: Evaluation of insert expression where a sequence of comments is inserted as using "before" clause. Make sure order is mantained. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return   insert [Error is around here]node (<!-- First Inserted Comment -->,<!-- Second Inserted Comment -->) before $var/empnum[1]
id-insert-expr-039,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-039 :) (: Description: Evaluation of insert expression where a sequence of comments is inserted as using "after" clause. Make sure order is mantained. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    insert node (<!-- First Inserted Comment -->,<!-- Second Inserted Comment -->) after $var/empnum[1]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-039 :) (: Description: Evaluation of insert expression where a sequence of comments is inserted as using "after" clause. Make sure order is mantained. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    insert [Error is around here]node (<!-- First Inserted Comment -->,<!-- Second Inserted Comment -->) after $var/empnum[1]
id-insert-expr-040,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-040 :) (: Description: Evaluation of insert expression where a two groups of element nodes is inserted as using "after" clause. Make sure order is mantained within groups. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return (   insert node (<type>Part Time</type>,<age>26</age>) after $var/empnum[1],   insert node (<type>Full Time</type>,<age>30</age>) after $var/empnum[1] )". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-insert-expr-040 :) (: Description: Evaluation of insert expression where a two groups of element nodes is inserted as using "after" clause. Make sure order is mantained within groups. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return (   insert [Error is around here]node (<type>Part Time</type>,<age>26</age>) after $var/empnum[1],   insert node (<type>Full Time</type>,<age>30</age>) after $var/empnum[1] )
id-insert-expr-041,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-041 :) (: Description: Evaluation of insert expression where a two groups of element nodes is inserted as using "before" clause. Make sure order is mantained within groups. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return (   insert node (<type>Part Time</type>,<age>26</age>) before $var/empnum[1],   insert node (<type>Full Time</type>,<age>30</age>) before $var/empnum[1] )". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-insert-expr-041 :) (: Description: Evaluation of insert expression where a two groups of element nodes is inserted as using "before" clause. Make sure order is mantained within groups. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return (   insert [Error is around here]node (<type>Part Time</type>,<age>26</age>) before $var/empnum[1],   insert node (<type>Full Time</type>,<age>30</age>) before $var/empnum[1] )
id-insert-expr-042,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-042 :) (: Description: Evaluation of insert expression where a two groups of element nodes is inserted as using "before" and "after" clauses respectively. Make sure order is mantained within groups. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (insert node (<type>Part Time</type>,<age>26</age>) before $var/empnum[1],   insert node (<type>Full Time</type>,<age>30</age>) after $var/empnum[1])". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-insert-expr-042 :) (: Description: Evaluation of insert expression where a two groups of element nodes is inserted as using "before" and "after" clauses respectively. Make sure order is mantained within groups. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (insert [Error is around here]node (<type>Part Time</type>,<age>26</age>) before $var/empnum[1],   insert node (<type>Full Time</type>,<age>30</age>) after $var/empnum[1])
id-insert-expr-043,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-043 :) (: Description: Evaluation of insert expression where a two groups of element nodes is inserted as using "after" and "before" clauses respectively. Make sure order is mantained within groups. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (insert node (<type>Part Time</type>,<age>26</age>) after $var/empnum[1],   insert node (<type>Full Time</type>,<age>30</age>) before $var/empnum[1])". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-insert-expr-043 :) (: Description: Evaluation of insert expression where a two groups of element nodes is inserted as using "after" and "before" clauses respectively. Make sure order is mantained within groups. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (insert [Error is around here]node (<type>Part Time</type>,<age>26</age>) after $var/empnum[1],   insert node (<type>Full Time</type>,<age>30</age>) before $var/empnum[1])
id-insert-expr-044,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-044 :) (: Description: Evaluation of insert expression, where the spource expression is a transform expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return  insert node (copy $newVar := $var modify delete node $newVar/hours[1] return $newVar)     after $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-044 :) (: Description: Evaluation of insert expression, where the spource expression is a transform expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return  insert [Error is around here]node (copy $newVar := $var modify delete node $newVar/hours[1] return $newVar)     after $var
id-insert-expr-045,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-045 :) (: Description: Evaluation of insert expression, where the before clause is used and the result is a document node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context return  insert node <hours>10</hours> before $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-045 :) (: Description: Evaluation of insert expression, where the before clause is used and the result is a document node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context return  insert [Error is around here]node <hours>10</hours> before $var
id-insert-expr-046,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-046 :) (: Description: Evaluation of insert expression, where the after clause is used and the result is a document node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context return  insert node <hours>10</hours> after $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-046 :) (: Description: Evaluation of insert expression, where the after clause is used and the result is a document node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context return  insert [Error is around here]node <hours>10</hours> after $var
id-insert-expr-047,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-047 :) (: Description: Evaluation of insert expression, where the target is a comment node and usage of "after" clause. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[4]/comment() return  insert node <hours>10</hours> after $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-047 :) (: Description: Evaluation of insert expression, where the target is a comment node and usage of "after" clause. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[4]/comment() return  insert [Error is around here]node <hours>10</hours> after $var
id-insert-expr-048,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-048 :) (: Description: Evaluation of insert expression, where the target is a comment node and usage of "before" clause. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[4]/comment() return  insert node <hours>10</hours> before $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-048 :) (: Description: Evaluation of insert expression, where the target is a comment node and usage of "before" clause. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[4]/comment() return  insert [Error is around here]node <hours>10</hours> before $var
id-insert-expr-049,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-049 :) (: Description: Evaluation of insert expression, where two nodes are inserted into the same node using the "as first" clause". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return  (insert node <hours>45</hours> as first into $var,insert node <hours>46</hours> as first into $var)". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-insert-expr-049 :) (: Description: Evaluation of insert expression, where two nodes are inserted into the same node using the "as first" clause". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return  (insert [Error is around here]node <hours>45</hours> as first into $var,insert node <hours>46</hours> as first into $var)
id-insert-expr-050,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-050 :) (: Description: Evaluation of insert expression, where two nodes are inserted into the same node using the "as last" clause". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return  (insert node <hours>45</hours> as last into $var, insert node <hours>46</hours> as last into $var)". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-insert-expr-050 :) (: Description: Evaluation of insert expression, where two nodes are inserted into the same node using the "as last" clause". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return  (insert [Error is around here]node <hours>45</hours> as last into $var, insert node <hours>46</hours> as last into $var)
id-insert-expr-051,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-051 :) (: Description: Same as id-insert-expr-01, but using keyword "nodes". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return insert nodes <hours>25</hours> after $var/hours[1]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-051 :) (: Description: Same as id-insert-expr-01, but using keyword "nodes". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return insert [Error is around here]nodes <hours>25</hours> after $var/hours[1]
id-insert-expr-052,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-052 :) (: Description: Insert into respects as first, as last, before, and after. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $ot := $input-context/works[1]/employee[@name="John Doe 12"]/overtime return    (    insert nodes <test1/> as first into $ot,    insert nodes <test2/> before $ot/day[. eq "Monday"],    insert nodes <test3/> after $ot/day[. eq "Monday"],    insert nodes <test4/> before $ot/day[. eq "Tuesday"],    insert nodes <test5/> after $ot/day[. eq "Tuesday"],    insert nodes <test6/> as last into  $ot,    insert nodes <test7/> into  $ot    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-insert-expr-052 :) (: Description: Insert into respects as first, as last, before, and after. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $ot := $input-context/works[1]/employee[@name="John Doe 12"]/overtime return    (    insert [Error is around here]nodes <test1/> as first into $ot,    insert nodes <test2/> before $ot/day[. eq "Monday"],    insert nodes <test3/> after $ot/day[. eq "Monday"],    insert nodes <test4/> before $ot/day[. eq "Tuesday"],    insert nodes <test5/> after $ot/day[. eq "Tuesday"],    insert nodes <test6/> as last into  $ot,    insert nodes <test7/> into  $ot    )
id-insert-expr-053,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-053 :) (: Description: Insert empty sequences into, as first, as last, before, and after. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $ot := $input-context/works[1]/employee[@name="John Doe 12"]/overtime return    (    insert nodes () as first into $ot,    insert nodes () before $ot/day[. eq "Monday"],    insert nodes () after $ot/day[. eq "Monday"],    insert nodes () before $ot/day[. eq "Tuesday"],    insert nodes () after $ot/day[. eq "Tuesday"],    insert nodes () as last into  $ot,    insert nodes () into  $ot    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-insert-expr-053 :) (: Description: Insert empty sequences into, as first, as last, before, and after. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $ot := $input-context/works[1]/employee[@name="John Doe 12"]/overtime return    (    insert [Error is around here]nodes () as first into $ot,    insert nodes () before $ot/day[. eq "Monday"],    insert nodes () after $ot/day[. eq "Monday"],    insert nodes () before $ot/day[. eq "Tuesday"],    insert nodes () after $ot/day[. eq "Tuesday"],    insert nodes () as last into  $ot,    insert nodes () into  $ot    )
id-insert-expr-054,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-054 :) (: Description: Insert an element into a comment. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := ($input-context//comment())[1] return    insert node <test/> into $n ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-054 :) (: Description: Insert an element into a comment. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := ($input-context//comment())[1] return    insert [Error is around here]node <test/> into $n
id-insert-expr-055,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-055 :) (: Description: Insert an element into a text node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := ($input-context//text())[1] return    insert node <test/> into $n ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-055 :) (: Description: Insert an element into a text node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := ($input-context//text())[1] return    insert [Error is around here]node <test/> into $n
id-insert-expr-056,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-056 :) (: Description: Insert an element into a PI. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := ($input-context//processing-instruction())[1] return    insert node <test/> into $n ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-056 :) (: Description: Insert an element into a PI. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := ($input-context//processing-instruction())[1] return    insert [Error is around here]node <test/> into $n
id-insert-expr-057,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-057 :) (: Description: Insert a text node into a text node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := ($input-context//text())[1] return    insert node text {"test"} into $n ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-057 :) (: Description: Insert a text node into a text node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := ($input-context//text())[1] return    insert [Error is around here]node text {"test"} into $n
id-insert-expr-058,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-058 :) (: Description: Insert an element before an attribute. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $emp := $input-context/works[1]/employee[1] return    insert node <test/> before $emp/@name ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-058 :) (: Description: Insert an element before an attribute. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $emp := $input-context/works[1]/employee[1] return    insert [Error is around here]node <test/> before $emp/@name
id-insert-expr-059,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-059 :) (: Description: Insert an element after an attribute. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $emp := $input-context/works[1]/employee[1] return    insert node <test/> after $emp/@name ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-059 :) (: Description: Insert an element after an attribute. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $emp := $input-context/works[1]/employee[1] return    insert [Error is around here]node <test/> after $emp/@name
id-insert-expr-060,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-060 :) (: Description: Insert an attribute before an attribute. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $emp := $input-context/works[1]/employee[1] return    insert node attribute exempt { "true" } before $emp/@name ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-060 :) (: Description: Insert an attribute before an attribute. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $emp := $input-context/works[1]/employee[1] return    insert [Error is around here]node attribute exempt { "true" } before $emp/@name
id-insert-expr-061,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-061 :) (: Description: Insert an attribute after an attribute. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $emp := $input-context/works[1]/employee[1] return    insert node attribute exempt { "true" } after $emp/@name ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-061 :) (: Description: Insert an attribute after an attribute. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $emp := $input-context/works[1]/employee[1] return    insert [Error is around here]node attribute exempt { "true" } after $emp/@name
id-insert-expr-062,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-062 :) (: Description: Insert an element before an element without a parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $emp := <employee/> return    insert node <test/> before $emp ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-062 :) (: Description: Insert an element before an element without a parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $emp := <employee/> return    insert [Error is around here]node <test/> before $emp
id-insert-expr-063,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-063 :) (: Description: Insert an element after an element without a parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $emp := <employee/> return    insert node <test/> after $emp ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-063 :) (: Description: Insert an element after an element without a parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $emp := <employee/> return    insert [Error is around here]node <test/> after $emp
id-insert-expr-064,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-064 :) (: Description: Insert an attribute into a comment. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := ($input-context//comment())[1] return    insert node attribute day { "good" } into $n ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-064 :) (: Description: Insert an attribute into a comment. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := ($input-context//comment())[1] return    insert [Error is around here]node attribute day { "good" } into $n
id-insert-expr-065,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-065 :) (: Description: Insert an attribute into a text node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := ($input-context//text())[1] return    insert node attribute day { "good" } into $n ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-065 :) (: Description: Insert an attribute into a text node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := ($input-context//text())[1] return    insert [Error is around here]node attribute day { "good" } into $n
id-insert-expr-066,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-066 :) (: Description: Insert an attribute into a PI. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := ($input-context//processing-instruction())[1] return    insert node attribute day { "good" } into $n ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-066 :) (: Description: Insert an attribute into a PI. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := ($input-context//processing-instruction())[1] return    insert [Error is around here]node attribute day { "good" } into $n
id-insert-expr-067,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-067 :) (: Description: Insert an attribute into a document. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := $input-context return    insert node attribute day { "good" } into $n ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-067 :) (: Description: Insert an attribute into a document. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := $input-context return    insert [Error is around here]node attribute day { "good" } into $n
id-insert-expr-068,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-068 :) (: Description: Insert an attribute into an attribute. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := $input-context/works[1]/employee[1] return    insert node attribute day { "good" } into $n/@name ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-068 :) (: Description: Insert an attribute into an attribute. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := $input-context/works[1]/employee[1] return    insert [Error is around here]node attribute day { "good" } into $n/@name
id-insert-expr-069,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-069 :) (: Description: Insert an attribute before an element without a parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $emp := <employee/> return    insert node attribute test { "123" } before $emp ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-069 :) (: Description: Insert an attribute before an element without a parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $emp := <employee/> return    insert [Error is around here]node attribute test { "123" } before $emp
id-insert-expr-070,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-070 :) (: Description: Insert an attribute after an element without a parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $emp := <employee/> return    insert node attribute test { "123" } after $emp ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-070 :) (: Description: Insert an attribute after an element without a parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $emp := <employee/> return    insert [Error is around here]node attribute test { "123" } after $emp
id-insert-expr-071,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-071 :) (: Description: Insert an attribute before a text node without a parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := text { "alone" } return    insert node attribute test { "123" } before $n ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-071 :) (: Description: Insert an attribute before a text node without a parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := text { "alone" } return    insert [Error is around here]node attribute test { "123" } before $n
id-insert-expr-072,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-072 :) (: Description: Insert an attribute after a text node without a parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := text { "alone" } return    insert node attribute test { "123" } after $n ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-072 :) (: Description: Insert an attribute after a text node without a parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := text { "alone" } return    insert [Error is around here]node attribute test { "123" } after $n
id-insert-expr-073,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-073 :) (: Description: Insert an attribute before a comment without a parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := comment { "alone" } return    insert node attribute test { "123" } before $n ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-073 :) (: Description: Insert an attribute before a comment without a parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := comment { "alone" } return    insert [Error is around here]node attribute test { "123" } before $n
id-insert-expr-074,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-074 :) (: Description: Insert an attribute after a comment without a parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := comment { "alone" } return    insert node attribute test { "123" } after $n ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-074 :) (: Description: Insert an attribute after a comment without a parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := comment { "alone" } return    insert [Error is around here]node attribute test { "123" } after $n
id-insert-expr-075,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-075 :) (: Description: Insert an attribute before a PI without a parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := processing-instruction audio-output { "beep"} return    insert node attribute test { "123" } before $n ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-075 :) (: Description: Insert an attribute before a PI without a parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := processing-instruction audio-output { "beep"} return    insert [Error is around here]node attribute test { "123" } before $n
id-insert-expr-076,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-076 :) (: Description: Insert an attribute after a PI without a parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := processing-instruction audio-output { "beep"} return    insert node attribute test { "123" } after $n ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-076 :) (: Description: Insert an attribute after a PI without a parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $n := processing-instruction audio-output { "beep"} return    insert [Error is around here]node attribute test { "123" } after $n
id-insert-expr-077,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-077 :) (: Description: Insert text nodes as first, as last, before, and after. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $ot := $input-context/works[1]/employee[@name="John Doe 12"]/overtime return    (    insert nodes text { "test1" } as first into $ot,    insert nodes text { "test2" } before $ot/day[. eq "Monday"],    insert nodes text { "test3" } after $ot/day[. eq "Monday"],    insert nodes text { "test4" } before $ot/day[. eq "Tuesday"],    insert nodes text { "test5" } after $ot/day[. eq "Tuesday"],    insert nodes text { "test6" } as last into  $ot    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-insert-expr-077 :) (: Description: Insert text nodes as first, as last, before, and after. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $ot := $input-context/works[1]/employee[@name="John Doe 12"]/overtime return    (    insert [Error is around here]nodes text { "test1" } as first into $ot,    insert nodes text { "test2" } before $ot/day[. eq "Monday"],    insert nodes text { "test3" } after $ot/day[. eq "Monday"],    insert nodes text { "test4" } before $ot/day[. eq "Tuesday"],    insert nodes text { "test5" } after $ot/day[. eq "Tuesday"],    insert nodes text { "test6" } as last into  $ot    )
id-insert-expr-078,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-078 :) (: Description: Insert PI as first, as last, before, and after. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $ot := $input-context/works[1]/employee[@name="John Doe 12"]/overtime return    (    insert nodes processing-instruction audio-output { "beep1" } as first into $ot,    insert nodes processing-instruction audio-output { "beep2" } before $ot/day[. eq "Monday"],    insert nodes processing-instruction audio-output { "beep3" } after $ot/day[. eq "Monday"],    insert nodes processing-instruction audio-output { "beep4" } before $ot/day[. eq "Tuesday"],    insert nodes processing-instruction audio-output { "beep5" } after $ot/day[. eq "Tuesday"],    insert nodes processing-instruction audio-output { "beep6" } as last into  $ot    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-insert-expr-078 :) (: Description: Insert PI as first, as last, before, and after. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $ot := $input-context/works[1]/employee[@name="John Doe 12"]/overtime return    (    insert [Error is around here]nodes processing-instruction audio-output { "beep1" } as first into $ot,    insert nodes processing-instruction audio-output { "beep2" } before $ot/day[. eq "Monday"],    insert nodes processing-instruction audio-output { "beep3" } after $ot/day[. eq "Monday"],    insert nodes processing-instruction audio-output { "beep4" } before $ot/day[. eq "Tuesday"],    insert nodes processing-instruction audio-output { "beep5" } after $ot/day[. eq "Tuesday"],    insert nodes processing-instruction audio-output { "beep6" } as last into  $ot    )
id-insert-expr-079,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-079 :) (: Description: Insert a document as first. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $ot := $input-context/works[1]/employee[@name="John Doe 12"]/overtime return    insert node $input-context as first into $ot ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-079 :) (: Description: Insert a document as first. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $ot := $input-context/works[1]/employee[@name="John Doe 12"]/overtime return    insert [Error is around here]node $input-context as first into $ot
id-insert-expr-080,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-080 :) (: Description: Insert a mixed sequence as first, as last, before, and after. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $ot := $input-context/works[1]/employee[@name="John Doe 12"]/overtime return    (    insert nodes (text {"test1"}, <test1/>) as first into $ot,    insert nodes (text {"test2"}, <test2/>) before $ot/day[. eq "Monday"],    insert nodes (text {"test3"}, <test3/>) after $ot/day[. eq "Monday"],    insert nodes (text {"test4"}, <test4/>) before $ot/day[. eq "Tuesday"],    insert nodes (text {"test5"}, <test5/>) after $ot/day[. eq "Tuesday"],    insert nodes (text {"test6"}, <test6/>) as last into  $ot    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-insert-expr-080 :) (: Description: Insert a mixed sequence as first, as last, before, and after. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $ot := $input-context/works[1]/employee[@name="John Doe 12"]/overtime return    (    insert [Error is around here]nodes (text {"test1"}, <test1/>) as first into $ot,    insert nodes (text {"test2"}, <test2/>) before $ot/day[. eq "Monday"],    insert nodes (text {"test3"}, <test3/>) after $ot/day[. eq "Monday"],    insert nodes (text {"test4"}, <test4/>) before $ot/day[. eq "Tuesday"],    insert nodes (text {"test5"}, <test5/>) after $ot/day[. eq "Tuesday"],    insert nodes (text {"test6"}, <test6/>) as last into  $ot    )
id-insert-expr-081,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-081 :) (: Description: Check namepsace propogation when inserting an element. :)  declare copy-namespaces preserve, inherit;  declare namespace myco="http://www.example.com/myco";  (: insert-start :) (: insert-end :)  let $myemps :=       <myco:employees>                        <myco:employee id='100'>                           <myco:name>Samuel</myco:name>                        </myco:employee>                      </myco:employees> let $newemps :=    copy $e := $myemps    modify insert node <dependents/> into $e/myco:employee[1]    return $e return     namespace-uri-for-prefix("myco",                              $newemps/myco:employee[1]/dependents[1]) ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-insert-expr-081 :) (: Description: Check namepsace propogation when inserting an element. :)  declare copy-namespaces preserve, inherit;  declare namespace myco="http://www.example.com/myco";  (: insert-start :) (: insert-end :)  let $myemps :=       <myco:employees>                        <myco:employee id='100'>                           <myco:name>Samuel</myco:name>                        </myco:employee>                      </myco:employees> let $newemps :=    copy $e := $myemps    modify insert [Error is around here]node <dependents/> into $e/myco:employee[1]    return $e return     namespace-uri-for-prefix("myco",                              $newemps/myco:employee[1]/dependents[1])
id-insert-expr-082,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-082 :) (: Description: Check namepsace propogation when inserting an element. :)  declare copy-namespaces preserve, inherit;  declare namespace myco="http://www.example.com/myco";  (: insert-start :) (: insert-end :)  let $myemps :=       <myco:employees>                        <myco:employee id='100'>                           <myco:name>Samuel</myco:name>                        </myco:employee>                      </myco:employees> let $newemps :=    copy $e := $myemps    modify insert node <dependents/> as first into $e/myco:employee[1]    return $e return     namespace-uri-for-prefix("myco",                              $newemps/myco:employee[1]/dependents[1]) ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-insert-expr-082 :) (: Description: Check namepsace propogation when inserting an element. :)  declare copy-namespaces preserve, inherit;  declare namespace myco="http://www.example.com/myco";  (: insert-start :) (: insert-end :)  let $myemps :=       <myco:employees>                        <myco:employee id='100'>                           <myco:name>Samuel</myco:name>                        </myco:employee>                      </myco:employees> let $newemps :=    copy $e := $myemps    modify insert [Error is around here]node <dependents/> as first into $e/myco:employee[1]    return $e return     namespace-uri-for-prefix("myco",                              $newemps/myco:employee[1]/dependents[1])
id-insert-expr-083,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-083 :) (: Description: Check namepsace propogation when inserting an element. :)  declare copy-namespaces preserve, inherit;  declare namespace myco="http://www.example.com/myco";  (: insert-start :) (: insert-end :)  let $myemps :=       <myco:employees>                        <myco:employee id='100'>                           <myco:name>Samuel</myco:name>                        </myco:employee>                      </myco:employees> let $newemps :=    copy $e := $myemps    modify insert node <dependents/> as last into $e/myco:employee[1]    return $e return     namespace-uri-for-prefix("myco",                              $newemps/myco:employee[1]/dependents[1]) ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-insert-expr-083 :) (: Description: Check namepsace propogation when inserting an element. :)  declare copy-namespaces preserve, inherit;  declare namespace myco="http://www.example.com/myco";  (: insert-start :) (: insert-end :)  let $myemps :=       <myco:employees>                        <myco:employee id='100'>                           <myco:name>Samuel</myco:name>                        </myco:employee>                      </myco:employees> let $newemps :=    copy $e := $myemps    modify insert [Error is around here]node <dependents/> as last into $e/myco:employee[1]    return $e return     namespace-uri-for-prefix("myco",                              $newemps/myco:employee[1]/dependents[1])
id-insert-expr-084,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-084 :) (: Description: Check namepsace propogation when inserting an element. :)  declare copy-namespaces preserve, inherit;  declare namespace myco="http://www.example.com/myco";  (: insert-start :) (: insert-end :)  let $myemps :=       <myco:employees>                        <myco:employee id='100'>                           <myco:name>Samuel</myco:name>                        </myco:employee>                      </myco:employees> let $newemps :=    copy $e := $myemps    modify insert node <dependents/> before $e/myco:employee[1]    return $e return     namespace-uri-for-prefix("myco",                              $newemps/dependents[1]) ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-insert-expr-084 :) (: Description: Check namepsace propogation when inserting an element. :)  declare copy-namespaces preserve, inherit;  declare namespace myco="http://www.example.com/myco";  (: insert-start :) (: insert-end :)  let $myemps :=       <myco:employees>                        <myco:employee id='100'>                           <myco:name>Samuel</myco:name>                        </myco:employee>                      </myco:employees> let $newemps :=    copy $e := $myemps    modify insert [Error is around here]node <dependents/> before $e/myco:employee[1]    return $e return     namespace-uri-for-prefix("myco",                              $newemps/dependents[1])
id-insert-expr-085,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-085 :) (: Description: Check namepsace propogation when inserting an element. :)  declare copy-namespaces preserve, inherit;  declare namespace myco="http://www.example.com/myco";  (: insert-start :) (: insert-end :)  let $myemps :=       <myco:employees>                        <myco:employee id='100'>                           <myco:name>Samuel</myco:name>                        </myco:employee>                      </myco:employees> let $newemps :=    copy $e := $myemps    modify insert node <dependents/> after $e/myco:employee[1]    return $e return     namespace-uri-for-prefix("myco",                              $newemps/dependents[1]) ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-insert-expr-085 :) (: Description: Check namepsace propogation when inserting an element. :)  declare copy-namespaces preserve, inherit;  declare namespace myco="http://www.example.com/myco";  (: insert-start :) (: insert-end :)  let $myemps :=       <myco:employees>                        <myco:employee id='100'>                           <myco:name>Samuel</myco:name>                        </myco:employee>                      </myco:employees> let $newemps :=    copy $e := $myemps    modify insert [Error is around here]node <dependents/> after $e/myco:employee[1]    return $e return     namespace-uri-for-prefix("myco",                              $newemps/dependents[1])
id-insert-expr-086,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-086 :) (: Description: Check namepsace propogation when inserting an attribute. :)  declare copy-namespaces preserve, inherit;  declare namespace myco="http://www.example.com/myco"; declare namespace hisco="http://www.example.com/hisco";  (: insert-start :) (: insert-end :)  let $myemps :=       <myco:employees>                        <myco:employee id='100'>                           <myco:name>Samuel</myco:name>                        </myco:employee>                      </myco:employees> let $newemps :=    copy $e := $myemps    modify insert node attribute hisco:salaried {"true"} into $e    return $e return     namespace-uri-for-prefix("hisco",                              $newemps/myco:employee[1]) ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-insert-expr-086 :) (: Description: Check namepsace propogation when inserting an attribute. :)  declare copy-namespaces preserve, inherit;  declare namespace myco="http://www.example.com/myco"; declare namespace hisco="http://www.example.com/hisco";  (: insert-start :) (: insert-end :)  let $myemps :=       <myco:employees>                        <myco:employee id='100'>                           <myco:name>Samuel</myco:name>                        </myco:employee>                      </myco:employees> let $newemps :=    copy $e := $myemps    modify insert [Error is around here]node attribute hisco:salaried {"true"} into $e    return $e return     namespace-uri-for-prefix("hisco",                              $newemps/myco:employee[1])
id-insert-expr-081-no-inherit,Error: XPST0003: Unable to parse XPath: " (: Name: id-insert-expr-081 :) (: Description: Check namepsace propogation when inserting an element. :)  declare copy-namespaces preserve, no-inherit;  declare namespace myco="http://www.example.com/myco";  (: insert-start :) (: insert-end :)  let $myemps :=       <myco:employees>                        <myco:employee id='100'>                           <myco:name>Samuel</myco:name>                        </myco:employee>                      </myco:employees> let $newemps :=    copy $e := $myemps    modify insert node <dependents/> into $e/myco:employee[1]    return $e return     namespace-uri-for-prefix("myco", $newemps/myco:employee[1]/dependents[1])  ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found.  (: Name: id-insert-expr-081 :) (: Description: Check namepsace propogation when inserting an element. :)  declare copy-namespaces preserve, no-inherit;  declare namespace myco="http://www.example.com/myco";  (: insert-start :) (: insert-end :)  let $myemps :=       <myco:employees>                        <myco:employee id='100'>                           <myco:name>Samuel</myco:name>                        </myco:employee>                      </myco:employees> let $newemps :=    copy $e := $myemps    modify insert [Error is around here]node <dependents/> into $e/myco:employee[1]    return $e return     namespace-uri-for-prefix("myco", $newemps/myco:employee[1]/dependents[1])
id-insert-expr-082-no-inherit,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-082 :) (: Description: Check namepsace propogation when inserting an element. :)  declare copy-namespaces preserve, no-inherit;  declare namespace myco="http://www.example.com/myco";  (: insert-start :) (: insert-end :)  let $myemps :=       <myco:employees>                        <myco:employee id='100'>                           <myco:name>Samuel</myco:name>                        </myco:employee>                      </myco:employees> let $newemps :=    copy $e := $myemps    modify insert node <dependents/> as first into $e/myco:employee[1]    return $e return     namespace-uri-for-prefix("myco",                              $newemps/myco:employee[1]/dependents[1])". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-insert-expr-082 :) (: Description: Check namepsace propogation when inserting an element. :)  declare copy-namespaces preserve, no-inherit;  declare namespace myco="http://www.example.com/myco";  (: insert-start :) (: insert-end :)  let $myemps :=       <myco:employees>                        <myco:employee id='100'>                           <myco:name>Samuel</myco:name>                        </myco:employee>                      </myco:employees> let $newemps :=    copy $e := $myemps    modify insert [Error is around here]node <dependents/> as first into $e/myco:employee[1]    return $e return     namespace-uri-for-prefix("myco",                              $newemps/myco:employee[1]/dependents[1])
id-insert-expr-083-no-inherit,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-083 :) (: Description: Check namepsace propogation when inserting an element. :)  declare copy-namespaces preserve, no-inherit;  declare namespace myco="http://www.example.com/myco";  (: insert-start :) (: insert-end :)  let $myemps :=       <myco:employees>                        <myco:employee id='100'>                           <myco:name>Samuel</myco:name>                        </myco:employee>                      </myco:employees> let $newemps :=    copy $e := $myemps    modify insert node <dependents/> as last into $e/myco:employee[1]    return $e return     namespace-uri-for-prefix("myco",                              $newemps/myco:employee[1]/dependents[1])". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-insert-expr-083 :) (: Description: Check namepsace propogation when inserting an element. :)  declare copy-namespaces preserve, no-inherit;  declare namespace myco="http://www.example.com/myco";  (: insert-start :) (: insert-end :)  let $myemps :=       <myco:employees>                        <myco:employee id='100'>                           <myco:name>Samuel</myco:name>                        </myco:employee>                      </myco:employees> let $newemps :=    copy $e := $myemps    modify insert [Error is around here]node <dependents/> as last into $e/myco:employee[1]    return $e return     namespace-uri-for-prefix("myco",                              $newemps/myco:employee[1]/dependents[1])
id-insert-expr-084-no-inherit,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-084 :) (: Description: Check namepsace propogation when inserting an element. :)  declare copy-namespaces preserve, no-inherit;  declare namespace myco="http://www.example.com/myco";  (: insert-start :) (: insert-end :)  let $myemps :=       <myco:employees>                        <myco:employee id='100'>                           <myco:name>Samuel</myco:name>                        </myco:employee>                      </myco:employees> let $newemps :=    copy $e := $myemps    modify insert node <dependents/> before $e/myco:employee[1]    return $e return     namespace-uri-for-prefix("myco", $newemps/dependents[1])". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-insert-expr-084 :) (: Description: Check namepsace propogation when inserting an element. :)  declare copy-namespaces preserve, no-inherit;  declare namespace myco="http://www.example.com/myco";  (: insert-start :) (: insert-end :)  let $myemps :=       <myco:employees>                        <myco:employee id='100'>                           <myco:name>Samuel</myco:name>                        </myco:employee>                      </myco:employees> let $newemps :=    copy $e := $myemps    modify insert [Error is around here]node <dependents/> before $e/myco:employee[1]    return $e return     namespace-uri-for-prefix("myco", $newemps/dependents[1])
id-insert-expr-085-no-inherit,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-085 :) (: Description: Check namepsace propogation when inserting an element. :)  declare copy-namespaces preserve, no-inherit;  declare namespace myco="http://www.example.com/myco";  (: insert-start :) (: insert-end :)  let $myemps :=       <myco:employees>                        <myco:employee id='100'>                           <myco:name>Samuel</myco:name>                        </myco:employee>                      </myco:employees> let $newemps :=    copy $e := $myemps    modify insert node <dependents/> after $e/myco:employee[1]    return $e return     namespace-uri-for-prefix("myco", $newemps/dependents[1]) ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-insert-expr-085 :) (: Description: Check namepsace propogation when inserting an element. :)  declare copy-namespaces preserve, no-inherit;  declare namespace myco="http://www.example.com/myco";  (: insert-start :) (: insert-end :)  let $myemps :=       <myco:employees>                        <myco:employee id='100'>                           <myco:name>Samuel</myco:name>                        </myco:employee>                      </myco:employees> let $newemps :=    copy $e := $myemps    modify insert [Error is around here]node <dependents/> after $e/myco:employee[1]    return $e return     namespace-uri-for-prefix("myco", $newemps/dependents[1])
id-insert-expr-086-no-inherit,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-086 :) (: Description: Check namepsace propogation when inserting an attribute. :)  declare copy-namespaces preserve, no-inherit;  declare namespace myco="http://www.example.com/myco"; declare namespace hisco="http://www.example.com/hisco";  (: insert-start :) (: insert-end :)  let $myemps :=       <myco:employees>                        <myco:employee id='100'>                           <myco:name>Samuel</myco:name>                        </myco:employee>                      </myco:employees> let $newemps :=    copy $e := $myemps    modify insert node attribute hisco:salaried {"true"} into $e    return $e return     namespace-uri-for-prefix("hisco",                              $newemps/myco:employee[1]) ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-insert-expr-086 :) (: Description: Check namepsace propogation when inserting an attribute. :)  declare copy-namespaces preserve, no-inherit;  declare namespace myco="http://www.example.com/myco"; declare namespace hisco="http://www.example.com/hisco";  (: insert-start :) (: insert-end :)  let $myemps :=       <myco:employees>                        <myco:employee id='100'>                           <myco:name>Samuel</myco:name>                        </myco:employee>                      </myco:employees> let $newemps :=    copy $e := $myemps    modify insert [Error is around here]node attribute hisco:salaried {"true"} into $e    return $e return     namespace-uri-for-prefix("hisco",                              $newemps/myco:employee[1])
id-insert-expr-087,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-087 :) (: Description: Insert an attribute before an element that does not have an element parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert node attribute test { "123" } before $input-context/far-north[1] ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-087 :) (: Description: Insert an attribute before an element that does not have an element parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert [Error is around here]node attribute test { "123" } before $input-context/far-north[1]
id-insert-expr-088,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-088 :) (: Description: Insert an attribute before an element that does not have an element parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert node attribute test { "123" } after $input-context/far-north[1] ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-088 :) (: Description: Insert an attribute before an element that does not have an element parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert [Error is around here]node attribute test { "123" } after $input-context/far-north[1]
id-insert-expr-089,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-089 :) (: Description: Insert an attribute before a comment that does not have an element parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert node attribute test { "123" } before $input-context/comment()[1] ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-089 :) (: Description: Insert an attribute before a comment that does not have an element parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert [Error is around here]node attribute test { "123" } before $input-context/comment()[1]
id-insert-expr-090,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-090 :) (: Description: Insert an attribute after a comment that does not have an element parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert node attribute test { "123" } after $input-context/comment()[1] ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-090 :) (: Description: Insert an attribute after a comment that does not have an element parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert [Error is around here]node attribute test { "123" } after $input-context/comment()[1]
id-insert-expr-091,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-091 :) (: Description: Insert an attribute before a PI that does not have an element parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert node attribute test { "123" } before $input-context/processing-instruction()[1] ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-091 :) (: Description: Insert an attribute before a PI that does not have an element parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert [Error is around here]node attribute test { "123" } before $input-context/processing-instruction()[1]
id-insert-expr-092,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-092 :) (: Description: Insert an attribute after a PI that does not have an element parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert node attribute test { "123" } after $input-context/processing-instruction()[1] ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-092 :) (: Description: Insert an attribute after a PI that does not have an element parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert [Error is around here]node attribute test { "123" } after $input-context/processing-instruction()[1]
id-insert-expr-093,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-093 :) (: Description: Insert an attribute that requires creation of a new namespace node. :)  declare namespace b="http://ns.example.com/id-insert-expr-093";  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $ot := $input-context/works[1]/employee[@name="John Doe 12"]/overtime return    (    insert node attribute { 'b:newAtt' } {"newValue"} into $ot    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-insert-expr-093 :) (: Description: Insert an attribute that requires creation of a new namespace node. :)  declare namespace b="http://ns.example.com/id-insert-expr-093";  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $ot := $input-context/works[1]/employee[@name="John Doe 12"]/overtime return    (    insert [Error is around here]node attribute { 'b:newAtt' } {"newValue"} into $ot    )
id-insert-expr-094,Error: XPST0003: Unable to parse XPath: "(: Name: id-insert-expr-094 :) (: Description: Insert an attribute that doesn't conflict with an element in the dedault namespace. :)  declare namespace books="http://ns.example.com/books";  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert node attribute ITEMS {count($input-context/books:BOOKLIST/books:BOOKS/books:ITEM)}        into $input-context/books:BOOKLIST/books:BOOKS ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-insert-expr-094 :) (: Description: Insert an attribute that doesn't conflict with an element in the dedault namespace. :)  declare namespace books="http://ns.example.com/books";  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert [Error is around here]node attribute ITEMS {count($input-context/books:BOOKLIST/books:BOOKS/books:ITEM)}        into $input-context/books:BOOKLIST/books:BOOKS
id-delete-expr-01,Error: XPST0003: Unable to parse XPath: "(: Name: id-delete-expr-01 :) (: Description: Evaluation of a delete expression that removes an element from a data source :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[3] return    delete node $var/hours[1]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-delete-expr-01 :) (: Description: Evaluation of a delete expression that removes an element from a data source :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[3] return    delete [Error is around here]node $var/hours[1]
id-delete-expr-02,Error: XPST0003: Unable to parse XPath: "(: Name: id-delete-expr-02 :) (: Description: Evaluation of a delete expression that removes an attribute from an element in a data source :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[4] return    delete node $var/attribute::name". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-delete-expr-02 :) (: Description: Evaluation of a delete expression that removes an attribute from an element in a data source :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[4] return    delete [Error is around here]node $var/attribute::name
id-delete-expr-03,Error: XPST0003: Unable to parse XPath: "(: Name: id-delete-expr-03 :) (: Description: Evaluation of a delete expression that removes a comment from a data source :) (: element node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[13] return    delete node $var/child::comment()". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-delete-expr-03 :) (: Description: Evaluation of a delete expression that removes a comment from a data source :) (: element node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[13] return    delete [Error is around here]node $var/child::comment()
id-delete-expr-04,Error: XPST0003: Unable to parse XPath: "(: Name: id-delete-expr-04 :) (: Description: Evaluation of a delete expression that remove multiple elements from an xml file :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1] return    delete node $var/employee[position() <= 12]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-delete-expr-04 :) (: Description: Evaluation of a delete expression that remove multiple elements from an xml file :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/works[1] return    delete [Error is around here]node $var/employee[position() <= 12]
id-delete-expr-05,Error: XPST0003: Unable to parse XPath: "(: Name: id-delete-expr-05 :) (: Description: Evaluation of a delete expression that remove a sequence of element nodes from a data source :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := ($input-context/works[1]/employee[1],$input-context/works[1]/employee[2],$input-context/works[1]/employee[3],$input-context/works[1]/employee[4]) return    delete node $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-delete-expr-05 :) (: Description: Evaluation of a delete expression that remove a sequence of element nodes from a data source :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := ($input-context/works[1]/employee[1],$input-context/works[1]/employee[2],$input-context/works[1]/employee[3],$input-context/works[1]/employee[4]) return    delete [Error is around here]node $var
id-delete-expr-06,Error: XPST0003: Unable to parse XPath: "(: Name: id-delete-expr-06 :) (: Description: Evaluation of a delete expression where target expression is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] return    delete node (delete node $var/salary[1])". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-delete-expr-06 :) (: Description: Evaluation of a delete expression where target expression is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] return    delete [Error is around here]node (delete node $var/salary[1])
id-delete-expr-07,Error: XPST0003: Unable to parse XPath: "(: Name: id-delete-expr-07 :) (: Description: Evaluation of a delete expression where target expression is mathematical. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] return    delete node (xs:integer($var/salary) + 3)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-delete-expr-07 :) (: Description: Evaluation of a delete expression where target expression is mathematical. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] return    delete [Error is around here]node (xs:integer($var/salary) + 3)
id-delete-expr-08,Error: XPST0003: Unable to parse XPath: "(: Name: id-delete-expr-08 :) (: Description: Evaluation of a delete expression where target expression results in a  sequence of zero nodes. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    delete node ($var/hours[2+1])". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-delete-expr-08 :) (: Description: Evaluation of a delete expression where target expression results in a  sequence of zero nodes. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    delete [Error is around here]node ($var/hours[2+1])
id-delete-expr-09,Error: XPST0003: Unable to parse XPath: "(: Name: id-delete-expr-09 :) (: Description: Evaluation of a delete expression where target expression is set to "()":)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] return    delete node ()". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-delete-expr-09 :) (: Description: Evaluation of a delete expression where target expression is set to "()":)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] return    delete [Error is around here]node ()
id-delete-expr-010,Error: XPST0003: Unable to parse XPath: "(: Name: id-delete-expr-010 :) (: Description: Evaluation of a delete expression where target expression is a complex one:)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    delete node $var/hours[(10 idiv 5) - 1]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-delete-expr-010 :) (: Description: Evaluation of a delete expression where target expression is a complex one:)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    delete [Error is around here]node $var/hours[(10 idiv 5) - 1]
id-delete-expr-011,Error: XPST0003: Unable to parse XPath: "(: Name: id-delete-expr-011 :) (: Description: A delete expression where the target expression results in a sequence of integers. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] return    delete node (xs:integer($var/salary[1]), xs:integer($var/salary[1]))". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-delete-expr-011 :) (: Description: A delete expression where the target expression results in a sequence of integers. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] return    delete [Error is around here]node (xs:integer($var/salary[1]), xs:integer($var/salary[1]))
id-delete-expr-012,Error: XPST0003: Unable to parse XPath: "(: Name: id-delete-expr-012 :) (: Description: Multiple states with multiple deletes. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    delete node $var". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-delete-expr-012 :) (: Description: Multiple states with multiple deletes. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    delete [Error is around here]node $var
id-delete-expr-013,Error: XPST0003: Unable to parse XPath: "(: Name: id-delete-expr-013 :) (: Description: Delete an element node and its parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $ot := $input-context/works[1]/employee[@name="John Doe 12"]/overtime return    (    delete node $ot/day[. eq "Monday"],    delete node $ot    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-delete-expr-013 :) (: Description: Delete an element node and its parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $ot := $input-context/works[1]/employee[@name="John Doe 12"]/overtime return    (    delete [Error is around here]node $ot/day[. eq "Monday"],    delete node $ot    )
id-delete-expr-014,Error: XPST0003: Unable to parse XPath: "(: Name: id-delete-expr-014 :) (: Description: Delete an element node parent and then the element node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $ot := $input-context/works[1]/employee[@name="John Doe 12"]/overtime return    (    delete node $ot,    delete node $ot/day[. eq "Monday"]    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-delete-expr-014 :) (: Description: Delete an element node parent and then the element node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $ot := $input-context/works[1]/employee[@name="John Doe 12"]/overtime return    (    delete [Error is around here]node $ot,    delete node $ot/day[. eq "Monday"]    )
id-delete-expr-015,Error: XPST0003: Unable to parse XPath: "(: Name: id-delete-expr-015 :) (: Description: Delete an element node multiple times. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $ot := $input-context/works[1]/employee[@name="John Doe 12"]/overtime return    (    delete node $ot,    delete node $ot    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-delete-expr-015 :) (: Description: Delete an element node multiple times. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $ot := $input-context/works[1]/employee[@name="John Doe 12"]/overtime return    (    delete [Error is around here]node $ot,    delete node $ot    )
id-delete-expr-016,Error: XPST0003: Unable to parse XPath: "(: Name: id-delete-expr-016 :) (: Description: Delete an element node multiple times. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $ot := $input-context/works[1]/employee[@name="John Doe 12"]/overtime return    (    delete node $ot,    delete node $ot,    delete node $ot    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-delete-expr-016 :) (: Description: Delete an element node multiple times. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $ot := $input-context/works[1]/employee[@name="John Doe 12"]/overtime return    (    delete [Error is around here]node $ot,    delete node $ot,    delete node $ot    )
id-delete-expr-017,Error: XPST0003: Unable to parse XPath: "(: Name: id-delete-expr-017 :) (: Description: Delete an element node, making sure that it is remains visible in this snapshot. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete node $input-context/works[1]/employee[@name="John Doe 12"]/overtime/day[1], delete node $input-context/works[1]/employee    [count($input-context/works[1]/employee[@name="John Doe 12"]/overtime/day)] ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-delete-expr-017 :) (: Description: Delete an element node, making sure that it is remains visible in this snapshot. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete [Error is around here]node $input-context/works[1]/employee[@name="John Doe 12"]/overtime/day[1], delete node $input-context/works[1]/employee    [count($input-context/works[1]/employee[@name="John Doe 12"]/overtime/day)]
id-delete-expr-018,Error: XPST0003: Unable to parse XPath: "(: Name: id-delete-expr-018 :) (: Description: Delete an element node, making sure that it is remains visible in this snapshot. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete node $input-context/works[1]/employee    [count($input-context/works[1]/employee[@name="John Doe 12"]/overtime/day)], delete node $input-context/works[1]/employee[@name="John Doe 12"]/overtime/day[1] ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-delete-expr-018 :) (: Description: Delete an element node, making sure that it is remains visible in this snapshot. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete [Error is around here]node $input-context/works[1]/employee    [count($input-context/works[1]/employee[@name="John Doe 12"]/overtime/day)], delete node $input-context/works[1]/employee[@name="John Doe 12"]/overtime/day[1]
id-delete-expr-019,Error: XPST0003: Unable to parse XPath: "(: Name: id-delete-expr-019 :) (: Description: Delete an attribute node multiple times. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $emp := $input-context/works[1]/employee[1] let $attr := $emp/@gender return    (    delete node $attr,    delete node $attr,    delete node $attr    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-delete-expr-019 :) (: Description: Delete an attribute node multiple times. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $emp := $input-context/works[1]/employee[1] let $attr := $emp/@gender return    (    delete [Error is around here]node $attr,    delete node $attr,    delete node $attr    )
id-delete-expr-020,Error: XPST0003: Unable to parse XPath: "(: Name: id-delete-expr-020 :) (: Description: Delete a text node multiple times. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $emp := $input-context/works[1]/employee[1] let $text := $emp/pnum/text() return    (    delete node $text,    delete node $text,    delete node $text    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-delete-expr-020 :) (: Description: Delete a text node multiple times. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $emp := $input-context/works[1]/employee[1] let $text := $emp/pnum/text() return    (    delete [Error is around here]node $text,    delete node $text,    delete node $text    )
id-delete-expr-021,Error: XPST0003: Unable to parse XPath: "(: Name: id-delete-expr-021 :) (: Description: Delete a comment node multiple times. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $emp := $input-context/works[1]/employee[13] let $comment := $emp/comment() return    (    delete node $comment,    delete node $comment,    delete node $comment    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-delete-expr-021 :) (: Description: Delete a comment node multiple times. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $emp := $input-context/works[1]/employee[13] let $comment := $emp/comment() return    (    delete [Error is around here]node $comment,    delete node $comment,    delete node $comment    )
id-delete-expr-022,Error: XPST0003: Unable to parse XPath: "(: Name: id-delete-expr-022 :) (: Description: Delete a PI node multiple times. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $emp := $input-context/works[1]/employee[13] let $pi := $emp/processing-instruction() return    (    delete node $pi,    delete node $pi,    delete node $pi    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-delete-expr-022 :) (: Description: Delete a PI node multiple times. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $emp := $input-context/works[1]/employee[13] let $pi := $emp/processing-instruction() return    (    delete [Error is around here]node $pi,    delete node $pi,    delete node $pi    )
complex-deletes-q3,Error: XPST0003: Unable to parse XPath: "(: Name: complex-deletes-q3 :) (: Description: Delete all PIs with target "a-pi". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete nodes $input-context//processing-instruction("a-pi") ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: complex-deletes-q3 :) (: Description: Delete all PIs with target "a-pi". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete [Error is around here]nodes $input-context//processing-instruction("a-pi")
complex-deletes-q4,Error: XPST0003: Unable to parse XPath: "(: Name: complex-deletes-q4 :) (: Description: Delete last text node child of document element. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete nodes $input-context/far-north/text()[last()] ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: complex-deletes-q4 :) (: Description: Delete last text node child of document element. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete [Error is around here]nodes $input-context/far-north/text()[last()]
complex-deletes-q5,Error: XPST0003: Unable to parse XPath: "(: Name: complex-deletes-q5 :) (: Description: Delete all text node children of element "south". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete nodes $input-context//south/text() ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: complex-deletes-q5 :) (: Description: Delete all text node children of element "south". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete [Error is around here]nodes $input-context//south/text()
complex-deletes-q10,Error: XPST0003: Unable to parse XPath: "(: Name: complex-deletes-q10 :) (: Description: Delete the element called "far-east". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete nodes $input-context/far-north/north/near-north/far-east ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: complex-deletes-q10 :) (: Description: Delete the element called "far-east". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete [Error is around here]nodes $input-context/far-north/north/near-north/far-east
complex-deletes-q11,Error: XPST0003: Unable to parse XPath: "(: Name: complex-deletes-q11 :) (: Description: Delete all attributes called "mark". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete nodes $input-context//@mark ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: complex-deletes-q11 :) (: Description: Delete all attributes called "mark". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete [Error is around here]nodes $input-context//@mark
complex-deletes-q12,Error: XPST0003: Unable to parse XPath: "(: Name: complex-deletes-q12 :) (: Description: Delete all attributes on the "west" element. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete nodes $input-context//west/@* ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: complex-deletes-q12 :) (: Description: Delete all attributes on the "west" element. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete [Error is around here]nodes $input-context//west/@*
complex-deletes-q13,Error: XPST0003: Unable to parse XPath: "(: Name: complex-deletes-q13 :) (: Description: Delete the attributes names "west-attr-2", "center-attr-2", and "south-attr-2". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete nodes $input-context//(@west-attr-2 | @center-attr-2 | @south-attr-2) ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: complex-deletes-q13 :) (: Description: Delete the attributes names "west-attr-2", "center-attr-2", and "south-attr-2". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete [Error is around here]nodes $input-context//(@west-attr-2 | @center-attr-2 | @south-attr-2)
complex-deletes-q14,Error: XPST0003: Unable to parse XPath: "(: Name: complex-deletes-q14 :) (: Description: Delete the document node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete nodes $input-context ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: complex-deletes-q14 :) (: Description: Delete the document node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete [Error is around here]nodes $input-context
id-replace-expr-011,Error: Should throw error XUST0001.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUST0001'
id-replace-expr-012,Error: Should throw error XUST0001.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUST0001'
id-replace-expr-013,Error: Should throw error XUTY0008.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUTY0008'
id-replace-expr-014,Error: Should throw error XUDY0009.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUDY0009'
id-replace-expr-015,Error: Should throw error XUTY0008.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUTY0008'
id-replace-expr-016,Error: Should throw error XUTY0011.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUTY0011'
id-replace-expr-022,Error: Should throw error XUTY0010.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUTY0010'
id-replace-expr-028,Error: Should throw error XUDY0027.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUDY0027'
id-replace-expr-030,Error: No selector counterpart for: computedTextConstructor.
id-replace-expr-045,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
id-replace-expr-045-no-inherit,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
id-replace-expr-08,Error: Not implemented: Intermediate clauses in flwor expressions are not implemented yet
id-replace-expr-017,Error: Should throw error XUST0001.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUST0001'
id-replace-expr-018,Error: Should throw error XUST0001.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUST0001'
id-replace-expr-019,Error: Should throw error XUTY0008.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUTY0008'
id-replace-expr-020,Error: Should throw error XUTY0008.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUTY0008'
id-replace-expr-021,Error: Not implemented: Intermediate clauses in flwor expressions are not implemented yet
complex-replacevalues-q11,Error: XPST0008, The variable pos is not in scope.
complex-replacevalues-q12,Error: Not implemented: Intermediate clauses in flwor expressions are not implemented yet
id-rename-expr-010,Error: XPST0003: Unable to parse XPath: "(: Name: id-rename-expr-010 :) (: Description: Evaluation of a rename expression where the newname expression is an updating expression.:)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] return    rename node $var/salary[1] as delete node $var/name[1]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-rename-expr-010 :) (: Description: Evaluation of a rename expression where the newname expression is an updating expression.:)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] return    rename node $var/salary[1] as delete [Error is around here]node $var/name[1]
id-rename-expr-033,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
id-rename-expr-034,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
id-rename-expr-033-no-inherit,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
id-rename-expr-034-no-inherit,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
id-rename-expr-035,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
id-rename-expr-036,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
id-rename-expr-037,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
complex-renames-q6,Error: Not implemented: Intermediate clauses in flwor expressions are not implemented yet
complex-renames-q7,Error: XPST0008, The variable pos is not in scope.
complex-renames-q8,Error: Not implemented: Intermediate clauses in flwor expressions are not implemented yet
id-transform-expr-01,Error: Not implemented: Intermediate clauses in flwor expressions are not implemented yet
id-transform-expr-02,Error: XPST0003: Unable to parse XPath: "(: Name: id-transform-expr-02 :) (: Description: Evaluation of transform expression with modify clause set to a delete expression. :) (: Transform of an element node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return   copy $newVar := $var   modify delete node $newVar/pnum[1]   return $newVar3". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-transform-expr-02 :) (: Description: Evaluation of transform expression with modify clause set to a delete expression. :) (: Transform of an element node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return   copy $newVar := $var   modify delete [Error is around here]node $newVar/pnum[1]   return $newVar3
id-transform-expr-04,Error: XPST0003: Unable to parse XPath: "(: Name: id-transform-expr-04 :) (: Description: Evaluation of transform expression with modify clause set to an insert expression expression. :) (: Transform of an element node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    copy $newVar := $var   modify insert node <pnum1>P1-1</pnum1> after $newVar/pnum[1]   return $newVar". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-transform-expr-04 :) (: Description: Evaluation of transform expression with modify clause set to an insert expression expression. :) (: Transform of an element node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    copy $newVar := $var   modify insert [Error is around here]node <pnum1>P1-1</pnum1> after $newVar/pnum[1]   return $newVar
id-transform-expr-05,Error: Not implemented: Intermediate clauses in flwor expressions are not implemented yet
id-transform-expr-06,Error: XPST0003: Unable to parse XPath: "(: Name: id-transform-expr-06 :) (: Description: Evaluation of transform expression where multiple element nodes are bounded. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/child::employee return    copy $newVar := $var   modify delete node $newVar[position() > 1]   return $newVar". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-transform-expr-06 :) (: Description: Evaluation of transform expression where multiple element nodes are bounded. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/child::employee return    copy $newVar := $var   modify delete [Error is around here]node $newVar[position() > 1]   return $newVar
id-transform-expr-07,Error: XPST0003: Unable to parse XPath: "(: Name: id-transform-expr-07 :) (: Description: Evaluation of a transform expression where an attribute is transformed. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    copy $newVar := $var   modify delete node $newVar/attribute::name   return $newVar". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-transform-expr-07 :) (: Description: Evaluation of a transform expression where an attribute is transformed. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    copy $newVar := $var   modify delete [Error is around here]node $newVar/attribute::name   return $newVar
id-transform-expr-08,Error: XPST0003: Unable to parse XPath: "(: Name: id-transform-expr-08 :) (: Description: Evaluation of a transform expression where a comment node is transformed. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[13] return   copy $newVar := $var   modify delete node $newVar/child::comment()   return $newVar". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-transform-expr-08 :) (: Description: Evaluation of a transform expression where a comment node is transformed. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[13] return   copy $newVar := $var   modify delete [Error is around here]node $newVar/child::comment()   return $newVar
id-transform-expr-09,Error: Should throw error FOER0000.: expected 'XPST0017: Function fn:error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?' to equal 'FOER0000'
id-transform-expr-010,Error: XPST0003: Unable to parse XPath: "(: Name: id-transform-expr-010 :) (: Description: Evaluation of a transform expression where two variables are bounded :) (: and only one is transformed. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1] return    copy $newVar1 := $var/employee[1], $newVar2 := $var/employee[2]   modify delete node $newVar1/hours[1]   return ($newVar1, $newVar2)". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-transform-expr-010 :) (: Description: Evaluation of a transform expression where two variables are bounded :) (: and only one is transformed. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1] return    copy $newVar1 := $var/employee[1], $newVar2 := $var/employee[2]   modify delete [Error is around here]node $newVar1/hours[1]   return ($newVar1, $newVar2)
id-transform-expr-011,Error: XPST0003: Unable to parse XPath: "(: Name: id-transform-expr-011 :) (: Description: Evaluation of a transform expression where two variables are bounded :) (: and both ones are transformed. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1] return    copy $newVar1 := $var/employee[1], $newVar2 := $var/employee[2]   modify delete node ($newVar1/hours[1], $newVar2/hours[1])   return ($newVar1, $newVar2)". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-transform-expr-011 :) (: Description: Evaluation of a transform expression where two variables are bounded :) (: and both ones are transformed. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1] return    copy $newVar1 := $var/employee[1], $newVar2 := $var/employee[2]   modify delete [Error is around here]node ($newVar1/hours[1], $newVar2/hours[1])   return ($newVar1, $newVar2)
id-transform-expr-012,Error: XPST0003: Unable to parse XPath: "(: Name: id-transform-expr-012 :) (: Description: Evaluation of a transform expression where the source expression is an updating expression :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] return    copy $newVar1 := delete node $var/salary[1]    modify ()   return $newVar1". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "modify", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-transform-expr-012 :) (: Description: Evaluation of a transform expression where the source expression is an updating expression :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] return    copy $newVar1 := delete [Error is around here]node $var/salary[1]    modify ()   return $newVar1
id-transform-expr-014,Error: XPST0003: Unable to parse XPath: "(: Name: id-transform-expr-014 :) (: Description: Evaluation of a transform expression where the return expression contains an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1] return    copy $newVar := $var   modify delete node $newVar/employee[1]   return delete node $newVar/employee[2]". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-transform-expr-014 :) (: Description: Evaluation of a transform expression where the return expression contains an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1] return    copy $newVar := $var   modify delete [Error is around here]node $newVar/employee[1]   return delete node $newVar/employee[2]
id-transform-expr-015,Error: XPST0003: Unable to parse XPath: "(: Name: id-transform-expr-015 :) (: Description: Evaluation of a transform expression where the pending updating list contains a node not created within :) (: this transform expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var1 := $input-context/employees[1]/employee[1] let $var2 := $input-context/employees[1]/employee[2] return    copy $newVar := $var1   modify delete node $var2/salary[1]   return $newVar". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-transform-expr-015 :) (: Description: Evaluation of a transform expression where the pending updating list contains a node not created within :) (: this transform expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var1 := $input-context/employees[1]/employee[1] let $var2 := $input-context/employees[1]/employee[2] return    copy $newVar := $var1   modify delete [Error is around here]node $var2/salary[1]   return $newVar
id-transform-expr-016,Error: XPST0003: Unable to parse XPath: "(: Name: id-transform-expr-016 :) (: Description: Evaluates a transform expression, which inserts a node and deletes the same node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    copy $newVar := $var   modify     (delete node $newVar/hours[1], insert node <hours>40</hours> as last into $newVar)   return $newVar". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-transform-expr-016 :) (: Description: Evaluates a transform expression, which inserts a node and deletes the same node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    copy $newVar := $var   modify     (delete [Error is around here]node $newVar/hours[1], insert node <hours>40</hours> as last into $newVar)   return $newVar
id-transform-expr-017,Error: XPST0003: Unable to parse XPath: "(: Name: id-transform-expr-017 :) (: Description: Evaluates a transform expression, which deletes a node and then isnserts a node with the same node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    copy $newVar := $var   modify     (insert node <hours>40</hours> as last into $newVar, delete node $newVar/hours[1])   return $newVar". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-transform-expr-017 :) (: Description: Evaluates a transform expression, which deletes a node and then isnserts a node with the same node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    copy $newVar := $var   modify     (insert [Error is around here]node <hours>40</hours> as last into $newVar, delete node $newVar/hours[1])   return $newVar
id-transform-expr-018,Error: XPST0003: Unable to parse XPath: "(: Name: id-transform-expr-018 :) (: Description: Evaluates a transform expression, which contains an embedded Transform expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] return    copy $newVar := $var   modify     (copy $newVar1 := $newVar modify (insert node <hours>40</hours> as last into $newVar1) return $newVar1)     return $newVar". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-transform-expr-018 :) (: Description: Evaluates a transform expression, which contains an embedded Transform expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] return    copy $newVar := $var   modify     (copy $newVar1 := $newVar modify (insert [Error is around here]node <hours>40</hours> as last into $newVar1) return $newVar1)     return $newVar
id-transform-expr-026,Error: XPST0003: Unable to parse XPath: "(: Name: id-transform-expr-026 :) (: Description: Evaluates a transform expression, where the source expression results in more than one single element node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1] return    copy $newVar := $var/employee[position() < 3]   modify     (delete node $newVar )     return $newVar". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-transform-expr-026 :) (: Description: Evaluates a transform expression, where the source expression results in more than one single element node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1] return    copy $newVar := $var/employee[position() < 3]   modify     (delete [Error is around here]node $newVar )     return $newVar
id-transform-expr-027,Error: XPST0003: Unable to parse XPath: "(: Name: id-transform-expr-027 :) (: Description: Evaluates a transform expression, where the source expression results in more than one single attribute node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1] return    copy $newVar := $var/employee[1]/attribute::*   modify     (delete node $newVar)     return $newVar". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-transform-expr-027 :) (: Description: Evaluates a transform expression, where the source expression results in more than one single attribute node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1] return    copy $newVar := $var/employee[1]/attribute::*   modify     (delete [Error is around here]node $newVar)     return $newVar
id-transform-expr-028,Error: XPST0003: Unable to parse XPath: "(: Name: id-transform-expr-028 :) (: Description: Evaluates a transform expression, which inserts a node to insure :) (: the original data is not modified. :)  (:insert-start:) declare variable $input-context external; (:insert-end:)  let $var := $input-context/works[1]/employee[1] return 	copy $newVar := $var 	modify insert node <id>0001</id> as first into $newVar 	return $newVar ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-transform-expr-028 :) (: Description: Evaluates a transform expression, which inserts a node to insure :) (: the original data is not modified. :)  (:insert-start:) declare variable $input-context external; (:insert-end:)  let $var := $input-context/works[1]/employee[1] return 	copy $newVar := $var 	modify insert [Error is around here]node <id>0001</id> as first into $newVar 	return $newVar
id-transform-expr-029,Error: XPST0003: Unable to parse XPath: "(: Name: id-transform-expr-029 :) (: Description: Evaluates a transform expression, which deletes a node to insure :) (: the original data is not modified. :)  (:insert-start:) declare variable $input-context external; (:insert-end:)  let $var := $input-context/works[1]/employee[2] return 	copy $newVar := $var 	modify delete node $newVar/pnum[1] 	return $newVar". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-transform-expr-029 :) (: Description: Evaluates a transform expression, which deletes a node to insure :) (: the original data is not modified. :)  (:insert-start:) declare variable $input-context external; (:insert-end:)  let $var := $input-context/works[1]/employee[2] return 	copy $newVar := $var 	modify delete [Error is around here]node $newVar/pnum[1] 	return $newVar
id-transform-expr-030,Error: No selector counterpart for: computedTextConstructor.
id-transform-expr-032,Error: XPST0003: Unable to parse XPath: "(: Name: id-transform-expr-032 :) (: Description: Transform with copy binding to an empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    copy $newVar := $var/*[100]   modify delete node $newVar/*[1]   return $newVar ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-transform-expr-032 :) (: Description: Transform with copy binding to an empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    copy $newVar := $var/*[100]   modify delete [Error is around here]node $newVar/*[1]   return $newVar
id-transform-expr-033,Error: XPST0003: Unable to parse XPath: "(: Name: id-transform-expr-033 :) (: Description: Transform with later copy variable binding seeing earlier copy variable binding. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1] return    copy $var1 := $var/employee[1],        $var2 := $var/employee[$var1/hours[1] div 20]    modify delete node $var2/hours   return $var2 ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-transform-expr-033 :) (: Description: Transform with later copy variable binding seeing earlier copy variable binding. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1] return    copy $var1 := $var/employee[1],        $var2 := $var/employee[$var1/hours[1] div 20]    modify delete [Error is around here]node $var2/hours   return $var2
id-transform-expr-041,Error: Not supported: renaming detached nodes.
id-transform-expr-042,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
id-transform-expr-043,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
id-transform-expr-044,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
id-transform-expr-045,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
id-transform-expr-046,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
id-transform-expr-047,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
id-transform-expr-048,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
id-transform-expr-049,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
id-transform-expr-050,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
id-transform-expr-051,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
id-transform-expr-052,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
id-transform-expr-053,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
id-transform-expr-054,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
id-transform-expr-057,Error: Should throw error XUDY0016.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUDY0016'
compatibility-007,Error: Should throw error XUDY0016.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUDY0016'
compatibility-008,Error: Should throw error XUDY0016.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUDY0016'
compatibility-009,Error: Should throw error XUDY0016.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUDY0016'
compatibility-010,Error: Should throw error XUDY0016.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUDY0016'
compatibility-011,Error: Should throw error XUDY0016.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUDY0016'
compatibility-012,Error: Should throw error XUDY0016.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUDY0016'
compatibility-013,Error: Should throw error XUDY0016.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUDY0016'
compatibility-014,Error: Should throw error XUDY0016.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUDY0016'
compatibility-015,Error: Should throw error XUDY0016.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUDY0016'
compatibility-016,Error: Should throw error XUDY0016.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUDY0016'
compatibility-029,Error: XPST0003: Unable to parse XPath: "(: Name: compatibility-029 :) (: Description: Replace value of and insert operate on the same element. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    replace value of node $var with "on leave",    insert node comment {"this employee is on leave"} into $var     ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: compatibility-029 :) (: Description: Replace value of and insert operate on the same element. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    replace value of node $var with "on leave",    insert [Error is around here]node comment {"this employee is on leave"} into $var     )
compatibility-030,Error: XPST0003: Unable to parse XPath: "(: Name: compatibility-030 :) (: Description: Replace value of and insert operate on the same element. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert node comment {"this employee is on leave"} into $var,    replace value of node $var with "on leave"    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: compatibility-030 :) (: Description: Replace value of and insert operate on the same element. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert [Error is around here]node comment {"this employee is on leave"} into $var,    replace value of node $var with "on leave"    )
id-flwor-expr-01,Error: XPST0003: Unable to parse XPath: "(: Name: id-flwor-expr-01 :) (: Description: Evaluation of insert expression use with FLWOR expression where let clause is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] let $var1 := insert node <salary>110000</salary> into $var return    "This Test Should Fail"". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "for", "ge", "group", "gt", "idiv", "instance", "intersect", "is", "le", "let", "lt", "mod", "ne", "or", "order", "return", "stable", "to", "treat", "union", "where", "|", or "||" but "n" found. (: Name: id-flwor-expr-01 :) (: Description: Evaluation of insert expression use with FLWOR expression where let clause is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] let $var1 := insert [Error is around here]node <salary>110000</salary> into $var return    "This Test Should Fail"
id-flwor-expr-02,Error: XPST0003: Unable to parse XPath: "(: Name: id-flwor-expr-02 :) (: Description: Evaluation of insert expression use with FLWOR expression where for clause is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/employees[1]/employee[2] for $var1 in (insert node <salary>110000</salary> into $var) return    "This Test Should Fail"". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-flwor-expr-02 :) (: Description: Evaluation of insert expression use with FLWOR expression where for clause is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/employees[1]/employee[2] for $var1 in (insert [Error is around here]node <salary>110000</salary> into $var) return    "This Test Should Fail"
id-flwor-expr-03,Error: XPST0003: Unable to parse XPath: "(: Name: id-flwor-expr-03:) (: Description: Evaluation of insert expression used with FLWOR expression where "where" clause is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/employees[1]/employee[2] where (insert node <salary>110000</salary> into $var) return    "This Test Should Fail"". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-flwor-expr-03:) (: Description: Evaluation of insert expression used with FLWOR expression where "where" clause is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/employees[1]/employee[2] where (insert [Error is around here]node <salary>110000</salary> into $var) return    "This Test Should Fail"
id-flwor-expr-04,Error: XPST0003: Unable to parse XPath: "(: Name: id-flwor-expr-04 :) (: Description: Evaluation of insert expression use with FLWOR expression where "order by" clause is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/employees[1]/employee[2] order by (insert node <salary>110000</salary> into $var) descending return    "This Test Should Fail"". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-flwor-expr-04 :) (: Description: Evaluation of insert expression use with FLWOR expression where "order by" clause is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/employees[1]/employee[2] order by (insert [Error is around here]node <salary>110000</salary> into $var) descending return    "This Test Should Fail"
id-flwor-expr-05,Error: XPST0003: Unable to parse XPath: "(: Name: id-flwor-expr-05 :) (: Description: Evaluation of delete expression use with FLWOR expression where let clause is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/employees[1]/employee[2] let $var1 := delete node $var/salary[1] return    "This Test Should Fail"". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "for", "ge", "group", "gt", "idiv", "instance", "intersect", "is", "le", "let", "lt", "mod", "ne", "or", "order", "return", "stable", "to", "treat", "union", "where", "|", or "||" but "n" found. (: Name: id-flwor-expr-05 :) (: Description: Evaluation of delete expression use with FLWOR expression where let clause is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/employees[1]/employee[2] let $var1 := delete [Error is around here]node $var/salary[1] return    "This Test Should Fail"
id-flwor-expr-06,Error: XPST0003: Unable to parse XPath: "(: Name: id-flwor-expr-06 :) (: Description: Evaluation of a delete expression use with FLWOR expression where for clause is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/employees[1]/employee[2] for $var1 in (delete node $var/salary[1]) return    "This Test Should Fail"". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-flwor-expr-06 :) (: Description: Evaluation of a delete expression use with FLWOR expression where for clause is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/employees[1]/employee[2] for $var1 in (delete [Error is around here]node $var/salary[1]) return    "This Test Should Fail"
id-flwor-expr-07,Error: XPST0003: Unable to parse XPath: "(: Name: id-flwor-expr-07 :) (: Description: Evaluation of delete expression used with FLWOR expression where "where" clause is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/employees[1]/employee[2] where (delete node $var/salary[1]) return    "This Test Should Fail"". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-flwor-expr-07 :) (: Description: Evaluation of delete expression used with FLWOR expression where "where" clause is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/employees[1]/employee[2] where (delete [Error is around here]node $var/salary[1]) return    "This Test Should Fail"
id-flwor-expr-08,Error: XPST0003: Unable to parse XPath: "(: Name: id-flwor-expr-08 :) (: Description: Evaluation of a delete expression use with FLWOR expression where "order by" clause is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/employees[1]/employee[2] order by (delete node $var/salary[1]) descending return    "This Test Should Fail"". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-flwor-expr-08 :) (: Description: Evaluation of a delete expression use with FLWOR expression where "order by" clause is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/employees[1]/employee[2] order by (delete [Error is around here]node $var/salary[1]) descending return    "This Test Should Fail"
id-flwor-expr-09,Error: Should throw error XUST0001.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUST0001'
id-flwor-expr-010,Error: Should throw error XUST0001.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUST0001'
id-flwor-expr-011,Error: Should throw error XUST0001.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUST0001'
id-flwor-expr-012,Error: Should throw error XUST0001.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUST0001'
id-flwor-expr-013,Error: Should throw error XUST0001.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUST0001'
id-flwor-expr-014,Error: Should throw error XUST0001.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUST0001'
id-flwor-expr-015,Error: Should throw error XUST0001.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUST0001'
id-flwor-expr-016,Error: Should throw error XUST0001.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUST0001'
id-flwor-expr-017,Error: XPST0003: Unable to parse XPath: "(: Name: id-flwor-expr-017 :) (: Description: Evaluation of a transform expression use with FLWOR expression where let clause is a transform expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/employees[1]/employee[1] let $var1 := copy $newVar := $var   modify delete node $newVar/salary[1]  return $newVar return $var1 ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-flwor-expr-017 :) (: Description: Evaluation of a transform expression use with FLWOR expression where let clause is a transform expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/employees[1]/employee[1] let $var1 := copy $newVar := $var   modify delete [Error is around here]node $newVar/salary[1]  return $newVar return $var1
id-flwor-expr-018,Error: XPST0003: Unable to parse XPath: "(: Name: id-flwor-expr-018 :) (: Description: Evaluation of a transform expression use with FLWOR expression where "for" clause is a transform expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/employees[1]/employee[1] for $var1 in (copy $newVar := $var   modify delete node $newVar/salary[1]  return $newVar) return $var1 ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-flwor-expr-018 :) (: Description: Evaluation of a transform expression use with FLWOR expression where "for" clause is a transform expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/employees[1]/employee[1] for $var1 in (copy $newVar := $var   modify delete [Error is around here]node $newVar/salary[1]  return $newVar) return $var1
id-flwor-expr-019,Error: XPST0003: Unable to parse XPath: "(: Name: id-flwor-expr-019 :) (: Description: Evaluation of a transform expression use with FLWOR expression where the "where" clause is a transform expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/employees[1]/employee[1] where copy $newVar := $var   modify delete node $newVar/salary[1]  return $newVar return $var". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-flwor-expr-019 :) (: Description: Evaluation of a transform expression use with FLWOR expression where the "where" clause is a transform expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   let $var := $input-context/employees[1]/employee[1] where copy $newVar := $var   modify delete [Error is around here]node $newVar/salary[1]  return $newVar return $var
id-flwor-expr-020,Error: XPST0003: Unable to parse XPath: "(: Name: id-flwor-expr-020 :) (: Description: Evaluation of a transform expression use with FLWOR expression where the "order by" clause is a transform expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] order by (copy $newVar := $var   modify delete node $newVar/salary[1]  return $newVar) descending return $var ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-flwor-expr-020 :) (: Description: Evaluation of a transform expression use with FLWOR expression where the "order by" clause is a transform expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] order by (copy $newVar := $var   modify delete [Error is around here]node $newVar/salary[1]  return $newVar) descending return $var
id-flwor-expr-021,Error: XPST0003: Unable to parse XPath: "(: Name: id-flwor-expr-021 :) (: Description: Evaluation of a FLWOR expression, where return is a delete expression that deletes a series nodes bounded via let clause. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := ($input-context/works[1]/employee[1], $input-context/works[1]/employee[2], $input-context/works[1]/employee[3]) return    delete node $var/empnum[1]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-flwor-expr-021 :) (: Description: Evaluation of a FLWOR expression, where return is a delete expression that deletes a series nodes bounded via let clause. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := ($input-context/works[1]/employee[1], $input-context/works[1]/employee[2], $input-context/works[1]/employee[3]) return    delete [Error is around here]node $var/empnum[1]
id-flwor-expr-022,Error: XPST0003: Unable to parse XPath: "(: Name: id-flwor-expr-022 :) (: Description: Evaluation of a FLWOR expression, where return is a delete expression that deletes a series nodes bounded via for clause. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  for $var in $input-context/works[1]/employee return    delete node $var/empnum[1]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-flwor-expr-022 :) (: Description: Evaluation of a FLWOR expression, where return is a delete expression that deletes a series nodes bounded via for clause. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  for $var in $input-context/works[1]/employee return    delete [Error is around here]node $var/empnum[1]
id-flwor-expr-024,Error: XPST0003: Unable to parse XPath: "(: Name: id-flwor-expr-024 :) (: Description: For clause that contains a for expression with a updating return clause. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  for $var in     for $var in $input-context/works[1]/employee[1]/hours[1]    return delete node $var return    $var ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "for", "ge", "group", "gt", "idiv", "instance", "intersect", "is", "le", "let", "lt", "mod", "ne", "or", "order", "return", "stable", "to", "treat", "union", "where", "|", or "||" but "n" found. (: Name: id-flwor-expr-024 :) (: Description: For clause that contains a for expression with a updating return clause. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  for $var in     for $var in $input-context/works[1]/employee[1]/hours[1]    return delete [Error is around here]node $var return    $var
id-typeswitch-expr-01,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-01 :) (: Description: Evaluation of insert expression used with typeswitch expression where the operand is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch(insert node <salary>23000</salary> into $input-context/employees[1]/employee[1])  case $i as xs:string     return "test should fail"  case $i as xs:double     return "test should fail"   default    return "test should fail"". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-01 :) (: Description: Evaluation of insert expression used with typeswitch expression where the operand is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch[Error is around here](insert node <salary>23000</salary> into $input-context/employees[1]/employee[1])  case $i as xs:string     return "test should fail"  case $i as xs:double     return "test should fail"   default    return "test should fail"
id-typeswitch-expr-02,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-02 :) (: Description: Evaluation of insert expression used with typeswitch expression where the branch (a "case") is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch(xs:int(1))  case $i as xs:int     return (insert node <hours>20</hours> into $input-context/works[1]/employee[1])  case $i as xs:double     return ()   default    return ()". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-02 :) (: Description: Evaluation of insert expression used with typeswitch expression where the branch (a "case") is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch[Error is around here](xs:int(1))  case $i as xs:int     return (insert node <hours>20</hours> into $input-context/works[1]/employee[1])  case $i as xs:double     return ()   default    return ()
id-typeswitch-expr-03,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-03 :) (: Description: Evaluation of insert expression used with typeswitch expression where the branch (a "default") is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch(xs:int(1))  case $i as xs:string     return ()  case $i as xs:double     return ()   default    return (insert node <hours>30</hours> into $input-context/works[1]/employee[1])". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-03 :) (: Description: Evaluation of insert expression used with typeswitch expression where the branch (a "default") is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch[Error is around here](xs:int(1))  case $i as xs:string     return ()  case $i as xs:double     return ()   default    return (insert node <hours>30</hours> into $input-context/works[1]/employee[1])
id-typeswitch-expr-04,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-04 :) (: Description: Evaluation of insert expression used with typeswitch expression where branch (a "case") is an updating expression. :) (: All other branches return "fn:error()". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch(xs:int(1))  case $i as xs:int     return (insert node <hours>30</hours> into $input-context/works[1]/employee[1])  case $i as xs:double     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  default     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-04 :) (: Description: Evaluation of insert expression used with typeswitch expression where branch (a "case") is an updating expression. :) (: All other branches return "fn:error()". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch[Error is around here](xs:int(1))  case $i as xs:int     return (insert node <hours>30</hours> into $input-context/works[1]/employee[1])  case $i as xs:double     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  default     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))
id-typeswitch-expr-05,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-05 :) (: Description: Evaluation of insert expression used with typeswitch expression where a branch (the "default") is an updating expression. :) (: All other branches return "fn:error()". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch(xs:int(1))  case $i as xs:int     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  case $i as xs:double     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  default      return (insert node <hours>34</hours> into $input-context/works[1]/employee[2])". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-05 :) (: Description: Evaluation of insert expression used with typeswitch expression where a branch (the "default") is an updating expression. :) (: All other branches return "fn:error()". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch[Error is around here](xs:int(1))  case $i as xs:int     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  case $i as xs:double     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  default      return (insert node <hours>34</hours> into $input-context/works[1]/employee[2])
id-typeswitch-expr-06,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-06 :) (: Description: Evaluation of insert expression used with typeswitch expression where a branch (a "case") is an updating expression. :) (: All other branches return a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch(xs:int(1))  case $i as xs:int     return (insert node <salary>34000</salary> into $input-context/employees[1]/employee[2])  case $i as xs:double     return "This test should fail"  default     return "This test should fail"". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-06 :) (: Description: Evaluation of insert expression used with typeswitch expression where a branch (a "case") is an updating expression. :) (: All other branches return a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch[Error is around here](xs:int(1))  case $i as xs:int     return (insert node <salary>34000</salary> into $input-context/employees[1]/employee[2])  case $i as xs:double     return "This test should fail"  default     return "This test should fail"
id-typeswitch-expr-07,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-07 :) (: Description: Evaluation of insert expression used with typeswitch expression where a branch (the "default") is an updating expression. :) (: All other branches return a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch(xs:int(1))  case $i as xs:string         return "This test should fail"  case $i as xs:double     return "This test should fail"  default     return (insert node <salary>34000</salary> into $input-context/employees[1]/employee[2])". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-07 :) (: Description: Evaluation of insert expression used with typeswitch expression where a branch (the "default") is an updating expression. :) (: All other branches return a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch[Error is around here](xs:int(1))  case $i as xs:string         return "This test should fail"  case $i as xs:double     return "This test should fail"  default     return (insert node <salary>34000</salary> into $input-context/employees[1]/employee[2])
id-typeswitch-expr-08,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-08 :) (: Description: Evaluation of delete expression used with typeswitch expression where the operand is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   typeswitch(insert node <salary>34000</salary> into $input-context/employees[1]/employee[2])   case $i as xs:string     return "test should fail"   case $i as xs:double     return "test should fail"    default    return "test should fail"". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-08 :) (: Description: Evaluation of delete expression used with typeswitch expression where the operand is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   typeswitch[Error is around here](insert node <salary>34000</salary> into $input-context/employees[1]/employee[2])   case $i as xs:string     return "test should fail"   case $i as xs:double     return "test should fail"    default    return "test should fail"
id-typeswitch-expr-09,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-09 :) (: Description: Evaluation of a delete expression used with typeswitch expression where the branch (a "case") is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   typeswitch(xs:int(1))   case $i as xs:int     return (delete node $input-context/works[1]/employee[1]/hours[1])   case $i as xs:double     return ()    default     return () ". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-09 :) (: Description: Evaluation of a delete expression used with typeswitch expression where the branch (a "case") is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   typeswitch[Error is around here](xs:int(1))   case $i as xs:int     return (delete node $input-context/works[1]/employee[1]/hours[1])   case $i as xs:double     return ()    default     return ()
id-typeswitch-expr-010,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-010 :) (: Description: Evaluation of delete expression used with typeswitch expression where the branch (a "default") is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   typeswitch(xs:int(1))   case $i as xs:string     return ()   case $i as xs:double     return ()    default    return (delete node $input-context/works[1]/employee[1]/hours[1])". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-010 :) (: Description: Evaluation of delete expression used with typeswitch expression where the branch (a "default") is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   typeswitch[Error is around here](xs:int(1))   case $i as xs:string     return ()   case $i as xs:double     return ()    default    return (delete node $input-context/works[1]/employee[1]/hours[1])
id-typeswitch-expr-011,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-011 :) (: Description: Evaluation of insert expression used with typeswitch expression where branch (a "case") is an updating expression. :) (: All other branches return "fn:error()". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   typeswitch(xs:int(1))   case $i as xs:int     return (insert node <hours>150000</hours> into $input-context/works[1]/employee[2])   case $i as xs:double     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))   default     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-011 :) (: Description: Evaluation of insert expression used with typeswitch expression where branch (a "case") is an updating expression. :) (: All other branches return "fn:error()". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   typeswitch[Error is around here](xs:int(1))   case $i as xs:int     return (insert node <hours>150000</hours> into $input-context/works[1]/employee[2])   case $i as xs:double     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))   default     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))
id-typeswitch-expr-012,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-012 :) (: Description: Evaluation of a delete expression used with typeswitch expression where a branch (the "default") is an updating expression. :) (: All other branches return "fn:error()". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   typeswitch(xs:int(1))   case $i as xs:int     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))   case $i as xs:double     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))   default      return insert node <hours>50</hours> into $input-context/works[1]/employee[2]". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-012 :) (: Description: Evaluation of a delete expression used with typeswitch expression where a branch (the "default") is an updating expression. :) (: All other branches return "fn:error()". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   typeswitch[Error is around here](xs:int(1))   case $i as xs:int     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))   case $i as xs:double     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))   default      return insert node <hours>50</hours> into $input-context/works[1]/employee[2]
id-typeswitch-expr-013,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-013 :) (: Description: Evaluation of an insert expression used with typeswitch expression where a branch (a "case") is an updating expression. :) (: All other branches return a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := <hours><hour>10</hour><hour>20</hour></hours> return  typeswitch(xs:int(1))   case $i as xs:int     return (insert node <salary>50000</salary> into $input-context/employees[1]/employee[2])   case $i as xs:double     return "This test should fail"   default     return "This test should fail"". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-013 :) (: Description: Evaluation of an insert expression used with typeswitch expression where a branch (a "case") is an updating expression. :) (: All other branches return a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := <hours><hour>10</hour><hour>20</hour></hours> return  typeswitch[Error is around here](xs:int(1))   case $i as xs:int     return (insert node <salary>50000</salary> into $input-context/employees[1]/employee[2])   case $i as xs:double     return "This test should fail"   default     return "This test should fail"
id-typeswitch-expr-014,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-014 :) (: Description: Evaluation of a delete expression used with typeswitch expression where a branch (the "default") is an updating expression. :) (: All other branches return a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := <hours><hour>10</hour><hour>20</hour></hours> return  typeswitch(xs:int(1))   case $i as xs:string         return "This test should fail"   case $i as xs:double     return "This test should fail"   default     return (insert node <salary>50000</salary> into $input-context/employees[1]/employee[2])". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-014 :) (: Description: Evaluation of a delete expression used with typeswitch expression where a branch (the "default") is an updating expression. :) (: All other branches return a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := <hours><hour>10</hour><hour>20</hour></hours> return  typeswitch[Error is around here](xs:int(1))   case $i as xs:string         return "This test should fail"   case $i as xs:double     return "This test should fail"   default     return (insert node <salary>50000</salary> into $input-context/employees[1]/employee[2])
id-typeswitch-expr-015,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-015 :) (: Description: Evaluation of a replace expression used with typeswitch expression where the operand is an updating (replace) expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch(replace value of node $input-context/employees[1]/employee[1]/salary[1] with $input-context/employees[1]/employee[2]/salary[1])  case $i as xs:string     return "test should fail"  case $i as xs:double     return "test should fail"   default    return "test should fail"". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-015 :) (: Description: Evaluation of a replace expression used with typeswitch expression where the operand is an updating (replace) expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch[Error is around here](replace value of node $input-context/employees[1]/employee[1]/salary[1] with $input-context/employees[1]/employee[2]/salary[1])  case $i as xs:string     return "test should fail"  case $i as xs:double     return "test should fail"   default    return "test should fail"
id-typeswitch-expr-016,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-016 :) (: Description: Evaluation of a replace expression used with typeswitch expression where the branch (a "case") is an updating (replace) expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch(xs:int(1))  case $i as xs:int     return (replace value of node $input-context/works[1]/employee[1]/hours[1] with $input-context/works[1]/employee[2]/hours[1])  case $i as xs:double     return ()   default    return ()". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-016 :) (: Description: Evaluation of a replace expression used with typeswitch expression where the branch (a "case") is an updating (replace) expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch[Error is around here](xs:int(1))  case $i as xs:int     return (replace value of node $input-context/works[1]/employee[1]/hours[1] with $input-context/works[1]/employee[2]/hours[1])  case $i as xs:double     return ()   default    return ()
id-typeswitch-expr-017,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-017 :) (: Description: Evaluation of a replace expression used with typeswitch expression where the branch (a "default") is an updating expression. :) (: Other branches are equal to the empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch(xs:int(1))  case $i as xs:string    return ()  case $i as xs:double    return ()   default    return (replace value of node $input-context/works[1]/employee[1]/hours[1] with $input-context/works[1]/employee[2]/hours[1])". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-017 :) (: Description: Evaluation of a replace expression used with typeswitch expression where the branch (a "default") is an updating expression. :) (: Other branches are equal to the empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch[Error is around here](xs:int(1))  case $i as xs:string    return ()  case $i as xs:double    return ()   default    return (replace value of node $input-context/works[1]/employee[1]/hours[1] with $input-context/works[1]/employee[2]/hours[1])
id-typeswitch-expr-018,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-018 :) (: Description: Evaluation of a replace expression used with typeswitch expression where branch (a "case") is an updating (replace) expression. :) (: All other branches return "fn:error()". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch(xs:int(1))  case $i as xs:int     return (replace value of node $input-context/works[1]/employee[1]/hours[1] with $input-context/works[1]/employee[2]/hours[1])  case $i as xs:double     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  default     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-018 :) (: Description: Evaluation of a replace expression used with typeswitch expression where branch (a "case") is an updating (replace) expression. :) (: All other branches return "fn:error()". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch[Error is around here](xs:int(1))  case $i as xs:int     return (replace value of node $input-context/works[1]/employee[1]/hours[1] with $input-context/works[1]/employee[2]/hours[1])  case $i as xs:double     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  default     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))
id-typeswitch-expr-019,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-019 :) (: Description: Evaluation of a replace expression used with typeswitch expression where a branch (the "default") is an updating (replace) expression. :) (: All other branches return "fn:error()". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2]  return  typeswitch("string")  case $i as xs:int     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  case $i as xs:double     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  default      return replace value of node $var/hours[1] with $var/hours[2]". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-019 :) (: Description: Evaluation of a replace expression used with typeswitch expression where a branch (the "default") is an updating (replace) expression. :) (: All other branches return "fn:error()". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2]  return  typeswitch[Error is around here]("string")  case $i as xs:int     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  case $i as xs:double     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  default      return replace value of node $var/hours[1] with $var/hours[2]
id-typeswitch-expr-020,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-020 :) (: Description: Evaluation of a replace expression used with typeswitch expression where a branch (a "case") is an updating expression. :) (: All other branches return a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch(xs:int(1))  case $i as xs:int     return (replace value of node $input-context/employees[1]/employee[1]/salary[1] with $input-context/employees[1]/employee[2]/salary[1])  case $i as xs:double     return "This test should fail"  default     return "This test should fail"". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-020 :) (: Description: Evaluation of a replace expression used with typeswitch expression where a branch (a "case") is an updating expression. :) (: All other branches return a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch[Error is around here](xs:int(1))  case $i as xs:int     return (replace value of node $input-context/employees[1]/employee[1]/salary[1] with $input-context/employees[1]/employee[2]/salary[1])  case $i as xs:double     return "This test should fail"  default     return "This test should fail"
id-typeswitch-expr-021,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-021 :) (: Description: Evaluation of a replace expression used with typeswitch expression where a branch (the "default") is an updating (replace) expression. :) (: All other branches return a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch(xs:int(1))  case $i as xs:string         return "This test should fail"  case $i as xs:double     return "This test should fail"  default     return (replace value of node $input-context/employees[1]/employee[1]/salary[1] with $input-context/employees[1]/employee[2]/salary[1])". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-021 :) (: Description: Evaluation of a replace expression used with typeswitch expression where a branch (the "default") is an updating (replace) expression. :) (: All other branches return a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch[Error is around here](xs:int(1))  case $i as xs:string         return "This test should fail"  case $i as xs:double     return "This test should fail"  default     return (replace value of node $input-context/employees[1]/employee[1]/salary[1] with $input-context/employees[1]/employee[2]/salary[1])
id-typeswitch-expr-022,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-022 :) (: Description: Evaluation of rename expression used with typeswitch expression where the operand is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch(rename node $input-context/employees[1]/employee[1]/salary[1] as "salary1")  case $i as xs:string     return "test should fail"  case $i as xs:double     return "test should fail"   default    return "test should fail"". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-022 :) (: Description: Evaluation of rename expression used with typeswitch expression where the operand is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch[Error is around here](rename node $input-context/employees[1]/employee[1]/salary[1] as "salary1")  case $i as xs:string     return "test should fail"  case $i as xs:double     return "test should fail"   default    return "test should fail"
id-typeswitch-expr-023,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-023 :) (: Description: Evaluation of a rename expression used with typeswitch expression where the branch (a "case") is an updating expression. :) (: The other branches are the empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   typeswitch(xs:int(1))  case $i as xs:int     return rename node $input-context/works[1]/employee[1]/hours[1] as "hours1"  case $i as xs:double     return ()   default    return ()". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-023 :) (: Description: Evaluation of a rename expression used with typeswitch expression where the branch (a "case") is an updating expression. :) (: The other branches are the empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   typeswitch[Error is around here](xs:int(1))  case $i as xs:int     return rename node $input-context/works[1]/employee[1]/hours[1] as "hours1"  case $i as xs:double     return ()   default    return ()
id-typeswitch-expr-024,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-024 :) (: Description: Evaluation of a rename expression used with typeswitch expression where the branch (a "default") is an updating expression. :) (: Other branches are equal to the empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch(xs:int(1))  case $i as xs:string     return ()  case $i as xs:double     return ()   default    return (rename node $input-context/works[1]/employee[2]/hours[1] as "hours1")". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-024 :) (: Description: Evaluation of a rename expression used with typeswitch expression where the branch (a "default") is an updating expression. :) (: Other branches are equal to the empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch[Error is around here](xs:int(1))  case $i as xs:string     return ()  case $i as xs:double     return ()   default    return (rename node $input-context/works[1]/employee[2]/hours[1] as "hours1")
id-typeswitch-expr-025,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-025 :) (: Description: Evaluation of a rename expression used with typeswitch expression where branch (a "case") is an updating expression. :) (: All other branches invoke "fn:error()". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch(xs:int(1))  case $i as xs:int     return rename node $input-context/works[1]/employee[2]/hours[1] as "hours1"  case $i as xs:double     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  default     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-025 :) (: Description: Evaluation of a rename expression used with typeswitch expression where branch (a "case") is an updating expression. :) (: All other branches invoke "fn:error()". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch[Error is around here](xs:int(1))  case $i as xs:int     return rename node $input-context/works[1]/employee[2]/hours[1] as "hours1"  case $i as xs:double     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  default     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))
id-typeswitch-expr-026,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-026 :) (: Description: Evaluation of a rename expression used with typeswitch expression where a branch (the "default") is an updating expression. :) (: All other branches return "fn:error()". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch(xs:int(1))  case $i as xs:int     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  case $i as xs:double     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  default      return rename node $input-context/works[1]/employee[2]/hours[1] as "hours1"". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-026 :) (: Description: Evaluation of a rename expression used with typeswitch expression where a branch (the "default") is an updating expression. :) (: All other branches return "fn:error()". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch[Error is around here](xs:int(1))  case $i as xs:int     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  case $i as xs:double     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  default      return rename node $input-context/works[1]/employee[2]/hours[1] as "hours1"
id-typeswitch-expr-027,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-027 :) (: Description: Evaluation of a rename expression used with typeswitch expression where a branch (a "case") is an updating expression. :) (: All other branches return a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch(xs:int(1))  case $i as xs:int     return rename node $input-context/employees[1]/salary[1] as "salary1"  case $i as xs:double     return "This test should fail"  default     return "This test should fail"". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-027 :) (: Description: Evaluation of a rename expression used with typeswitch expression where a branch (a "case") is an updating expression. :) (: All other branches return a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch[Error is around here](xs:int(1))  case $i as xs:int     return rename node $input-context/employees[1]/salary[1] as "salary1"  case $i as xs:double     return "This test should fail"  default     return "This test should fail"
id-typeswitch-expr-028,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-028 :) (: Description: Evaluation of rename expression used with typeswitch expression where a branch (the "default") is an updating expression. :) (: All other branches return a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch(xs:int(1))  case $i as xs:string         return "This test should fail"  case $i as xs:double     return "This test should fail"  default     return rename node $input-context/employees[1]/salary[1] as "salary1"". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-028 :) (: Description: Evaluation of rename expression used with typeswitch expression where a branch (the "default") is an updating expression. :) (: All other branches return a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  typeswitch[Error is around here](xs:int(1))  case $i as xs:string         return "This test should fail"  case $i as xs:double     return "This test should fail"  default     return rename node $input-context/employees[1]/salary[1] as "salary1"
id-typeswitch-expr-029,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-029 :) (: Description: Evaluation of a transform expression used with typeswitch expression where the operand is an updating (transform) expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] return typeswitch(copy $newVar := $var   modify delete node $newVar/salary[1]  return $newVar)  case $i as xs:string     return "not this one"  case $i as xs:double     return "not this one"  default $i    return ($i, $var)". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-029 :) (: Description: Evaluation of a transform expression used with typeswitch expression where the operand is an updating (transform) expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] return typeswitch[Error is around here](copy $newVar := $var   modify delete node $newVar/salary[1]  return $newVar)  case $i as xs:string     return "not this one"  case $i as xs:double     return "not this one"  default $i    return ($i, $var)
id-typeswitch-expr-030,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-030 :) (: Description: Evaluation of a transform expression used with typeswitch expression where the branch (a "case") is an updating (transform) expression. :) (: Other branches are the empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return typeswitch(xs:int(1))  case $i as xs:int     return (copy $newVar := $var modify delete node $newVar/hours[1]     return $newVar)                            case $i as xs:double    return ()  default    return ()". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-030 :) (: Description: Evaluation of a transform expression used with typeswitch expression where the branch (a "case") is an updating (transform) expression. :) (: Other branches are the empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return typeswitch[Error is around here](xs:int(1))  case $i as xs:int     return (copy $newVar := $var modify delete node $newVar/hours[1]     return $newVar)                            case $i as xs:double    return ()  default    return ()
id-typeswitch-expr-031,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-031 :) (: Description: Evaluation of a transform expression used with typeswitch expression where the branch (a "default") is an updating (a transform) expression. :) (: Other branches are the empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return typeswitch(xs:int(1))  case $i as xs:string     return ()  case $i as xs:double     return ()   default    return (copy $newVar := $var modify delete node $newVar/hours[2]    return $newVar)". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-031 :) (: Description: Evaluation of a transform expression used with typeswitch expression where the branch (a "default") is an updating (a transform) expression. :) (: Other branches are the empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return typeswitch[Error is around here](xs:int(1))  case $i as xs:string     return ()  case $i as xs:double     return ()   default    return (copy $newVar := $var modify delete node $newVar/hours[2]    return $newVar)
id-typeswitch-expr-032,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-032 :) (: Description: Evaluation of a transform expression used with typeswitch expression where branch (a "case") is an updating (a transform) expression. :) (: All other branches return "fn:error()". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return typeswitch(xs:int(1))  case $i as xs:int    return (copy $newVar := $var modify delete node $newVar/hours[1]    return $newVar)                                                          case $i as xs:double     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  default  return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-032 :) (: Description: Evaluation of a transform expression used with typeswitch expression where branch (a "case") is an updating (a transform) expression. :) (: All other branches return "fn:error()". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return typeswitch[Error is around here](xs:int(1))  case $i as xs:int    return (copy $newVar := $var modify delete node $newVar/hours[1]    return $newVar)                                                          case $i as xs:double     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  default  return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))
id-typeswitch-expr-033,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-033 :) (: Description: Evaluation of a transform expression used with typeswitch expression where branch (the default) is an updating (a transform) expression. :) (: All other branches return "fn:error()". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var :=$input-context/works[1]/employee[2] return typeswitch(xs:int(1))  case $i as xs:string     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  case $i as xs:double     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  default     return (copy $newVar := $var modify delete node $newVar/hours[2]     return $newVar) ". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-033 :) (: Description: Evaluation of a transform expression used with typeswitch expression where branch (the default) is an updating (a transform) expression. :) (: All other branches return "fn:error()". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var :=$input-context/works[1]/employee[2] return typeswitch[Error is around here](xs:int(1))  case $i as xs:string     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  case $i as xs:double     return fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  default     return (copy $newVar := $var modify delete node $newVar/hours[2]     return $newVar)
id-typeswitch-expr-034,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-034 :) (: Description: Evaluation of a transform expression used with typeswitch expression where a branch (a "case") is an updating expression. :) (: All other branches return a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] return typeswitch(xs:int(1))  case $i as xs:int     return (copy $newVar := $var modify delete node $newVar/salary[1]     return $newVar)   case $i as xs:double     return "This test should not fail"  default     return "This test should not fail"". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-034 :) (: Description: Evaluation of a transform expression used with typeswitch expression where a branch (a "case") is an updating expression. :) (: All other branches return a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] return typeswitch[Error is around here](xs:int(1))  case $i as xs:int     return (copy $newVar := $var modify delete node $newVar/salary[1]     return $newVar)   case $i as xs:double     return "This test should not fail"  default     return "This test should not fail"
id-typeswitch-expr-035,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-035 :) (: Description: Evaluation of insert expression used with typeswitch expression where a branch (the "default") is an updating expression. :) (: All other branches return a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] return typeswitch(xs:int(1))  case $i as xs:string         return "This test should not fail"  case $i as xs:double     return "This test should not fail"  default     return (copy $newVar := $var modify delete node $newVar/salary[1]     return $newVar) ". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-035 :) (: Description: Evaluation of insert expression used with typeswitch expression where a branch (the "default") is an updating expression. :) (: All other branches return a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] return typeswitch[Error is around here](xs:int(1))  case $i as xs:string         return "This test should not fail"  case $i as xs:double     return "This test should not fail"  default     return (copy $newVar := $var modify delete node $newVar/salary[1]     return $newVar)
id-typeswitch-expr-036,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-036 :) (: Description: Updating typeswitch expression in an updating typeswitch expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    typeswitch(xs:int(10))       case $i as xs:int          return              typeswitch(xs:int(10))                case $i as xs:int                   return replace value of node $input-context/works[1]/employee[1]/hours[1] with 41                case $i as xs:double                   return replace value of node $input-context/works[1]/employee[1]/hours[1] with 42                default                   return replace value of node $input-context/works[1]/employee[1]/hours[1] with 43       case $i as xs:double          return replace value of node $input-context/works[1]/employee[1]/hours[1] with 44       default          return replace value of node $input-context/works[1]/employee[1]/hours[1] with 45 ". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-036 :) (: Description: Updating typeswitch expression in an updating typeswitch expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    typeswitch[Error is around here](xs:int(10))       case $i as xs:int          return              typeswitch(xs:int(10))                case $i as xs:int                   return replace value of node $input-context/works[1]/employee[1]/hours[1] with 41                case $i as xs:double                   return replace value of node $input-context/works[1]/employee[1]/hours[1] with 42                default                   return replace value of node $input-context/works[1]/employee[1]/hours[1] with 43       case $i as xs:double          return replace value of node $input-context/works[1]/employee[1]/hours[1] with 44       default          return replace value of node $input-context/works[1]/employee[1]/hours[1] with 45
id-typeswitch-expr-037,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-037 :) (: Description: Vacuous typeswitch expression in an updating typeswitch expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    typeswitch(xs:int(10))       case $i as xs:double          return              typeswitch(xs:int(10))                case $i as xs:int                   return ()                case $i as xs:double                   return ()                default                   return ()       case $i as xs:int          return replace value of node $input-context/works[1]/employee[1]/hours[1] with 44       default          return () ". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-037 :) (: Description: Vacuous typeswitch expression in an updating typeswitch expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    typeswitch[Error is around here](xs:int(10))       case $i as xs:double          return              typeswitch(xs:int(10))                case $i as xs:int                   return ()                case $i as xs:double                   return ()                default                   return ()       case $i as xs:int          return replace value of node $input-context/works[1]/employee[1]/hours[1] with 44       default          return ()
id-typeswitch-expr-038,Error: XPST0003: Unable to parse XPath: "(: Name: id-typeswitch-expr-038 :) (: Description: Simple typeswitch expression in an updating typeswitch expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    typeswitch(xs:int(10))       case $i as xs:double          return              typeswitch(xs:int(10))                case $i as xs:int                   return ()                case $i as xs:double                   return "Test"                default                   return ()       case $i as xs:int          return replace value of node $input-context/works[1]/employee[1]/hours[1] with 44       default          return () ". Expected "!", "!=", "#", "*", "+", ",", "-", "/", "//", ":", ":*", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", [A-Z_a-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-퟿豈-﷏ﷰ-�], [\-.0-9·̀-ͯ‿⁀], [�-�], or end of input but "(" found. (: Name: id-typeswitch-expr-038 :) (: Description: Simple typeswitch expression in an updating typeswitch expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    typeswitch[Error is around here](xs:int(10))       case $i as xs:double          return              typeswitch(xs:int(10))                case $i as xs:int                   return ()                case $i as xs:double                   return "Test"                default                   return ()       case $i as xs:int          return replace value of node $input-context/works[1]/employee[1]/hours[1] with 44       default          return ()
id-conditional-expr-01,Error: XPST0003: Unable to parse XPath: "(: Name: id-conditional-expr-01 :) (: Description: Evaluation of insert expression used with conditional expression where a branch (the "then") is an updating expression. :) (: The "else" returns the empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  if (fn:true()) then  insert node <hours>25</hours> into $input-context/works[1]/employee[2] else   ()". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-conditional-expr-01 :) (: Description: Evaluation of insert expression used with conditional expression where a branch (the "then") is an updating expression. :) (: The "else" returns the empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  if (fn:true()) then  insert [Error is around here]node <hours>25</hours> into $input-context/works[1]/employee[2] else   ()
id-conditional-expr-02,Error: XPST0003: Unable to parse XPath: "(: Name: id-conditional-expr-02 :) (: Description: Evaluation of insert expression used with conditional expression where a branch (the "else") is an updating expression. :) (: The "then" returns the empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  if (fn:false()) then  () else   insert node <hours>25</hours> into $input-context/works[1]/employee[2]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-conditional-expr-02 :) (: Description: Evaluation of insert expression used with conditional expression where a branch (the "else") is an updating expression. :) (: The "then" returns the empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  if (fn:false()) then  () else   insert [Error is around here]node <hours>25</hours> into $input-context/works[1]/employee[2]
id-conditional-expr-03,Error: XPST0003: Unable to parse XPath: "(: Name: id-conditional-expr-03 :) (: Description: Evaluation of insert expression used with conditional expression where a branch (the "then") is an updating expression. :) (: The "else" returns fn:error(). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  if (fn:true()) then   insert node <hours>25</hours> into $input-context/works[1]/employee[2] else   fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-conditional-expr-03 :) (: Description: Evaluation of insert expression used with conditional expression where a branch (the "then") is an updating expression. :) (: The "else" returns fn:error(). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  if (fn:true()) then   insert [Error is around here]node <hours>25</hours> into $input-context/works[1]/employee[2] else   fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))
id-conditional-expr-04,Error: XPST0003: Unable to parse XPath: "(: Name: id-conditional-expr-04 :) (: Description: Evaluation of insert expression used with conditional expression where a branch (the "else") is an updating expression. :) (: The "then" returns fn:error(). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  if (fn:false()) then   fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')) else  insert node <hours>25</hours> into $input-context/works[1]/employee[2]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-conditional-expr-04 :) (: Description: Evaluation of insert expression used with conditional expression where a branch (the "else") is an updating expression. :) (: The "then" returns fn:error(). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  if (fn:false()) then   fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')) else  insert [Error is around here]node <hours>25</hours> into $input-context/works[1]/employee[2]
id-conditional-expr-05,Error: XPST0003: Unable to parse XPath: "(: Name: id-conditional-expr-05 :) (: Description: Evaluation of insert expression used with conditional expression where a branch (the "then") is an updating expression. :) (: The "else" print a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  if (fn:true()) then  insert node <salary>25000</salary> into $input-context/employees[1]/employee[2] else   "This test should fail"". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-conditional-expr-05 :) (: Description: Evaluation of insert expression used with conditional expression where a branch (the "then") is an updating expression. :) (: The "else" print a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  if (fn:true()) then  insert [Error is around here]node <salary>25000</salary> into $input-context/employees[1]/employee[2] else   "This test should fail"
id-conditional-expr-06,Error: XPST0003: Unable to parse XPath: "(: Name: id-conditional-expr-06 :) (: Description: Evaluation of insert expression used with conditional expression where a branch (the "else") is an updating expression. :) (: The "then" print a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  if (fn:false()) then   "This test should fail" else  insert node <salary>25000</salary> into $input-context/employees[1]/employee[2]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-conditional-expr-06 :) (: Description: Evaluation of insert expression used with conditional expression where a branch (the "else") is an updating expression. :) (: The "then" print a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  if (fn:false()) then   "This test should fail" else  insert [Error is around here]node <salary>25000</salary> into $input-context/employees[1]/employee[2]
id-conditional-expr-07,Error: XPST0003: Unable to parse XPath: "(: Name: id-conditional-expr-07 :) (: Description: Evaluation of a delete expression used with conditional expression where a branch (the "then") is an updating expression. :) (: The "else" returns the empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return  if (fn:true()) then    delete node $var/hours[1]  else   ()". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-conditional-expr-07 :) (: Description: Evaluation of a delete expression used with conditional expression where a branch (the "then") is an updating expression. :) (: The "else" returns the empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return  if (fn:true()) then    delete [Error is around here]node $var/hours[1]  else   ()
id-conditional-expr-08,Error: XPST0003: Unable to parse XPath: "(: Name: id-conditional-expr-08 :) (: Description: Evaluation of a delete expression used with conditional expression where a branch (the "else") is an updating expression. :) (: The "then" returns the empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return  if (fn:false()) then   ()  else   delete node $var/hours[1]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-conditional-expr-08 :) (: Description: Evaluation of a delete expression used with conditional expression where a branch (the "else") is an updating expression. :) (: The "then" returns the empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return  if (fn:false()) then   ()  else   delete [Error is around here]node $var/hours[1]
id-conditional-expr-09,Error: XPST0003: Unable to parse XPath: "(: Name: id-conditional-expr-09 :) (: Description: Evaluation of a delete expression used with conditional expression where a branch (the "then") is an updating expression. :) (: The "else" returns fn:error(). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return  if (fn:true()) then   delete node $var/hours[1]  else   fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-conditional-expr-09 :) (: Description: Evaluation of a delete expression used with conditional expression where a branch (the "then") is an updating expression. :) (: The "else" returns fn:error(). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return  if (fn:true()) then   delete [Error is around here]node $var/hours[1]  else   fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))
id-conditional-expr-010,Error: XPST0003: Unable to parse XPath: "(: Name: id-conditional-expr-010 :) (: Description: Evaluation of a delete expression used with conditional expression where a branch (the "else") is an updating expression. :) (: The "then" returns fn:error(). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return  if (fn:false()) then   fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  else   delete node $var/hours[1]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-conditional-expr-010 :) (: Description: Evaluation of a delete expression used with conditional expression where a branch (the "else") is an updating expression. :) (: The "then" returns fn:error(). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return  if (fn:false()) then   fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))  else   delete [Error is around here]node $var/hours[1]
id-conditional-expr-011,Error: XPST0003: Unable to parse XPath: "(: Name: id-conditional-expr-011 :) (: Description: Evaluation of a delete expression used with conditional expression where a branch (the "then") is an updating expression. :) (: The "else" print a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return  if (fn:true()) then   delete node $var/salary[1]  else   "This test should fail"". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-conditional-expr-011 :) (: Description: Evaluation of a delete expression used with conditional expression where a branch (the "then") is an updating expression. :) (: The "else" print a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return  if (fn:true()) then   delete [Error is around here]node $var/salary[1]  else   "This test should fail"
id-conditional-expr-012,Error: XPST0003: Unable to parse XPath: "(: Name: id-conditional-expr-012 :) (: Description: Evaluation of a delete expression used with conditional expression where a branch (the "else") is an updating expression. :) (: The "then" print a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return  if (fn:false()) then   "This test should fail"  else    delete node $var/salary[1]". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: id-conditional-expr-012 :) (: Description: Evaluation of a delete expression used with conditional expression where a branch (the "else") is an updating expression. :) (: The "then" print a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return  if (fn:false()) then   "This test should fail"  else    delete [Error is around here]node $var/salary[1]
id-conditional-expr-015,Error: XPST0017: Function fn:error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
id-conditional-expr-016,Error: XPST0017: Function fn:error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
id-conditional-expr-017,Error: Should throw error XUST0001.
id-conditional-expr-018,Error: Should throw error XUST0001.
id-conditional-expr-021,Error: XPST0017: Function fn:error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
id-conditional-expr-022,Error: XPST0017: Function fn:error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?
id-conditional-expr-023,Error: Should throw error XUST0001.
id-conditional-expr-024,Error: Should throw error XUST0001.: expected 'XUDY0027: The target for a replace expression should not be empty.' to equal 'XUST0001'
id-conditional-expr-025,Error: XPST0003: Unable to parse XPath: "(: Name: id-conditional-expr-025 :) (: Description: Evaluation of a transform expression used with conditional expression where a branch (the "then") is an updating expression. :) (: The "else" returns the empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return if (fn:true()) then     (copy $newVar := $var modify delete node $newVar/hours[1]     return $newVar)  else   ()". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-conditional-expr-025 :) (: Description: Evaluation of a transform expression used with conditional expression where a branch (the "then") is an updating expression. :) (: The "else" returns the empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return if (fn:true()) then     (copy $newVar := $var modify delete [Error is around here]node $newVar/hours[1]     return $newVar)  else   ()
id-conditional-expr-026,Error: XPST0003: Unable to parse XPath: "(: Name: id-conditional-expr-026 :) (: Description: Evaluation of a transform expression used with conditional expression where a branch (the "else") is an updating expression. :) (: The "then" returns the empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var :=$input-context/works[1]/employee[2] return if (fn:false()) then    () else    (copy $newVar := $var modify delete node $newVar/hours[1]    return $newVar)". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-conditional-expr-026 :) (: Description: Evaluation of a transform expression used with conditional expression where a branch (the "else") is an updating expression. :) (: The "then" returns the empty sequence. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var :=$input-context/works[1]/employee[2] return if (fn:false()) then    () else    (copy $newVar := $var modify delete [Error is around here]node $newVar/hours[1]    return $newVar)
id-conditional-expr-027,Error: XPST0003: Unable to parse XPath: "(: Name: id-conditional-expr-027 :) (: Description: Evaluation of a transform expression used with conditional expression where a branch (the "then") is an updating expression. :) (: The "else" returns is an invokation to the fn:error function. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return if (fn:true()) then   (copy $newVar := $var modify delete node $newVar/hours[1]   return $newVar) else   fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-conditional-expr-027 :) (: Description: Evaluation of a transform expression used with conditional expression where a branch (the "then") is an updating expression. :) (: The "else" returns is an invokation to the fn:error function. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return if (fn:true()) then   (copy $newVar := $var modify delete [Error is around here]node $newVar/hours[1]   return $newVar) else   fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000'))
id-conditional-expr-028,Error: XPST0003: Unable to parse XPath: "(: Name: id-conditional-expr-028 :) (: Description: Evaluation of a transform expression used with conditional expression where a branch (the "else") is an updating expression. :) (: The "then" returns is an invokation to the fn:error function. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return if (fn:false()) then   fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')) else   (copy $newVar := $var modify delete node $newVar/hours[1]   return $newVar)". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-conditional-expr-028 :) (: Description: Evaluation of a transform expression used with conditional expression where a branch (the "else") is an updating expression. :) (: The "then" returns is an invokation to the fn:error function. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return if (fn:false()) then   fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')) else   (copy $newVar := $var modify delete [Error is around here]node $newVar/hours[1]   return $newVar)
id-conditional-expr-029,Error: XPST0003: Unable to parse XPath: "(: Name: id-conditional-expr-029 :) (: Description: Evaluation of a transform expression used with conditional expression where a branch (the "then") is an updating expression. :) (: The "else" returns a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return if (fn:true()) then   (copy $newVar := $var modify delete node $newVar/salary[1]   return $newVar) else   "This test should not fail"". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-conditional-expr-029 :) (: Description: Evaluation of a transform expression used with conditional expression where a branch (the "then") is an updating expression. :) (: The "else" returns a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return if (fn:true()) then   (copy $newVar := $var modify delete [Error is around here]node $newVar/salary[1]   return $newVar) else   "This test should not fail"
id-conditional-expr-030,Error: XPST0003: Unable to parse XPath: "(: Name: id-conditional-expr-030 :) (: Description: Evaluation of a transform expression used with conditional expression where a branch (the "else") is an updating expression. :) (: The "then" returns a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return if (fn:false()) then   "This test should fail" else   (copy $newVar := $var modify delete node $newVar/salary[1]   return $newVar) ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-conditional-expr-030 :) (: Description: Evaluation of a transform expression used with conditional expression where a branch (the "else") is an updating expression. :) (: The "then" returns a string. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return if (fn:false()) then   "This test should fail" else   (copy $newVar := $var modify delete [Error is around here]node $newVar/salary[1]   return $newVar)
id-conditional-expr-031,Error: XPST0003: Unable to parse XPath: "(: Name: id-conditional-expr-031 :) (: Description: Evaluates a transform expression together with a conditional expression where the if-clause is an non-updating (transform) expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return if (copy $newVar := $var modify delete node $newVar/hours[1] return $newVar) then     "This test should not fail" else    "This test should not fail"". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-conditional-expr-031 :) (: Description: Evaluates a transform expression together with a conditional expression where the if-clause is an non-updating (transform) expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return if (copy $newVar := $var modify delete [Error is around here]node $newVar/hours[1] return $newVar) then     "This test should not fail" else    "This test should not fail"
id-conditional-expr-032,Error: XPST0003: Unable to parse XPath: "(: Name: id-conditional-expr-032 :) (: Description: Evaluates a transform expression together with a conditional expression where the if-clause is an updating (delete) expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return if (delete node $var/hours[1]) then     "This test should fail" else    "This test should fail"". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-conditional-expr-032 :) (: Description: Evaluates a transform expression together with a conditional expression where the if-clause is an updating (delete) expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return if (delete [Error is around here]node $var/hours[1]) then     "This test should fail" else    "This test should fail"
id-conditional-expr-033,Error: XPST0003: Unable to parse XPath: "(: Name: id-conditional-expr-033 :) (: Description: Evaluates a conditional expression, where both branches are updating expressions (delete).  Both delete the same node (only one is selected). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return if (fn:true()) then    delete node $var/hours[1] else    delete node $var/hours[1]". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-conditional-expr-033 :) (: Description: Evaluates a conditional expression, where both branches are updating expressions (delete).  Both delete the same node (only one is selected). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return if (fn:true()) then    delete [Error is around here]node $var/hours[1] else    delete node $var/hours[1]
id-conditional-expr-034,Error: XPST0003: Unable to parse XPath: "(: Name: id-conditional-expr-034 :) (: Description: Evaluates a conditional expression, where the if brach contains a delete expression and the else branch contains transform expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return if (fn:true()) then     delete node $var else  copy $newVar := $var modify delete node $newVar/salary[1] return $newVar". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "else", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-conditional-expr-034 :) (: Description: Evaluates a conditional expression, where the if brach contains a delete expression and the else branch contains transform expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return if (fn:true()) then     delete [Error is around here]node $var else  copy $newVar := $var modify delete node $newVar/salary[1] return $newVar
id-conditional-expr-035,Error: XPST0003: Unable to parse XPath: "(: Name: id-conditional-expr-035 :) (: Description: Evaluates a conditional expression, where both braches contains a transform expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return if (fn:true()) then  copy $newVar := $var modify delete node $newVar/hours[1] return $newVar else  copy $newVar := $var modify delete node $newVar/hours[1] return $newVar". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-conditional-expr-035 :) (: Description: Evaluates a conditional expression, where both braches contains a transform expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return if (fn:true()) then  copy $newVar := $var modify delete [Error is around here]node $newVar/hours[1] return $newVar else  copy $newVar := $var modify delete node $newVar/hours[1] return $newVar
id-conditional-expr-038,Error: Should throw error XUST0001.
id-comma-expr-01,Error: XPST0003: Unable to parse XPath: "(: Name: id-comma-expr-01 :) (: Description: Evaluation of insert expression used with comma expression where both :) (: expressions are updating expressions.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var :=$input-context/works[1]/employee[1] return (insert node <hours>20</hours> as last into $var, insert node <hours>25</hours> as last into $var)". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-comma-expr-01 :) (: Description: Evaluation of insert expression used with comma expression where both :) (: expressions are updating expressions.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var :=$input-context/works[1]/employee[1] return (insert [Error is around here]node <hours>20</hours> as last into $var, insert node <hours>25</hours> as last into $var)
id-comma-expr-02,Error: XPST0003: Unable to parse XPath: "(: Name: id-comma-expr-02 :) (: Description: Evaluation of insert expression used with comma expression where first :) (: expression is an updating expression and the secon one is ().  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return (insert node <hours>20</hours> as last into $var, ())". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-comma-expr-02 :) (: Description: Evaluation of insert expression used with comma expression where first :) (: expression is an updating expression and the secon one is ().  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return (insert [Error is around here]node <hours>20</hours> as last into $var, ())
id-comma-expr-03,Error: XPST0003: Unable to parse XPath: "(: Name: id-comma-expr-03 :) (: Description: Evaluation of insert expression used with comma expression where first :) (: expression is () and second expression is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var :=$input-context/works[1]/employee[1] return ((),insert node <hours>20</hours> as last into $var)". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-comma-expr-03 :) (: Description: Evaluation of insert expression used with comma expression where first :) (: expression is () and second expression is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var :=$input-context/works[1]/employee[1] return ((),insert [Error is around here]node <hours>20</hours> as last into $var)
id-comma-expr-04,Error: XPST0003: Unable to parse XPath: "(: Name: id-comma-expr-04 :) (: Description: Evaluation of insert expression used with comma expression where first :) (: expression is an updating expression and the second one a call to fn:error().  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[3] return (insert node <hours>20</hours> as last into $var, fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-comma-expr-04 :) (: Description: Evaluation of insert expression used with comma expression where first :) (: expression is an updating expression and the second one a call to fn:error().  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[3] return (insert [Error is around here]node <hours>20</hours> as last into $var, fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')))
id-comma-expr-05,Error: XPST0003: Unable to parse XPath: "(: Name: id-comma-expr-05 :) (: Description: Evaluation of insert expression used with comma expression where first :) (: expression is a call to fn:error() and the second one updating expression .  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[3] return (fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')),insert node <hours>20</hours> as last into $var)". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-comma-expr-05 :) (: Description: Evaluation of insert expression used with comma expression where first :) (: expression is a call to fn:error() and the second one updating expression .  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[3] return (fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')),insert [Error is around here]node <hours>20</hours> as last into $var)
id-comma-expr-06,Error: XPST0003: Unable to parse XPath: "(: Name: id-comma-expr-06 :) (: Description: Evaluation of insert expression used with comma expression where first :) (: expression is an updating expression and the second one is a mathematical expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] return (insert node <salary>20600</salary> into $var, (6 idiv 2) + 1)". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-comma-expr-06 :) (: Description: Evaluation of insert expression used with comma expression where first :) (: expression is an updating expression and the second one is a mathematical expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] return (insert [Error is around here]node <salary>20600</salary> into $var, (6 idiv 2) + 1)
id-comma-expr-07,Error: XPST0003: Unable to parse XPath: "(: Name: id-comma-expr-07 :) (: Description: Evaluation of insert expression used with comma expression where first :) (: expression is a mathematical expression and second one is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] return ((6 idiv 2) + 1,insert node <salary>20</salary> into $var)". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-comma-expr-07 :) (: Description: Evaluation of insert expression used with comma expression where first :) (: expression is a mathematical expression and second one is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[1] return ((6 idiv 2) + 1,insert [Error is around here]node <salary>20</salary> into $var)
id-comma-expr-08,Error: XPST0003: Unable to parse XPath: "(: Name: id-comma-expr-08 :) (: Description: Evaluation a delete expression used with comma expression where both :) (: expressions are updating expressions.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return (delete node $var/hours[1], delete node $var/hours[2])". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-comma-expr-08 :) (: Description: Evaluation a delete expression used with comma expression where both :) (: expressions are updating expressions.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return (delete [Error is around here]node $var/hours[1], delete node $var/hours[2])
id-comma-expr-09,Error: XPST0003: Unable to parse XPath: "(: Name: id-comma-expr-09 :) (: Description: Evaluation of a delete expression used with comma expression where first :) (: expression is an updating expression and the secon one is ().  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return (delete node $var/hours[1], ())". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-comma-expr-09 :) (: Description: Evaluation of a delete expression used with comma expression where first :) (: expression is an updating expression and the secon one is ().  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return (delete [Error is around here]node $var/hours[1], ())
id-comma-expr-010,Error: XPST0003: Unable to parse XPath: "(: Name: id-comma-expr-010 :) (: Description: Evaluation of a delete expression used with comma expression where first :) (: expression is () and second expression is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return ((), delete node $var/hours[1])". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-comma-expr-010 :) (: Description: Evaluation of a delete expression used with comma expression where first :) (: expression is () and second expression is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return ((), delete [Error is around here]node $var/hours[1])
id-comma-expr-011,Error: XPST0003: Unable to parse XPath: "(: Name: id-comma-expr-011 :) (: Description: Evaluation of a delete expression used with comma expression where first :) (: expression is an updating expression and the second one a call to fn:error().  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return (delete node $var/hours[1], fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')))". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-comma-expr-011 :) (: Description: Evaluation of a delete expression used with comma expression where first :) (: expression is an updating expression and the second one a call to fn:error().  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return (delete [Error is around here]node $var/hours[1], fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')))
id-comma-expr-012,Error: XPST0003: Unable to parse XPath: "(: Name: id-comma-expr-012 :) (: Description: Evaluation of a delete expression used with comma expression where first :) (: expression is a call to fn:error() and the second one updating expression .  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return  (fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')),delete node $var/hours[1])". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-comma-expr-012 :) (: Description: Evaluation of a delete expression used with comma expression where first :) (: expression is a call to fn:error() and the second one updating expression .  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return  (fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')),delete [Error is around here]node $var/hours[1])
id-comma-expr-013,Error: XPST0003: Unable to parse XPath: "(: Name: id-comma-expr-013 :) (: Description: Evaluation of a delete expression used with comma expression where first :) (: expression is an updating expression and the second one is a mathematical expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return (delete node $var/salary[1], (6 idiv 2) + 1)". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-comma-expr-013 :) (: Description: Evaluation of a delete expression used with comma expression where first :) (: expression is an updating expression and the second one is a mathematical expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return (delete [Error is around here]node $var/salary[1], (6 idiv 2) + 1)
id-comma-expr-014,Error: XPST0003: Unable to parse XPath: "(: Name: id-comma-expr-014 :) (: Description: Evaluation of insert expression used with comma expression where first :) (: expression is a mathematical expression and second one is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return ((6 idiv 2) + 1, delete node $var/salary[1])". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-comma-expr-014 :) (: Description: Evaluation of insert expression used with comma expression where first :) (: expression is a mathematical expression and second one is an updating expression.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[2] return ((6 idiv 2) + 1, delete [Error is around here]node $var/salary[1])
id-comma-expr-015,Error: Not implemented: Intermediate clauses in flwor expressions are not implemented yet
id-comma-expr-018,Error: Should throw error FOER0000.: expected 'XPST0017: Function fn:error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?' to equal 'FOER0000'
id-comma-expr-019,Error: Should throw error FOER0000.: expected 'XPST0017: Function fn:error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?' to equal 'FOER0000'
id-comma-expr-020,Error: Should throw error XUST0001.
id-comma-expr-021,Error: Should throw error XUST0001.
id-comma-expr-025,Error: Should throw error FOER0000.: expected 'XPST0017: Function fn:error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?' to equal 'FOER0000'
id-comma-expr-026,Error: Should throw error FOER0000.: expected 'XPST0017: Function fn:error with arity of 1 not registered. Did you mean "Q{http://www.w3.org/2001/XMLSchema}error (xs:anyAtomicType?)"?' to equal 'FOER0000'
id-comma-expr-027,Error: Should throw error XUST0001.
id-comma-expr-028,Error: Should throw error XUST0001.
id-comma-expr-029,Error: XPST0003: Unable to parse XPath: "(: Name: id-comma-expr-029 :) (: Description: Evaluation of a transform expression used with comma expression where both :) (: expressions are updating expressions.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return   (copy $newVar1 := $var modify delete node $newVar1/hours[1] return $newVar1,    copy $newVar2 := $var modify delete node $newVar2/hours[2] return $newVar2)". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-comma-expr-029 :) (: Description: Evaluation of a transform expression used with comma expression where both :) (: expressions are updating expressions.  :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return   (copy $newVar1 := $var modify delete [Error is around here]node $newVar1/hours[1] return $newVar1,    copy $newVar2 := $var modify delete node $newVar2/hours[2] return $newVar2)
id-comma-expr-030,Error: XPST0003: Unable to parse XPath: "(: Name: id-comma-expr-030 :) (: Description: Evaluation of a transform expression used with comma expression where the :) (: first expression is an updating expression.  The second one is the empty sequence :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return   (copy $newVar := $var modify delete node $newVar/hours[1] return $newVar,())". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-comma-expr-030 :) (: Description: Evaluation of a transform expression used with comma expression where the :) (: first expression is an updating expression.  The second one is the empty sequence :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return   (copy $newVar := $var modify delete [Error is around here]node $newVar/hours[1] return $newVar,())
id-comma-expr-031,Error: XPST0003: Unable to parse XPath: "(: Name: id-comma-expr-031 :) (: Description: Evaluation of a transform expression used with comma expression where the :) (: the first expression is the empty sequence.  The second one is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var :=  $input-context/works[1]/employee[1] return   ((), copy $newVar := $var modify delete node $newVar/hours[1] return $newVar)". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-comma-expr-031 :) (: Description: Evaluation of a transform expression used with comma expression where the :) (: the first expression is the empty sequence.  The second one is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var :=  $input-context/works[1]/employee[1] return   ((), copy $newVar := $var modify delete [Error is around here]node $newVar/hours[1] return $newVar)
id-comma-expr-032,Error: XPST0003: Unable to parse XPath: "(: Name: id-comma-expr-032 :) (: Description: Evaluation of a transform expression used with comma expression where the :) (: first expression is an updating expression.  The second one is an invokation to fn:error() :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var :=  $input-context/works[1]/employee[1] return   (copy $newVar := $var modify delete node $newVar/hours[1] return $newVar, fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')))". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-comma-expr-032 :) (: Description: Evaluation of a transform expression used with comma expression where the :) (: first expression is an updating expression.  The second one is an invokation to fn:error() :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var :=  $input-context/works[1]/employee[1] return   (copy $newVar := $var modify delete [Error is around here]node $newVar/hours[1] return $newVar, fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')))
id-comma-expr-033,Error: XPST0003: Unable to parse XPath: "(: Name: id-comma-expr-033 :) (: Description: Evaluation of a transform expression used with comma expression where the :) (: first expression is an invokation to fn:error() and the second one is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var :=  $input-context/works[1]/employee[3] return   (fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')), copy $newVar := $var modify delete node $newVar/hours[1] return $newVar)". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-comma-expr-033 :) (: Description: Evaluation of a transform expression used with comma expression where the :) (: first expression is an invokation to fn:error() and the second one is an updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var :=  $input-context/works[1]/employee[3] return   (fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')), copy $newVar := $var modify delete [Error is around here]node $newVar/hours[1] return $newVar)
id-comma-expr-034,Error: XPST0003: Unable to parse XPath: "(: Name: id-comma-expr-034 :) (: Description: Evaluation of a transform expression used with comma expression where the :) (: first expression is an updating expression and the second one is a mathematical expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var :=  $input-context/employees[1]/employee[2] return   (copy $newVar := $var modify delete node $newVar/salary[1] return $newVar, xs:integer(1) + xs:integer(2))". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-comma-expr-034 :) (: Description: Evaluation of a transform expression used with comma expression where the :) (: first expression is an updating expression and the second one is a mathematical expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var :=  $input-context/employees[1]/employee[2] return   (copy $newVar := $var modify delete [Error is around here]node $newVar/salary[1] return $newVar, xs:integer(1) + xs:integer(2))
id-comma-expr-035,Error: XPST0003: Unable to parse XPath: "(: Name: id-comma-expr-035 :) (: Description: Evaluation of a transform expression used with comma expression where the :) (: first expression is a mathematical expression and the second one is a transform expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[3] return   (xs:integer(1) + xs:integer(2), copy $newVar := $var modify delete node $newVar/salary[1] return $newVar)". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-comma-expr-035 :) (: Description: Evaluation of a transform expression used with comma expression where the :) (: first expression is a mathematical expression and the second one is a transform expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/employees[1]/employee[3] return   (xs:integer(1) + xs:integer(2), copy $newVar := $var modify delete [Error is around here]node $newVar/salary[1] return $newVar)
id-comma-expr-038,Error: Should throw error XUST0001.
parenthesized-expr-02,Error: XPST0003: Unable to parse XPath: "(: Name: parenthesized-expr-02 :) (: Description: Parenthesized updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  for $var in     (    for $var in $input-context/works[1]/employee[1]/hours[1]    return delete node $var    ) return    $var ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: parenthesized-expr-02 :) (: Description: Parenthesized updating expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  for $var in     (    for $var in $input-context/works[1]/employee[1]/hours[1]    return delete [Error is around here]node $var    ) return    $var
id-function-call-01,Error: XPST0003: Unable to parse XPath: "(: Name: id-function-call-01 :) (: Description: Evaluation of insert expression used with function declaration. :) (: the function call contains an "updating" expression :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   declare function     local:insertFunction($e as xs:anyAtomicType)     {    let $e1 := $e    return      $e1    };     let $arg1 := $input-context/employees[1]/employee[1] return   local:insertFunction(insert node <salary>45000</salary> into $arg1)". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-function-call-01 :) (: Description: Evaluation of insert expression used with function declaration. :) (: the function call contains an "updating" expression :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   declare function     local:insertFunction($e as xs:anyAtomicType)     {    let $e1 := $e    return      $e1    };     let $arg1 := $input-context/employees[1]/employee[1] return   local:insertFunction(insert [Error is around here]node <salary>45000</salary> into $arg1)
id-function-call-02,Error: XPST0003: Unable to parse XPath: "(: Name: id-function-call-02 :) (: Description: Evaluation of a delete expression used with function declaration. :) (: the function call contains an "updating" (delete) expression :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   declare function     local:insertFunction($e as xs:anyAtomicType)     {    let $e1 := $e    return      $e1    };     let $arg1 := $input-context/employees[1]/employee[1] return   local:insertFunction(delete node $arg1/salary[1])". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-function-call-02 :) (: Description: Evaluation of a delete expression used with function declaration. :) (: the function call contains an "updating" (delete) expression :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   declare function     local:insertFunction($e as xs:anyAtomicType)     {    let $e1 := $e    return      $e1    };     let $arg1 := $input-context/employees[1]/employee[1] return   local:insertFunction(delete [Error is around here]node $arg1/salary[1])
id-function-call-03,Error: Should throw error XUST0001.: expected 'XPTY0004: Multiplicity of function argument of type xs:anyAtomicTypenull for replaceFunction is incorrect. Expected exactly one' to equal 'XUST0001'
id-function-call-04,Error: Should throw error XUST0001.: expected 'XPTY0004: Multiplicity of function argument of type xs:anyAtomicTypenull for renameFunction is incorrect. Expected exactly one' to equal 'XUST0001'
id-function-call-05,Error: XPST0003: Unable to parse XPath: "(: Name: id-function-call-05 :) (: Description: Evaluation of a transform expression used with function declaration. :) (: the function call contains an "updating" (transform) expression :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   declare function     local:transformFunction($e as xs:anyAtomicType)     {    let $e1 := $e    return      $e1    };     let $arg1 := $input-context/employees[1]/employee[1] return   concat('"', local:transformFunction(copy $newVar := $arg1 modify delete node $newVar/salary[1] return $newVar), '"')". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-function-call-05 :) (: Description: Evaluation of a transform expression used with function declaration. :) (: the function call contains an "updating" (transform) expression :)  (: insert-start :) declare variable $input-context external; (: insert-end :)   declare function     local:transformFunction($e as xs:anyAtomicType)     {    let $e1 := $e    return      $e1    };     let $arg1 := $input-context/employees[1]/employee[1] return   concat('"', local:transformFunction(copy $newVar := $arg1 modify delete [Error is around here]node $newVar/salary[1] return $newVar), '"')
id-function-call-06,Error: Should throw error XUST0001.: expected 'XPTY0004: Multiplicity of function argument of type xs:anyAtomicTypenull for renameFunction is incorrect. Expected exactly one' to equal 'XUST0001'
id-other-expr-01,Error: XPST0003: Unable to parse XPath: "(: Name: id-other-expr-01 :) (: Description: Evaluates usage of an updating expression (delete) in initializing expression for variable declaration. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  declare variable $x as xs:integer? := delete node $input-context/employees[1]/employee[1];  let $newVar := $x return  $newVar". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-other-expr-01 :) (: Description: Evaluates usage of an updating expression (delete) in initializing expression for variable declaration. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  declare variable $x as xs:integer? := delete [Error is around here]node $input-context/employees[1]/employee[1];  let $newVar := $x return  $newVar
id-other-expr-02,Error: XPST0003: Unable to parse XPath: "(: Name: id-other-expr-02 :) (: Description: Evaluates usage of an updating expression (insert) in initializing expression for variable declaration. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  declare variable $x as xs:integer? := insert node <salary>25600</salary> after $input-context/employees[1]/employee[1]/salary[1];  let $newVar := $x return  $newVar". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", ";", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-other-expr-02 :) (: Description: Evaluates usage of an updating expression (insert) in initializing expression for variable declaration. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  declare variable $x as xs:integer? := insert [Error is around here]node <salary>25600</salary> after $input-context/employees[1]/employee[1]/salary[1];  let $newVar := $x return  $newVar
id-other-expr-03,Error: Should throw error XUST0001.: expected 'Not implemented: only external variable declaration without default value is implemented in XQuery modules' to equal 'XUST0001'
id-other-expr-04,Error: Should throw error XUST0001.: expected 'Not implemented: only external variable declaration without default value is implemented in XQuery modules' to equal 'XUST0001'
id-other-expr-05,Error: XPST0003: Unable to parse XPath: "(: Name: id-other-expr-05 :) (: Description: Evaluates usage of an updating expression (transform) in initializing expression for variable declaration. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  declare variable $x := $input-context/works[1]/employee[1]; declare variable $y as element() := copy $newVar := $x modify delete node $newVar/hours[1] return $newVar;  $y". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-other-expr-05 :) (: Description: Evaluates usage of an updating expression (transform) in initializing expression for variable declaration. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  declare variable $x := $input-context/works[1]/employee[1]; declare variable $y as element() := copy $newVar := $x modify delete [Error is around here]node $newVar/hours[1] return $newVar;  $y
id-other-expr-06,Error: XPST0003: Unable to parse XPath: "(: Name: id-other-expr-06 :) (: Description: Evaluates usage of an updating expression (delete) as part of a logical (and) expression and usage of fn:true() function. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  fn:true() and (delete node $input-context/employees[1]/employee[1]/salary[1])". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-other-expr-06 :) (: Description: Evaluates usage of an updating expression (delete) as part of a logical (and) expression and usage of fn:true() function. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  fn:true() and (delete [Error is around here]node $input-context/employees[1]/employee[1]/salary[1])
id-other-expr-07,Error: XPST0003: Unable to parse XPath: "(: Name: id-other-expr-07 :) (: Description: Evaluates usage of an updating expression (delete) as part of a logical (or) expression and usage of fn:true() function. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  fn:true() or (delete node $input-context/employees[1]/employee[1]/salary[1])". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-other-expr-07 :) (: Description: Evaluates usage of an updating expression (delete) as part of a logical (or) expression and usage of fn:true() function. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  fn:true() or (delete [Error is around here]node $input-context/employees[1]/employee[1]/salary[1])
id-other-expr-08,Error: XPST0003: Unable to parse XPath: "(: Name: id-other-expr-08 :) (: Description: Evaluates usage of an updating expression (delete) as part of a logical (and) expression and usage of fn:false() function. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  fn:false() and (delete node $input-context/employees[1]/employee[1]/salary[1])". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-other-expr-08 :) (: Description: Evaluates usage of an updating expression (delete) as part of a logical (and) expression and usage of fn:false() function. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  fn:false() and (delete [Error is around here]node $input-context/employees[1]/employee[1]/salary[1])
id-other-expr-09,Error: XPST0003: Unable to parse XPath: "(: Name: id-other-expr-09 :) (: Description: Evaluates usage of an updating expression (delete) as part of a logical (or) expression and usage of fn:false() function. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  fn:false() or (delete node $input-context/employees[1]/employee[1]/salary[1])". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-other-expr-09 :) (: Description: Evaluates usage of an updating expression (delete) as part of a logical (or) expression and usage of fn:false() function. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  fn:false() or (delete [Error is around here]node $input-context/employees[1]/employee[1]/salary[1])
id-other-expr-010,Error: Should throw error XUST0001.: expected 'The expression (: Name: id-other-expr-010 :)\n(: Description: Evaluates usage of an updating expression (rename) as part of a logical (and) expression and usage of fn:true() function. :)\n\n(: insert-start :)\ndeclare variable $input-context external;\n(: insert-end :)\n\nfn:true() and (rename node $input-context/employees[1]/employee[1]/salary[1] as "salary1") is not updating and can not be executed as an updating expression.' to equal 'XUST0001'
id-other-expr-011,Error: Should throw error XUST0001.: expected 'The expression (: Name: id-other-expr-011 :)\n(: Description: Evaluates usage of an updating expression (replace) as part of a logical (and) expression and usage of fn:true() function. :)\n\n(: insert-start :)\ndeclare variable $input-context external;\n(: insert-end :)\n\nfn:true() and (replace node $input-context/employees[1]/employee[1]/salary[1] with <salary1>120000</salary1>) is not updating and can not be executed as an updating expression.' to equal 'XUST0001'
id-other-expr-012,Error: XPST0003: Unable to parse XPath: "(: Name: id-other-expr-012 :) (: Description: Evaluates usage of an updating expression (insert) as part of a logical (and) expression and usage of fn:true() function. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  fn:true() and (insert node <salary1>120000</salary1> into $input-context/employees[1]/employee[1])". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-other-expr-012 :) (: Description: Evaluates usage of an updating expression (insert) as part of a logical (and) expression and usage of fn:true() function. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  fn:true() and (insert [Error is around here]node <salary1>120000</salary1> into $input-context/employees[1]/employee[1])
id-other-expr-013,Error: XPST0003: Unable to parse XPath: "(: Name: id-other-expr-013 :) (: Description: Evaluates usage of an non updating expression (transform) as part of a logical (and) expression and usage of fn:true() function. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return  fn:true() and (copy $newVar := $var modify delete node $newVar/hours[1] return $newVar)". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-other-expr-013 :) (: Description: Evaluates usage of an non updating expression (transform) as part of a logical (and) expression and usage of fn:true() function. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return  fn:true() and (copy $newVar := $var modify delete [Error is around here]node $newVar/hours[1] return $newVar)
id-other-expr-014,Error: Should throw error XUST0001.: expected 'The expression (: Name: id-other-expr-014 :)\n(: Description: Evaluates usage of an updating expression (rename) as part of a Node Comparison (is) expression. :)\n\n(: insert-start :)\ndeclare variable $input-context external;\n(: insert-end :)\n\n($input-context/employees[1]/employee[1]/salary[1]) is (rename node $input-context/employees[1]/employee[1]/salary[1] as "salary1") is not updating and can not be executed as an updating expression.' to equal 'XUST0001'
id-other-expr-015,Error: XPST0003: Unable to parse XPath: "(: Name: id-other-expr-015 :) (: Description: Evaluates usage of an updating expression (delete) as part of a Node Comparison (is) expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  ($input-context/employees[1]/employee[1]/salary[1]) is (delete node $input-context/employees[1]/employee[1]/salary[1])". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-other-expr-015 :) (: Description: Evaluates usage of an updating expression (delete) as part of a Node Comparison (is) expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  ($input-context/employees[1]/employee[1]/salary[1]) is (delete [Error is around here]node $input-context/employees[1]/employee[1]/salary[1])
id-other-expr-016,Error: Should throw error XUST0001.: expected 'The expression (: Name: id-other-expr-016 :)\n(: Description: Evaluates usage of an updating expression (replace) as part of a Node Comparison (is) expression. :)\n\n(: insert-start :)\ndeclare variable $input-context external;\n(: insert-end :)\n\n($input-context/employees[1]/employee[1]/salary[1]) is (replace node $input-context/employees[1]/employee[1]/salary[1] with <salary1>120000</salary1>) is not updating and can not be executed as an updating expression.' to equal 'XUST0001'
id-other-expr-017,Error: XPST0003: Unable to parse XPath: "(: Name: id-other-expr-017 :) (: Description: Evaluates usage of an non updating expression (transform) as part of a node comparison (is) expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return  ($var) is (copy $newVar := $var modify delete node $newVar/hours[1] return $newVar)". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-other-expr-017 :) (: Description: Evaluates usage of an non updating expression (transform) as part of a node comparison (is) expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return  ($var) is (copy $newVar := $var modify delete [Error is around here]node $newVar/hours[1] return $newVar)
id-other-expr-018,Error: XPST0003: Unable to parse XPath: "(: Name: id-other-expr-018 :) (: Description: Evaluates usage of an non updating expression (transform) as part of a node comparison (is) expression (both operands are transform expressions). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return  (copy $newVar := $var modify delete node $newVar/hours[1] return $newVar) is (copy $newVar := $var modify delete node $newVar/hours[1] return $newVar)". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-other-expr-018 :) (: Description: Evaluates usage of an non updating expression (transform) as part of a node comparison (is) expression (both operands are transform expressions). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return  (copy $newVar := $var modify delete [Error is around here]node $newVar/hours[1] return $newVar) is (copy $newVar := $var modify delete node $newVar/hours[1] return $newVar)
id-other-expr-019,Error: XPST0003: Unable to parse XPath: "(: Name: id-other-expr-019 :) (: Description: Evaluates usage of an updating expression (insert) as part of a Node Comparison (is) expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  ($input-context/employees[1]/employee[1]/salary[1]) is (insert node <salary1>107900</salary1> into $input-context/employees[1]/employee[1])". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-other-expr-019 :) (: Description: Evaluates usage of an updating expression (insert) as part of a Node Comparison (is) expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  ($input-context/employees[1]/employee[1]/salary[1]) is (insert [Error is around here]node <salary1>107900</salary1> into $input-context/employees[1]/employee[1])
id-other-expr-020,Error: XPST0003: Unable to parse XPath: "(: Name: id-other-expr-020 :) (: Description: Evaluates usage of an updating expression (insert) as part of a value Comparison (eq) expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  ($input-context/employees[1]/employee[1]/salary[1]) eq (insert node <salary1>107900</salary1> into $input-context/employees[1]/employee[1])". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-other-expr-020 :) (: Description: Evaluates usage of an updating expression (insert) as part of a value Comparison (eq) expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  ($input-context/employees[1]/employee[1]/salary[1]) eq (insert [Error is around here]node <salary1>107900</salary1> into $input-context/employees[1]/employee[1])
id-other-expr-021,Error: Should throw error XUST0001.: expected 'The expression (: Name: id-other-expr-021 :)\n(: Description:  Evaluates usage of an updating expression (rename) as part of a value Comparison (ne) expression. :)\n\n(: insert-start :)\ndeclare variable $input-context external;\n(: insert-end :)\n\n($input-context/employees[1]/employee[1]/salary[1]) ne (rename node $input-context/employees[1]/employee[1]/salary[1] as "salary1") is not updating and can not be executed as an updating expression.' to equal 'XUST0001'
id-other-expr-022,Error: Should throw error XUST0001.: expected 'The expression (: Name: id-other-expr-022 :)\n(: Description:  Evaluates usage of an updating expression (rename) as part of a value Comparison (gt operator) expression. :)\n\n(: insert-start :)\ndeclare variable $input-context external;\n(: insert-end :)\n\n($input-context/employees[1]/employee[1]/salary[1]) gt (rename node $input-context/employees[1]/employee[1]/salary[1] as "salary1") is not updating and can not be executed as an updating expression.' to equal 'XUST0001'
id-other-expr-023,Error: Should throw error XUST0001.: expected 'The expression (: Name: id-other-expr-023 :)\n(: Description:  Evaluates usage of an updating expression (rename) as part of a value Comparison (lt operator) expression. :)\n\n(: insert-start :)\ndeclare variable $input-context external;\n(: insert-end :)\n\n($input-context/employees[1]/employee[1]/salary[1]) lt (rename node $input-context/employees[1]/employee[1]/salary[1] as "salary1") is not updating and can not be executed as an updating expression.' to equal 'XUST0001'
id-other-expr-024,Error: Should throw error XUST0001.: expected 'The expression (: Name: id-other-expr-024 :)\n(: Description:  Evaluates usage of an updating expression (rename) as part of a value Comparison (le operator) expression. :)\n\n(: insert-start :)\ndeclare variable $input-context external;\n(: insert-end :)\n\n($input-context/employees[1]/employee[1]/salary[1]) le (rename node $input-context/employees[1]/employee[1]/salary[1] as "salary1") is not updating and can not be executed as an updating expression.' to equal 'XUST0001'
id-other-expr-025,Error: Should throw error XUST0001.: expected 'The expression (: Name: id-other-expr-025 :)\n(: Description:  Evaluates usage of an updating expression (rename) as part of a value Comparison (ge operator) expression. :)\n\n(: insert-start :)\ndeclare variable $input-context external;\n(: insert-end :)\n\n($input-context/employees[1]/employee[1]/salary[1]) ge (rename node $input-context/employees[1]/employee[1]/salary[1] as "salary1") is not updating and can not be executed as an updating expression.' to equal 'XUST0001'
id-other-expr-26,Error: XPST0003: Unable to parse XPath: "(: Name: id-other-expr-026 :) (: Description: Evaluates usage of an updating expression (delete) as part of a sequence expression (union operator). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  ($input-context/employees[1]/employee[1]) union (delete node $input-context/employees[1]/employee[2])". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-other-expr-026 :) (: Description: Evaluates usage of an updating expression (delete) as part of a sequence expression (union operator). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  ($input-context/employees[1]/employee[1]) union (delete [Error is around here]node $input-context/employees[1]/employee[2])
id-other-expr-027,Error: XPST0003: Unable to parse XPath: "(: Name: id-other-expr-027 :) (: Description: Evaluates usage of an updating expression (delete) as part of a sequence expression (intersect operator). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  ($input-context/employees[1]/employee[1]) intersect (delete node $input-context/employees[1]/employee[2])". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-other-expr-027 :) (: Description: Evaluates usage of an updating expression (delete) as part of a sequence expression (intersect operator). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  ($input-context/employees[1]/employee[1]) intersect (delete [Error is around here]node $input-context/employees[1]/employee[2])
id-other-expr-028,Error: XPST0003: Unable to parse XPath: "(: Name: id-other-expr-028 :) (: Description: Evaluates usage of an updating expression (delete) as part of a sequence expression (except operator). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  ($input-context/employees[1]/employee[1]) except (delete node $input-context/employees[1]/employee[2])". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-other-expr-028 :) (: Description: Evaluates usage of an updating expression (delete) as part of a sequence expression (except operator). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  ($input-context/employees[1]/employee[1]) except (delete [Error is around here]node $input-context/employees[1]/employee[2])
id-other-expr-029,Error: XPST0003: Unable to parse XPath: "(: Name: id-other-expr-029 :) (: Description: Evaluates usage of an non updating expression (transform) as part of a sequence expression (union operator). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var1 := $input-context/works[1]/employee[1] let $var2 := $input-context/works[1]/employee[2] return (copy $newVar := $var1 modify delete node $newVar/hours[1] return $newVar) union (copy $newVar := $var2 modify delete node $newVar/hours[1] return $newVar)". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-other-expr-029 :) (: Description: Evaluates usage of an non updating expression (transform) as part of a sequence expression (union operator). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var1 := $input-context/works[1]/employee[1] let $var2 := $input-context/works[1]/employee[2] return (copy $newVar := $var1 modify delete [Error is around here]node $newVar/hours[1] return $newVar) union (copy $newVar := $var2 modify delete node $newVar/hours[1] return $newVar)
id-other-expr-030,Error: XPST0003: Unable to parse XPath: "(: Name: id-other-expr-030 :) (: Description: Evaluates usage of an non updating expression (transform) as part of a sequence expression (intersect operator). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var1 := $input-context/works[1]/employee[1] return fn:count((copy $newVar := $var1 modify delete node $newVar/hours[1] return $newVar) intersect (copy $newVar := $var1 modify delete node $newVar/hours[1] return $newVar))". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-other-expr-030 :) (: Description: Evaluates usage of an non updating expression (transform) as part of a sequence expression (intersect operator). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var1 := $input-context/works[1]/employee[1] return fn:count((copy $newVar := $var1 modify delete [Error is around here]node $newVar/hours[1] return $newVar) intersect (copy $newVar := $var1 modify delete node $newVar/hours[1] return $newVar))
id-other-expr-031,Error: XPST0003: Unable to parse XPath: "(: Name: id-other-expr-031 :) (: Description: Evaluates usage of an non updating expression (transform) as part of a sequence expression (except operator). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var1 := $input-context/works[1]/employee[1] let $var2 := $input-context/works[1]/employee[2] return (copy $newVar := $var1 modify delete node $newVar/hours[1] return $newVar) except (copy $newVar := $var2 modify delete node $newVar/hours[1] return $newVar)". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-other-expr-031 :) (: Description: Evaluates usage of an non updating expression (transform) as part of a sequence expression (except operator). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var1 := $input-context/works[1]/employee[1] let $var2 := $input-context/works[1]/employee[2] return (copy $newVar := $var1 modify delete [Error is around here]node $newVar/hours[1] return $newVar) except (copy $newVar := $var2 modify delete node $newVar/hours[1] return $newVar)
id-other-expr-032,Error: XPST0003: Unable to parse XPath: "(: Name: id-other-expr-032 :) (: Description: Evaluates usage of an updating expression (delete) as part of a range expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  ($input-context/employees[1]/employee[1]) to (delete node $input-context/employees[1]/employee[2])". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: id-other-expr-032 :) (: Description: Evaluates usage of an updating expression (delete) as part of a range expression. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  ($input-context/employees[1]/employee[1]) to (delete [Error is around here]node $input-context/employees[1]/employee[2])
fn-put-001,Error: A non-updating expression without an expected value is not supported in the test framework.
fn-put-007,Error: Should throw error FOUP0002.: expected 'No selector counterpart for: computedDocumentConstructor.' to equal 'FOUP0002'
fn-put-008,Error: Should throw error XUST0001.: expected 'No selector counterpart for: computedDocumentConstructor.' to equal 'XUST0001'
fn-put-009,Error: XPST0003: Unable to parse XPath: "(: Name: fn-put-009 :) (: Description: Check that fn:put is an updating function. :)  (: insert-start :) declare variable $input-context external; declare variable $input-URI external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert node <retiring/> as last into $var,    fn:put(document { <test/> }, $input-URI)    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: fn-put-009 :) (: Description: Check that fn:put is an updating function. :)  (: insert-start :) declare variable $input-context external; declare variable $input-URI external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert [Error is around here]node <retiring/> as last into $var,    fn:put(document { <test/> }, $input-URI)    )
fn-put-011,Error: XPST0003: Unable to parse XPath: "(: Name: fn-put-011 :) (: Description: Check that fn:put does not become effective until after completion of the snapshot. :)  (: insert-start :) declare variable $input-context external; declare variable $input-URI external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    fn:put(document { <test/> }, $input-URI),    insert node fn:doc($input-URI)/test[1] as last into $var    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: fn-put-011 :) (: Description: Check that fn:put does not become effective until after completion of the snapshot. :)  (: insert-start :) declare variable $input-context external; declare variable $input-URI external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    fn:put(document { <test/> }, $input-URI),    insert [Error is around here]node fn:doc($input-URI)/test[1] as last into $var    )
fn-put-012,Error: Should throw error XUDY0031.: expected 'No selector counterpart for: computedDocumentConstructor.' to equal 'XUDY0031'
fn-put-013,Error: A non-updating expression without an expected value is not supported in the test framework.
fn-put-014,Error: Should throw error XUDY0031.: expected 'No selector counterpart for: computedDocumentConstructor.' to equal 'XUDY0031'
put-001,Error: A non-updating expression without an expected value is not supported in the test framework.
fn-put-002,Error: A non-updating expression without an expected value is not supported in the test framework.
fn-put-010,Error: XPST0003: Unable to parse XPath: "(: Name: fn-put-010 :) (: Description: Check that fn:put operates after other update operations. :)  (: insert-start :) declare variable $input-context external; declare variable $input-URI external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    fn:put($var, $input-URI),    insert node <retiring/> as last into $var    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: fn-put-010 :) (: Description: Check that fn:put operates after other update operations. :)  (: insert-start :) declare variable $input-context external; declare variable $input-URI external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    fn:put($var, $input-URI),    insert [Error is around here]node <retiring/> as last into $var    )
attribute-errors-q1,Error: XPST0003: Unable to parse XPath: "(: Name: attribute-errors-q1 :) (: Description: Insert of attribute that already exists. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert node attribute { "name" } { "Mavis Gertrude Smith" } into $input-context/works/employee[1] ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: attribute-errors-q1 :) (: Description: Insert of attribute that already exists. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert [Error is around here]node attribute { "name" } { "Mavis Gertrude Smith" } into $input-context/works/employee[1]
attribute-errors-q2,Error: XPST0003: Unable to parse XPath: "(: Name: attribute-errors-q2 :) (: Description: Insert of multiple attributes, one of which already exists. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert node <tmp otherAttr="some value" name="Mavis Gertrude Smith" andMore="attrs"/>/@* into $input-context/works/employee[1] ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: attribute-errors-q2 :) (: Description: Insert of multiple attributes, one of which already exists. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert [Error is around here]node <tmp otherAttr="some value" name="Mavis Gertrude Smith" andMore="attrs"/>/@* into $input-context/works/employee[1]
attribute-errors-q3,Error: XPST0003: Unable to parse XPath: "(: Name: attribute-errors-q3 :) (: Description: Insert of multiple attributes with the same name. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert node (attribute {"sameName"} {"some value"}, attribute {"sameName"} {"another value"}) into $input-context/works/employee[1] ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: attribute-errors-q3 :) (: Description: Insert of multiple attributes with the same name. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert [Error is around here]node (attribute {"sameName"} {"some value"}, attribute {"sameName"} {"another value"}) into $input-context/works/employee[1]
attribute-errors-q4,Error: XPST0003: Unable to parse XPath: "(: Name: attribute-errors-q4 :) (: Description: Insert of multiple attributes, some with the same name. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert node (attribute {"sameName"} {"some value"}, attribute {"anotherName"} {()}, attribute {"sameName"} {"another value"}) into $input-context/works/employee[1] ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: attribute-errors-q4 :) (: Description: Insert of multiple attributes, some with the same name. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert [Error is around here]node (attribute {"sameName"} {"some value"}, attribute {"anotherName"} {()}, attribute {"sameName"} {"another value"}) into $input-context/works/employee[1]
attribute-errors-q5,Error: XPST0003: Unable to parse XPath: "(: Name: attribute-errors-q5 :) (: Description: Multiple inserts of attributes with the same name. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert node attribute {"sameName"} {"some value"} into $input-context/works/employee[1], insert node attribute {"sameName"} {"another value"} into $input-context//employee[@name="Jane Doe 1"] ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: attribute-errors-q5 :) (: Description: Multiple inserts of attributes with the same name. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert [Error is around here]node attribute {"sameName"} {"some value"} into $input-context/works/employee[1], insert node attribute {"sameName"} {"another value"} into $input-context//employee[@name="Jane Doe 1"]
attribute-errors-q6,Error: XPST0003: Unable to parse XPath: "(: Name: attribute-errors-q6 :) (: Description: Multiple inserts of attributes, some with the same name. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert node attribute {"sameName"} {"some value"} into $input-context/works/employee[1], insert node attribute {"anotherName"} {()} into $input-context/works/employee[@gender="female"][1], insert node attribute {"sameName"} {"another value"} into $input-context//employee[@name="Jane Doe 1"] ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: attribute-errors-q6 :) (: Description: Multiple inserts of attributes, some with the same name. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert [Error is around here]node attribute {"sameName"} {"some value"} into $input-context/works/employee[1], insert node attribute {"anotherName"} {()} into $input-context/works/employee[@gender="female"][1], insert node attribute {"sameName"} {"another value"} into $input-context//employee[@name="Jane Doe 1"]
attribute-errors-q7,Error: XPST0003: Unable to parse XPath: "(: Name: attribute-errors-q7 :) (: Description: Multiple inserts of attributes, one of which already exists. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert node attribute {"sameName"} {"some value"} into $input-context/works/employee[1], insert node attribute {"name"} {"Mavis Gertrude Smith"} into $input-context/works/employee[@gender="female"][1], insert node attribute {"sameName"} {"another value"} into $input-context//employee[@name="Jane Doe 1"] ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: attribute-errors-q7 :) (: Description: Multiple inserts of attributes, one of which already exists. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert [Error is around here]node attribute {"sameName"} {"some value"} into $input-context/works/employee[1], insert node attribute {"name"} {"Mavis Gertrude Smith"} into $input-context/works/employee[@gender="female"][1], insert node attribute {"sameName"} {"another value"} into $input-context//employee[@name="Jane Doe 1"]
attribute-errors-q15,Error: XPST0003: Unable to parse XPath: "(: Name: attribute-errors-q15 :) (: Description: Insert and replace of attributes which have the same name. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert node attribute {"otherName"} {"some value"} into $input-context/works/employee[1], replace node $input-context/works/employee[@name="Jane Doe 1"]/@gender with attribute {"otherName"} {"another value"} ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: attribute-errors-q15 :) (: Description: Insert and replace of attributes which have the same name. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert [Error is around here]node attribute {"otherName"} {"some value"} into $input-context/works/employee[1], replace node $input-context/works/employee[@name="Jane Doe 1"]/@gender with attribute {"otherName"} {"another value"}
attribute-errors-q16,Error: XPST0003: Unable to parse XPath: "(: Name: attribute-errors-q15 :) (: Description: Insert and replace of multiple attributes, some of which have the same name. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert node (attribute {"shiny"} {"no"}, attribute {"otherName"} {"some value"}) into $input-context/works/employee[1], replace node $input-context/works/employee[@name="Jane Doe 1"]/@gender with (attribute {"sparkly"} {"yes"}, attribute {"otherName"} {"another value"}) ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: attribute-errors-q15 :) (: Description: Insert and replace of multiple attributes, some of which have the same name. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert [Error is around here]node (attribute {"shiny"} {"no"}, attribute {"otherName"} {"some value"}) into $input-context/works/employee[1], replace node $input-context/works/employee[@name="Jane Doe 1"]/@gender with (attribute {"sparkly"} {"yes"}, attribute {"otherName"} {"another value"})
attribute-errors-q17,Error: XPST0003: Unable to parse XPath: "(: Name: attribute-errors-q17 :) (: Description: Insert of duplicate attributes in a deleted sub-tree. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert node (attribute {"gender"} {"male"}) into $input-context/works/employee[1], delete node $input-context/works/employee[1] ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: attribute-errors-q17 :) (: Description: Insert of duplicate attributes in a deleted sub-tree. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert [Error is around here]node (attribute {"gender"} {"male"}) into $input-context/works/employee[1], delete node $input-context/works/employee[1]
namespace-errors-q1,Error: XPST0003: Unable to parse XPath: "(: Name: namespace-errors-q1 :) (: Description: Insert after of attribute with implicit namespace binding that clashes. :)  declare namespace nara = "http://www.anr.fr/nara"; declare namespace univ = "http://www.education.gouv.fr"; declare namespace coop = "http://www.gouv.fr/univ-industry-coop/"; declare namespace agro = "http://www.agroplus.com";  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert node attribute { fn:QName("http://www.example.com", "nara:name") } { "Mavis Gertrude Smith" } after $input-context/grant/univ:lab ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: namespace-errors-q1 :) (: Description: Insert after of attribute with implicit namespace binding that clashes. :)  declare namespace nara = "http://www.anr.fr/nara"; declare namespace univ = "http://www.education.gouv.fr"; declare namespace coop = "http://www.gouv.fr/univ-industry-coop/"; declare namespace agro = "http://www.agroplus.com";  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert [Error is around here]node attribute { fn:QName("http://www.example.com", "nara:name") } { "Mavis Gertrude Smith" } after $input-context/grant/univ:lab
namespace-errors-q2,Error: XPST0003: Unable to parse XPath: "(: Name: namespace-errors-q2 :) (: Description: Insert of attribute with implicit namespace binding that clashes. :)  declare namespace nara = "http://www.anr.fr/nara"; declare namespace univ = "http://www.education.gouv.fr"; declare namespace coop = "http://www.gouv.fr/univ-industry-coop/"; declare namespace agro = "http://www.agroplus.com";  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert node attribute { fn:QName("http://www.example.com", "nara:name") } { "Mavis Gertrude Smith" } into $input-context/grant/nara:lab/coop:PhD ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: namespace-errors-q2 :) (: Description: Insert of attribute with implicit namespace binding that clashes. :)  declare namespace nara = "http://www.anr.fr/nara"; declare namespace univ = "http://www.education.gouv.fr"; declare namespace coop = "http://www.gouv.fr/univ-industry-coop/"; declare namespace agro = "http://www.agroplus.com";  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert [Error is around here]node attribute { fn:QName("http://www.example.com", "nara:name") } { "Mavis Gertrude Smith" } into $input-context/grant/nara:lab/coop:PhD
namespace-errors-q3,Error: XPST0003: Unable to parse XPath: "(: Name: namespace-errors-q3 :) (: Description: Insert as first of attribute with implicit namespace binding that clashes. :)  declare namespace nara = "http://www.anr.fr/nara"; declare namespace univ = "http://www.education.gouv.fr"; declare namespace coop = "http://www.gouv.fr/univ-industry-coop/"; declare namespace agro = "http://www.agroplus.com";  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert node attribute { fn:QName("http://www.example.com", "univ:name") } { "Mavis Gertrude Smith" } as first into $input-context/grant/univ:lab ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: namespace-errors-q3 :) (: Description: Insert as first of attribute with implicit namespace binding that clashes. :)  declare namespace nara = "http://www.anr.fr/nara"; declare namespace univ = "http://www.education.gouv.fr"; declare namespace coop = "http://www.gouv.fr/univ-industry-coop/"; declare namespace agro = "http://www.agroplus.com";  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert [Error is around here]node attribute { fn:QName("http://www.example.com", "univ:name") } { "Mavis Gertrude Smith" } as first into $input-context/grant/univ:lab
namespace-errors-q9,Error: XPST0003: Unable to parse XPath: "(: Name: namespace-errors-q9 :) (: Description: Multiple inserts of attribute with implicit namespace binding that clashes. :)  declare namespace nara = "http://www.anr.fr/nara"; declare namespace univ = "http://www.education.gouv.fr"; declare namespace coop = "http://www.gouv.fr/univ-industry-coop/"; declare namespace agro = "http://www.agroplus.com";  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert node attribute { fn:QName("http://www.example.com", "newns:name") } { "Mavis Gertrude Smith" } after $input-context/grant/univ:lab, insert node attribute { fn:QName("http://www.example.com/test", "newns:sparkle") } { "not really" } after $input-context/grant/*:lab[2] ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: namespace-errors-q9 :) (: Description: Multiple inserts of attribute with implicit namespace binding that clashes. :)  declare namespace nara = "http://www.anr.fr/nara"; declare namespace univ = "http://www.education.gouv.fr"; declare namespace coop = "http://www.gouv.fr/univ-industry-coop/"; declare namespace agro = "http://www.agroplus.com";  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert [Error is around here]node attribute { fn:QName("http://www.example.com", "newns:name") } { "Mavis Gertrude Smith" } after $input-context/grant/univ:lab, insert node attribute { fn:QName("http://www.example.com/test", "newns:sparkle") } { "not really" } after $input-context/grant/*:lab[2]
namespace-errors-q10,Error: XPST0003: Unable to parse XPath: "(: Name: namespace-errors-q10 :) (: Description: Insert and replace of attributes with implicit namespace binding that clashes. :)  declare namespace nara = "http://www.anr.fr/nara"; declare namespace univ = "http://www.education.gouv.fr"; declare namespace coop = "http://www.gouv.fr/univ-industry-coop/"; declare namespace agro = "http://www.agroplus.com";  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert node attribute { fn:QName("http://www.example.com", "newns:name") } { "Mavis Gertrude Smith" } into $input-context/grant/univ:lab, replace node $input-context/grant/*:lab[2]/@name with attribute { fn:QName("http://www.example.com/test", "newns:sparkle") } { "not really" } ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: namespace-errors-q10 :) (: Description: Insert and replace of attributes with implicit namespace binding that clashes. :)  declare namespace nara = "http://www.anr.fr/nara"; declare namespace univ = "http://www.education.gouv.fr"; declare namespace coop = "http://www.gouv.fr/univ-industry-coop/"; declare namespace agro = "http://www.agroplus.com";  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert [Error is around here]node attribute { fn:QName("http://www.example.com", "newns:name") } { "Mavis Gertrude Smith" } into $input-context/grant/univ:lab, replace node $input-context/grant/*:lab[2]/@name with attribute { fn:QName("http://www.example.com/test", "newns:sparkle") } { "not really" }
namespace-errors-q14,Error: XPST0003: Unable to parse XPath: "(: Name: namespace-errors-q14 :) (: Description: Rename and insert of attributes with implicit namespace binding that clashes. :)  declare namespace nara = "http://www.anr.fr/nara"; declare namespace univ = "http://www.education.gouv.fr"; declare namespace coop = "http://www.gouv.fr/univ-industry-coop/"; declare namespace agro = "http://www.agroplus.com";  (: insert-start :) declare variable $input-context external; (: insert-end :)  rename node $input-context//nara:researcher[@name="Fred"]/@position as fn:QName("http://www.example.com/test", "newns:sparkle"), insert node attribute { fn:QName("http://www.example.com", "newns:name") } {"Hugo"} into $input-context//nara:researcher[1] ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: namespace-errors-q14 :) (: Description: Rename and insert of attributes with implicit namespace binding that clashes. :)  declare namespace nara = "http://www.anr.fr/nara"; declare namespace univ = "http://www.education.gouv.fr"; declare namespace coop = "http://www.gouv.fr/univ-industry-coop/"; declare namespace agro = "http://www.agroplus.com";  (: insert-start :) declare variable $input-context external; (: insert-end :)  rename node $input-context//nara:researcher[@name="Fred"]/@position as fn:QName("http://www.example.com/test", "newns:sparkle"), insert [Error is around here]node attribute { fn:QName("http://www.example.com", "newns:name") } {"Hugo"} into $input-context//nara:researcher[1]
namespace-errors-q15,Error: XPST0003: Unable to parse XPath: "(: Name: namespace-errors-q15 :) (: Description: Rename of element and insert of attribute with implicit namespace binding that clashes. :)  declare namespace nara = "http://www.anr.fr/nara"; declare namespace univ = "http://www.education.gouv.fr"; declare namespace coop = "http://www.gouv.fr/univ-industry-coop/"; declare namespace agro = "http://www.agroplus.com";  (: insert-start :) declare variable $input-context external; (: insert-end :)  rename node $input-context//nara:researcher[@name="Fred"] as fn:QName("http://www.example.com/test", "newns:researcher"), insert node attribute { fn:QName("http://www.example.com", "newns:name") } {"Hugo"} into $input-context//nara:researcher[1] ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: namespace-errors-q15 :) (: Description: Rename of element and insert of attribute with implicit namespace binding that clashes. :)  declare namespace nara = "http://www.anr.fr/nara"; declare namespace univ = "http://www.education.gouv.fr"; declare namespace coop = "http://www.gouv.fr/univ-industry-coop/"; declare namespace agro = "http://www.agroplus.com";  (: insert-start :) declare variable $input-context external; (: insert-end :)  rename node $input-context//nara:researcher[@name="Fred"] as fn:QName("http://www.example.com/test", "newns:researcher"), insert [Error is around here]node attribute { fn:QName("http://www.example.com", "newns:name") } {"Hugo"} into $input-context//nara:researcher[1]
namespace-errors-q16,Error: InvalidStateError: Namespace prefix declarations cannot be used to undeclare a namespace (use a default namespace declaration instead)
namespace-errors-q17,Error: XPST0003: Unable to parse XPath: "(: Name: namespace-errors-q17 :) (: Description: Insert new attributes with implicit namespace bindings that clash. :)  declare namespace nara = "http://www.anr.fr/nara"; declare namespace univ = "http://www.education.gouv.fr"; declare namespace coop = "http://www.gouv.fr/univ-industry-coop/"; declare namespace agro = "http://www.agroplus.com";  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert nodes     (    attribute { fn:QName("http://www.example.com", "newns:name") } { "Mavis Gertrude Smith" },    attribute { fn:QName("http://www.example.com/oops", "newns:nickname") } { "Mavis" }    ) into $input-context/grant  ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: namespace-errors-q17 :) (: Description: Insert new attributes with implicit namespace bindings that clash. :)  declare namespace nara = "http://www.anr.fr/nara"; declare namespace univ = "http://www.education.gouv.fr"; declare namespace coop = "http://www.gouv.fr/univ-industry-coop/"; declare namespace agro = "http://www.agroplus.com";  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert [Error is around here]nodes     (    attribute { fn:QName("http://www.example.com", "newns:name") } { "Mavis Gertrude Smith" },    attribute { fn:QName("http://www.example.com/oops", "newns:nickname") } { "Mavis" }    ) into $input-context/grant
namespace-errors-q18,Error: XPST0003: Unable to parse XPath: "(: Name: namespace-errors-q18 :) (: Description: Insert new attributes with implicit namespace bindings that clash. :)  declare namespace nara = "http://www.anr.fr/nara"; declare namespace univ = "http://www.education.gouv.fr"; declare namespace coop = "http://www.gouv.fr/univ-industry-coop/"; declare namespace agro = "http://www.agroplus.com";  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert nodes     (    attribute { fn:QName("http://www.example.com", "newns:name") } { "Mavis Gertrude Smith" },    attribute { fn:QName("http://www.example.com/oops", "newns:nickname") } { "Mavis" }    ) after $input-context/grant/univ:lab  ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: namespace-errors-q18 :) (: Description: Insert new attributes with implicit namespace bindings that clash. :)  declare namespace nara = "http://www.anr.fr/nara"; declare namespace univ = "http://www.education.gouv.fr"; declare namespace coop = "http://www.gouv.fr/univ-industry-coop/"; declare namespace agro = "http://www.agroplus.com";  (: insert-start :) declare variable $input-context external; (: insert-end :)  insert [Error is around here]nodes     (    attribute { fn:QName("http://www.example.com", "newns:name") } { "Mavis Gertrude Smith" },    attribute { fn:QName("http://www.example.com/oops", "newns:nickname") } { "Mavis" }    ) after $input-context/grant/univ:lab
mergeUpdates-001,Error: XPST0003: Unable to parse XPath: "(: Name: mergeUpdates-001 :) (: Description: Multiple operations that add non-conflicting namespace bindings to a node. :)  declare namespace co1="http://www.example.com/company1"; declare namespace co2="http://www.example.com/company2"; declare namespace co3="http://www.example.com/company3";  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert node attribute co1:age {30} into $var,     replace node $var/@gender with attribute co2:gender {"f"},    rename node $var as "co3:employee"    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: mergeUpdates-001 :) (: Description: Multiple operations that add non-conflicting namespace bindings to a node. :)  declare namespace co1="http://www.example.com/company1"; declare namespace co2="http://www.example.com/company2"; declare namespace co3="http://www.example.com/company3";  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert [Error is around here]node attribute co1:age {30} into $var,     replace node $var/@gender with attribute co2:gender {"f"},    rename node $var as "co3:employee"    )
mergeUpdates-002,Error: XPST0003: Unable to parse XPath: "(: Name: mergeUpdates-002 :) (: Description: Multiple operations that add conflicting namespace bindings to a node. :)  declare namespace co1="http://www.example.com/company1"; declare namespace co2="http://www.example.com/company2";  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert node attribute co1:age {30} into $var,     replace node $var/@gender with attribute co2:gender {"f"},    rename node $var as QName("http://www.example.com/company3", "co2:employee")    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: mergeUpdates-002 :) (: Description: Multiple operations that add conflicting namespace bindings to a node. :)  declare namespace co1="http://www.example.com/company1"; declare namespace co2="http://www.example.com/company2";  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert [Error is around here]node attribute co1:age {30} into $var,     replace node $var/@gender with attribute co2:gender {"f"},    rename node $var as QName("http://www.example.com/company3", "co2:employee")    )
applyUpdates-001,Error: XPST0003: Unable to parse XPath: "(: Name: applyUpdates-001 :) (: Description: insertInto then delete. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert node comment { "Testing" } into $var/hours,    delete node $var/hours/text()    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: applyUpdates-001 :) (: Description: insertInto then delete. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert [Error is around here]node comment { "Testing" } into $var/hours,    delete node $var/hours/text()    )
applyUpdates-002,Error: XPST0003: Unable to parse XPath: "(: Name: applyUpdates-002 :) (: Description: Apply insertInto then delete. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    delete node $var/hours/text(),    insert node comment { "Testing" } into $var/hours    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: applyUpdates-002 :) (: Description: Apply insertInto then delete. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    delete [Error is around here]node $var/hours/text(),    insert node comment { "Testing" } into $var/hours    )
applyUpdates-003,Error: XPST0003: Unable to parse XPath: "(: Name: applyUpdates-003 :) (: Description: Apply insertBefore then replaceNode. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert node <exempt/> before $var/hours,    replace node $var/hours with <overtime>10</overtime>    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: applyUpdates-003 :) (: Description: Apply insertBefore then replaceNode. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert [Error is around here]node <exempt/> before $var/hours,    replace node $var/hours with <overtime>10</overtime>    )
applyUpdates-004,Error: XPST0003: Unable to parse XPath: "(: Name: applyUpdates-004 :) (: Description: Apply insertBefore then replaceNode. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    replace node $var/hours with <overtime>10</overtime>,    insert node <exempt/> before $var/hours    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: applyUpdates-004 :) (: Description: Apply insertBefore then replaceNode. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    replace node $var/hours with <overtime>10</overtime>,    insert [Error is around here]node <exempt/> before $var/hours    )
applyUpdates-005,Error: XPST0003: Unable to parse XPath: "(: Name: applyUpdates-005 :) (: Description: Apply insertAsFirst then replaceElementContent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert node comment { "full week" } as first into $var/hours,    replace value of node $var/hours with "50"    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: applyUpdates-005 :) (: Description: Apply insertAsFirst then replaceElementContent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert [Error is around here]node comment { "full week" } as first into $var/hours,    replace value of node $var/hours with "50"    )
applyUpdates-006,Error: XPST0003: Unable to parse XPath: "(: Name: applyUpdates-006 :) (: Description: Apply insertAsFirst then replaceElementContent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    replace value of node $var/hours with "50",    insert node comment { "full week" } as first into $var/hours    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: applyUpdates-006 :) (: Description: Apply insertAsFirst then replaceElementContent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    replace value of node $var/hours with "50",    insert [Error is around here]node comment { "full week" } as first into $var/hours    )
applyUpdates-007,Error: XPST0003: Unable to parse XPath: "(: Name: applyUpdates-007 :) (: Description: Apply replaceNode then delete. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    replace node $var/hours with comment { "vacation" },    delete node $var/hours    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: applyUpdates-007 :) (: Description: Apply replaceNode then delete. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    replace node $var/hours with comment { "vacation" },    delete [Error is around here]node $var/hours    )
applyUpdates-008,Error: XPST0003: Unable to parse XPath: "(: Name: applyUpdates-008 :) (: Description: Apply replaceNode then delete. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    delete node $var/hours,    replace node $var/hours with comment { "vacation" }    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: applyUpdates-008 :) (: Description: Apply replaceNode then delete. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    delete [Error is around here]node $var/hours,    replace node $var/hours with comment { "vacation" }    )
applyUpdates-009,Error: XPST0003: Unable to parse XPath: "(: Name: applyUpdates-009 :) (: Description: Apply multiple operations to the same node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert node attribute overtime { "false" } into $var/hours,    insert node comment { "punctual" } into $var/hours,    insert node <employeeOfTheWeek>true</employeeOfTheWeek> before $var/hours/text(),    replace value of node $var/hours with "50",    delete node $var/hours    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: applyUpdates-009 :) (: Description: Apply multiple operations to the same node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert [Error is around here]node attribute overtime { "false" } into $var/hours,    insert node comment { "punctual" } into $var/hours,    insert node <employeeOfTheWeek>true</employeeOfTheWeek> before $var/hours/text(),    replace value of node $var/hours with "50",    delete node $var/hours    )
applyUpdates-010,Error: XPST0003: Unable to parse XPath: "(: Name: applyUpdates-010 :) (: Description: Apply multiple operations to the same node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    delete node $var/hours,    replace value of node $var/hours with "50",    insert node <employeeOfTheWeek>true</employeeOfTheWeek> before $var/hours/text(),    insert node comment { "punctual" } into $var/hours,    insert node attribute overtime { "false" } into $var/hours    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: applyUpdates-010 :) (: Description: Apply multiple operations to the same node. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    delete [Error is around here]node $var/hours,    replace value of node $var/hours with "50",    insert node <employeeOfTheWeek>true</employeeOfTheWeek> before $var/hours/text(),    insert node comment { "punctual" } into $var/hours,    insert node attribute overtime { "false" } into $var/hours    )
applyUpdates-011,Error: XPST0003: Unable to parse XPath: "(: Name: applyUpdates-011 :) (: Description: Delete elements and merge text nodes. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return    delete node $var/* ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: applyUpdates-011 :) (: Description: Delete elements and merge text nodes. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[2] return    delete [Error is around here]node $var/*
applyUpdates-012,Error: expected '<root>1</root>' to equal '<root>0</root>'
applyUpdates-013,Error: XPST0003: Unable to parse XPath: "(: Name: applyUpdates-013 :) (: Description: Insert and delete attributes with the same name. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert node attribute name {"Sylvia"} into $var,    delete node $var/@name    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: applyUpdates-013 :) (: Description: Insert and delete attributes with the same name. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert [Error is around here]node attribute name {"Sylvia"} into $var,    delete node $var/@name    )
applyUpdates-014,Error: XPST0003: Unable to parse XPath: "(: Name: applyUpdates-014 :) (: Description: Insert and delete attributes with the same name. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    delete node $var/@name,    insert node attribute name {"Sylvia"} into $var    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: applyUpdates-014 :) (: Description: Insert and delete attributes with the same name. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    delete [Error is around here]node $var/@name,    insert node attribute name {"Sylvia"} into $var    )
applyUpdates-016,Error: XPST0003: Unable to parse XPath: "(: Name: applyUpdates-016 :) (: Description: Check atomicity with a good operation and a bad operation. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert node comment {"my guy"} into $var,    insert node attribute punctual {"true"} into $var,    replace node $var/@gender with attribute punctual {"true"}    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: applyUpdates-016 :) (: Description: Check atomicity with a good operation and a bad operation. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert [Error is around here]node comment {"my guy"} into $var,    insert node attribute punctual {"true"} into $var,    replace node $var/@gender with attribute punctual {"true"}    )
applyUpdates-021,Error: XPST0003: Unable to parse XPath: "(: Name: applyUpdates-021 :) (: Description: Insert and rename attributes with the same name. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert node attribute name {"Sylvia"} into $var,    rename node $var/@name as "oldName"    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: applyUpdates-021 :) (: Description: Insert and rename attributes with the same name. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert [Error is around here]node attribute name {"Sylvia"} into $var,    rename node $var/@name as "oldName"    )
applyUpdates-022,Error: XPST0003: Unable to parse XPath: "(: Name: applyUpdates-022 :) (: Description: Insert and replace attributes with the same name. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert node attribute name {"Sylvia"} into $var,    replace node $var/@name with <e oldName="{$var/@name}"/>/@oldName    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: applyUpdates-022 :) (: Description: Insert and replace attributes with the same name. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert [Error is around here]node attribute name {"Sylvia"} into $var,    replace node $var/@name with <e oldName="{$var/@name}"/>/@oldName    )
applyUpdates-023,Error: XPST0003: Unable to parse XPath: "(: Name: applyUpdates-023 :) (: Description: Insert two attributes with the same name, delete the containing element. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert node attribute name {"Sylvia"} into $var,    insert node attribute name {"Gwynneth"} into $var,    delete node $var    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: applyUpdates-023 :) (: Description: Insert two attributes with the same name, delete the containing element. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert [Error is around here]node attribute name {"Sylvia"} into $var,    insert node attribute name {"Gwynneth"} into $var,    delete node $var    )
applyUpdates-024,Error: XPST0003: Unable to parse XPath: "(: Name: applyUpdates-024 :) (: Description: Insert two attributes with the same name, delete the containing element's parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert node attribute name {"Sylvia"} into $var/empnum,    insert node attribute name {"Gwynneth"} into $var/empnum,    delete node $var    ) ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Name: applyUpdates-024 :) (: Description: Insert two attributes with the same name, delete the containing element's parent. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $var := $input-context/works[1]/employee[1] return    (    insert [Error is around here]node attribute name {"Sylvia"} into $var/empnum,    insert node attribute name {"Gwynneth"} into $var/empnum,    delete node $var    )
applyUpdates-025,Error: XUDY0021: Applying the updates will result in the XDM instance violating constraint: 'An attribute gender already exists.'
applyUpdates-026,Error: XUDY0021: Applying the updates will result in the XDM instance violating constraint: 'An attribute gender already exists.'
setToUntyped-001,Error: XPST0003: Unable to parse XPath: "(: Name: setToUntyped-001 :) (: Description: Check that all properties are set correctly by upd:setToUntyped. :)  declare construction strip; declare default element namespace "http://ns.example.com/books2";  (: insert-start :) declare variable $input-context external; (: insert-end :)  copy $var1 := document { <test><content/></test> } modify insert node $input-context/BOOKLIST[1] into $var1/test[1]  return (        $var1/test[1]/BOOKLIST[1] instance of element(*, xs:untyped),        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1] eq "2002-12-31",        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1] instance of element(*, xs:untyped),        data($var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1]) instance of xs:untypedAtomic,        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT eq "in",        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT instance of attribute(*, xs:untypedAtomic),        empty(data($var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/LANGUAGE[1])),        $var1/test[1]/BOOKLIST[1]/BOOKS[1]//ITEM[last()]/@xml:id instance of attribute(*, xs:untypedAtomic),        empty(id("jff001", $var1/test[1])),        empty(idref("MMP", $var1/test[1])),        empty(id("MMP", $var1/test[1]))        ) ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: setToUntyped-001 :) (: Description: Check that all properties are set correctly by upd:setToUntyped. :)  declare construction strip; declare default element namespace "http://ns.example.com/books2";  (: insert-start :) declare variable $input-context external; (: insert-end :)  copy $var1 := document { <test><content/></test> } modify insert [Error is around here]node $input-context/BOOKLIST[1] into $var1/test[1]  return (        $var1/test[1]/BOOKLIST[1] instance of element(*, xs:untyped),        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1] eq "2002-12-31",        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1] instance of element(*, xs:untyped),        data($var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1]) instance of xs:untypedAtomic,        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT eq "in",        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT instance of attribute(*, xs:untypedAtomic),        empty(data($var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/LANGUAGE[1])),        $var1/test[1]/BOOKLIST[1]/BOOKS[1]//ITEM[last()]/@xml:id instance of attribute(*, xs:untypedAtomic),        empty(id("jff001", $var1/test[1])),        empty(idref("MMP", $var1/test[1])),        empty(id("MMP", $var1/test[1]))        )
setToUntyped-002,Error: XPST0003: Unable to parse XPath: "(: Name: setToUntyped-002 :) (: Description: Check that all properties are set correctly by upd:setToUntyped. :)  declare construction strip; declare default element namespace "http://ns.example.com/books2";  (: insert-start :) declare variable $input-context external; (: insert-end :)  copy $var1 := document { <test><content/></test> } modify insert node $input-context/BOOKLIST[1] as first into $var1/test[1]  return (        $var1/test[1]/BOOKLIST[1] instance of element(*, xs:untyped),        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1] eq "2002-12-31",        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1] instance of element(*, xs:untyped),        data($var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1]) instance of xs:untypedAtomic,        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT eq "in",        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT instance of attribute(*, xs:untypedAtomic),        empty(data($var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/LANGUAGE[1])),        $var1/test[1]/BOOKLIST[1]/BOOKS[1]//ITEM[last()]/@xml:id instance of attribute(*, xs:untypedAtomic),        empty(id("jff001", $var1/test[1])),        empty(idref("MMP", $var1/test[1])),        empty(id("MMP", $var1/test[1]))        ) ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: setToUntyped-002 :) (: Description: Check that all properties are set correctly by upd:setToUntyped. :)  declare construction strip; declare default element namespace "http://ns.example.com/books2";  (: insert-start :) declare variable $input-context external; (: insert-end :)  copy $var1 := document { <test><content/></test> } modify insert [Error is around here]node $input-context/BOOKLIST[1] as first into $var1/test[1]  return (        $var1/test[1]/BOOKLIST[1] instance of element(*, xs:untyped),        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1] eq "2002-12-31",        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1] instance of element(*, xs:untyped),        data($var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1]) instance of xs:untypedAtomic,        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT eq "in",        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT instance of attribute(*, xs:untypedAtomic),        empty(data($var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/LANGUAGE[1])),        $var1/test[1]/BOOKLIST[1]/BOOKS[1]//ITEM[last()]/@xml:id instance of attribute(*, xs:untypedAtomic),        empty(id("jff001", $var1/test[1])),        empty(idref("MMP", $var1/test[1])),        empty(id("MMP", $var1/test[1]))        )
setToUntyped-003,Error: XPST0003: Unable to parse XPath: "(: Name: setToUntyped-003 :) (: Description: Check that all properties are set correctly by upd:setToUntyped. :)  declare construction strip; declare default element namespace "http://ns.example.com/books2";  (: insert-start :) declare variable $input-context external; (: insert-end :)  copy $var1 := document { <test><content/></test> } modify insert node $input-context/BOOKLIST[1] as last into $var1/test[1]  return (        $var1/test[1]/BOOKLIST[1] instance of element(*, xs:untyped),        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1] eq "2002-12-31",        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1] instance of element(*, xs:untyped),        data($var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1]) instance of xs:untypedAtomic,        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT eq "in",        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT instance of attribute(*, xs:untypedAtomic),        empty(data($var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/LANGUAGE[1])),        $var1/test[1]/BOOKLIST[1]/BOOKS[1]//ITEM[last()]/@xml:id instance of attribute(*, xs:untypedAtomic),        empty(id("jff001", $var1/test[1])),        empty(idref("MMP", $var1/test[1])),        empty(id("MMP", $var1/test[1]))        ) ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: setToUntyped-003 :) (: Description: Check that all properties are set correctly by upd:setToUntyped. :)  declare construction strip; declare default element namespace "http://ns.example.com/books2";  (: insert-start :) declare variable $input-context external; (: insert-end :)  copy $var1 := document { <test><content/></test> } modify insert [Error is around here]node $input-context/BOOKLIST[1] as last into $var1/test[1]  return (        $var1/test[1]/BOOKLIST[1] instance of element(*, xs:untyped),        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1] eq "2002-12-31",        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1] instance of element(*, xs:untyped),        data($var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1]) instance of xs:untypedAtomic,        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT eq "in",        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT instance of attribute(*, xs:untypedAtomic),        empty(data($var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/LANGUAGE[1])),        $var1/test[1]/BOOKLIST[1]/BOOKS[1]//ITEM[last()]/@xml:id instance of attribute(*, xs:untypedAtomic),        empty(id("jff001", $var1/test[1])),        empty(idref("MMP", $var1/test[1])),        empty(id("MMP", $var1/test[1]))        )
setToUntyped-004,Error: XPST0003: Unable to parse XPath: "(: Name: setToUntyped-004 :) (: Description: Check that all properties are set correctly by upd:setToUntyped. :)  declare construction strip; declare default element namespace "http://ns.example.com/books2";  (: insert-start :) declare variable $input-context external; (: insert-end :)  copy $var1 := document { <test><content/></test> } modify insert node $input-context/BOOKLIST[1] before $var1/test[1]/*[1]  return (        $var1/test[1]/BOOKLIST[1] instance of element(*, xs:untyped),        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1] eq "2002-12-31",        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1] instance of element(*, xs:untyped),        data($var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1]) instance of xs:untypedAtomic,        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT eq "in",        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT instance of attribute(*, xs:untypedAtomic),        empty(data($var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/LANGUAGE[1])),        $var1/test[1]/BOOKLIST[1]/BOOKS[1]//ITEM[last()]/@xml:id instance of attribute(*, xs:untypedAtomic),        empty(id("jff001", $var1/test[1])),        empty(idref("MMP", $var1/test[1])),        empty(id("MMP", $var1/test[1]))        ) ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: setToUntyped-004 :) (: Description: Check that all properties are set correctly by upd:setToUntyped. :)  declare construction strip; declare default element namespace "http://ns.example.com/books2";  (: insert-start :) declare variable $input-context external; (: insert-end :)  copy $var1 := document { <test><content/></test> } modify insert [Error is around here]node $input-context/BOOKLIST[1] before $var1/test[1]/*[1]  return (        $var1/test[1]/BOOKLIST[1] instance of element(*, xs:untyped),        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1] eq "2002-12-31",        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1] instance of element(*, xs:untyped),        data($var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1]) instance of xs:untypedAtomic,        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT eq "in",        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT instance of attribute(*, xs:untypedAtomic),        empty(data($var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/LANGUAGE[1])),        $var1/test[1]/BOOKLIST[1]/BOOKS[1]//ITEM[last()]/@xml:id instance of attribute(*, xs:untypedAtomic),        empty(id("jff001", $var1/test[1])),        empty(idref("MMP", $var1/test[1])),        empty(id("MMP", $var1/test[1]))        )
setToUntyped-005,Error: XPST0003: Unable to parse XPath: "(: Name: setToUntyped-005 :) (: Description: Check that all properties are set correctly by upd:setToUntyped. :)  declare construction strip; declare default element namespace "http://ns.example.com/books2";  (: insert-start :) declare variable $input-context external; (: insert-end :)  copy $var1 := document { <test><content/></test> } modify insert node $input-context/BOOKLIST[1] after $var1/test[1]/*[1]  return (        $var1/test[1]/BOOKLIST[1] instance of element(*, xs:untyped),        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1] eq "2002-12-31",        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1] instance of element(*, xs:untyped),        data($var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1]) instance of xs:untypedAtomic,        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT eq "in",        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT instance of attribute(*, xs:untypedAtomic),        empty(data($var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/LANGUAGE[1])),        $var1/test[1]/BOOKLIST[1]/BOOKS[1]//ITEM[last()]/@xml:id instance of attribute(*, xs:untypedAtomic),        empty(id("jff001", $var1/test[1])),        empty(idref("MMP", $var1/test[1])),        empty(id("MMP", $var1/test[1]))        ) ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: setToUntyped-005 :) (: Description: Check that all properties are set correctly by upd:setToUntyped. :)  declare construction strip; declare default element namespace "http://ns.example.com/books2";  (: insert-start :) declare variable $input-context external; (: insert-end :)  copy $var1 := document { <test><content/></test> } modify insert [Error is around here]node $input-context/BOOKLIST[1] after $var1/test[1]/*[1]  return (        $var1/test[1]/BOOKLIST[1] instance of element(*, xs:untyped),        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1] eq "2002-12-31",        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1] instance of element(*, xs:untyped),        data($var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1]) instance of xs:untypedAtomic,        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT eq "in",        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT instance of attribute(*, xs:untypedAtomic),        empty(data($var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/LANGUAGE[1])),        $var1/test[1]/BOOKLIST[1]/BOOKS[1]//ITEM[last()]/@xml:id instance of attribute(*, xs:untypedAtomic),        empty(id("jff001", $var1/test[1])),        empty(idref("MMP", $var1/test[1])),        empty(id("MMP", $var1/test[1]))        )
setToUntyped-006,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
setToUntyped-007,Error: XPST0003: Unable to parse XPath: "(: Name: setToUntyped-007 :) (: Description: Check that all properties are set correctly by upd:setToUntyped. :)  declare construction strip; declare default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $input-context external; (: insert-end :)  copy $var1 := document { <test><content/></test> } modify insert node $input-context/BOOKLIST[1] into $var1/test[1]  return (        $var1/test[1]/BOOKLIST[1] instance of element(*, xs:untyped),        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1] eq "2002-12-31",        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1] instance of element(*, xs:untyped),        data($var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1]) instance of xs:untypedAtomic,        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT eq "in",        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT instance of attribute(*, xs:untypedAtomic),        empty(data($var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/LANGUAGE[1])),        $var1/test[1]/BOOKLIST[1]/BOOKS[1]//ITEM[last()]/@xml:id instance of attribute(*, xs:untypedAtomic),        empty(id("jff001", $var1/test[1])),        empty(idref("MMP", $var1/test[1])),        empty(id("MMP", $var1/test[1]))        ) ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: setToUntyped-007 :) (: Description: Check that all properties are set correctly by upd:setToUntyped. :)  declare construction strip; declare default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $input-context external; (: insert-end :)  copy $var1 := document { <test><content/></test> } modify insert [Error is around here]node $input-context/BOOKLIST[1] into $var1/test[1]  return (        $var1/test[1]/BOOKLIST[1] instance of element(*, xs:untyped),        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1] eq "2002-12-31",        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1] instance of element(*, xs:untyped),        data($var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/PUB-DATE[1]) instance of xs:untypedAtomic,        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT eq "in",        $var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT instance of attribute(*, xs:untypedAtomic),        empty(data($var1/test[1]/BOOKLIST[1]/BOOKS[1]/ITEM[1]/LANGUAGE[1])),        $var1/test[1]/BOOKLIST[1]/BOOKS[1]//ITEM[last()]/@xml:id instance of attribute(*, xs:untypedAtomic),        empty(id("jff001", $var1/test[1])),        empty(idref("MMP", $var1/test[1])),        empty(id("MMP", $var1/test[1]))        )
setToUntyped-008,Error: XPST0003: Unable to parse XPath: "(: Name: setToUntyped-008 :) (: Description: Check that all properties are set correctly by upd:setToUntyped. :)  declare construction strip; declare default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $input-context external; (: insert-end :)  copy $var1 := document { <test><content/></test> } modify insert node $input-context/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT into $var1/test[1] return (        $var1/test[1]/@UNIT instance of attribute(*, xs:untypedAtomic),        $var1/test[1]/@UNIT eq "in"        ) ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: setToUntyped-008 :) (: Description: Check that all properties are set correctly by upd:setToUntyped. :)  declare construction strip; declare default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $input-context external; (: insert-end :)  copy $var1 := document { <test><content/></test> } modify insert [Error is around here]node $input-context/BOOKLIST[1]/BOOKS[1]/ITEM[1]/DIMENSIONS[1]/@UNIT into $var1/test[1] return (        $var1/test[1]/@UNIT instance of attribute(*, xs:untypedAtomic),        $var1/test[1]/@UNIT eq "in"        )
setToUntyped-009,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
setToUntyped-010,Error: Not implemented: only module imports, namespace declarations, and function declarations are implemented in XQuery modules
propagateNamespaces01,Error: XPST0003: Unable to parse XPath: "declare copy-namespaces preserve, inherit; declare boundary-space preserve;  copy $data := <v xmlns:a="a-one" xmlns:b="b-one"/> modify    insert node        <w>         <x xmlns:a="a-two">           <y xmlns:b="b-two"><z/></y>         </x>       </w>   into $data return     let $w := $data/w    let $x := $w/x    let $y := $x/y    let $z := $y/z    return <result>   <w>{namespace-uri-for-prefix("a", $w), namespace-uri-for-prefix("b",$w)}</w>   <x>{namespace-uri-for-prefix("a", $x), namespace-uri-for-prefix("b",$x)}</x>   <y>{namespace-uri-for-prefix("a", $y), namespace-uri-for-prefix("b",$y)}</y>   <z>{namespace-uri-for-prefix("a", $z), namespace-uri-for-prefix("b",$z)}</z> </result>  ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. declare copy-namespaces preserve, inherit; declare boundary-space preserve;  copy $data := <v xmlns:a="a-one" xmlns:b="b-one"/> modify    insert [Error is around here]node        <w>         <x xmlns:a="a-two">           <y xmlns:b="b-two"><z/></y>         </x>       </w>   into $data return     let $w := $data/w    let $x := $w/x    let $y := $x/y    let $z := $y/z    return <result>   <w>{namespace-uri-for-prefix("a", $w), namespace-uri-for-prefix("b",$w)}</w>   <x>{namespace-uri-for-prefix("a", $x), namespace-uri-for-prefix("b",$x)}</x>   <y>{namespace-uri-for-prefix("a", $y), namespace-uri-for-prefix("b",$y)}</y>   <z>{namespace-uri-for-prefix("a", $z), namespace-uri-for-prefix("b",$z)}</z> </result>
propagateNamespaces02,Error: XPST0003: Unable to parse XPath: "declare copy-namespaces preserve, no-inherit; declare boundary-space preserve;  copy $data := <v xmlns:a="a-one" xmlns:b="b-one"/> modify    insert node        <w>         <x xmlns:a="a-two">           <y xmlns:b="b-two"><z/></y>         </x>       </w>   into $data return     let $w := $data/w    let $x := $w/x    let $y := $x/y    let $z := $y/z    return <result>   <w>{namespace-uri-for-prefix("a", $w), namespace-uri-for-prefix("b",$w)}</w>   <x>{namespace-uri-for-prefix("a", $x), namespace-uri-for-prefix("b",$x)}</x>   <y>{namespace-uri-for-prefix("a", $y), namespace-uri-for-prefix("b",$y)}</y>   <z>{namespace-uri-for-prefix("a", $z), namespace-uri-for-prefix("b",$z)}</z> </result>  ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. declare copy-namespaces preserve, no-inherit; declare boundary-space preserve;  copy $data := <v xmlns:a="a-one" xmlns:b="b-one"/> modify    insert [Error is around here]node        <w>         <x xmlns:a="a-two">           <y xmlns:b="b-two"><z/></y>         </x>       </w>   into $data return     let $w := $data/w    let $x := $w/x    let $y := $x/y    let $z := $y/z    return <result>   <w>{namespace-uri-for-prefix("a", $w), namespace-uri-for-prefix("b",$w)}</w>   <x>{namespace-uri-for-prefix("a", $x), namespace-uri-for-prefix("b",$x)}</x>   <y>{namespace-uri-for-prefix("a", $y), namespace-uri-for-prefix("b",$y)}</y>   <z>{namespace-uri-for-prefix("a", $z), namespace-uri-for-prefix("b",$z)}</z> </result>
propagateNamespaces03,Error: XPST0003: Unable to parse XPath: "declare copy-namespaces no-preserve, inherit; declare boundary-space preserve;  copy $data := <v xmlns:a="a-one" xmlns:b="b-one"/> modify    insert node        <w>         <x xmlns:a="a-two">           <y xmlns:b="b-two"><z/></y>         </x>       </w>   into $data return     let $w := $data/w    let $x := $w/x    let $y := $x/y    let $z := $y/z    return <result>   <w>{namespace-uri-for-prefix("a", $w), namespace-uri-for-prefix("b",$w)}</w>   <x>{namespace-uri-for-prefix("a", $x), namespace-uri-for-prefix("b",$x)}</x>   <y>{namespace-uri-for-prefix("a", $y), namespace-uri-for-prefix("b",$y)}</y>   <z>{namespace-uri-for-prefix("a", $z), namespace-uri-for-prefix("b",$z)}</z> </result>  ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. declare copy-namespaces no-preserve, inherit; declare boundary-space preserve;  copy $data := <v xmlns:a="a-one" xmlns:b="b-one"/> modify    insert [Error is around here]node        <w>         <x xmlns:a="a-two">           <y xmlns:b="b-two"><z/></y>         </x>       </w>   into $data return     let $w := $data/w    let $x := $w/x    let $y := $x/y    let $z := $y/z    return <result>   <w>{namespace-uri-for-prefix("a", $w), namespace-uri-for-prefix("b",$w)}</w>   <x>{namespace-uri-for-prefix("a", $x), namespace-uri-for-prefix("b",$x)}</x>   <y>{namespace-uri-for-prefix("a", $y), namespace-uri-for-prefix("b",$y)}</y>   <z>{namespace-uri-for-prefix("a", $z), namespace-uri-for-prefix("b",$z)}</z> </result>
propagateNamespaces04,Error: XPST0003: Unable to parse XPath: "declare copy-namespaces no-preserve, no-inherit; declare boundary-space preserve;  copy $data := <v xmlns:a="a-one" xmlns:b="b-one"/> modify    insert node        <w>         <x xmlns:a="a-two">           <y xmlns:b="b-two"><z/></y>         </x>       </w>   into $data return     let $w := $data/w    let $x := $w/x    let $y := $x/y    let $z := $y/z    return <result>   <w>{namespace-uri-for-prefix("a", $w), namespace-uri-for-prefix("b",$w)}</w>   <x>{namespace-uri-for-prefix("a", $x), namespace-uri-for-prefix("b",$x)}</x>   <y>{namespace-uri-for-prefix("a", $y), namespace-uri-for-prefix("b",$y)}</y>   <z>{namespace-uri-for-prefix("a", $z), namespace-uri-for-prefix("b",$z)}</z> </result>  ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. declare copy-namespaces no-preserve, no-inherit; declare boundary-space preserve;  copy $data := <v xmlns:a="a-one" xmlns:b="b-one"/> modify    insert [Error is around here]node        <w>         <x xmlns:a="a-two">           <y xmlns:b="b-two"><z/></y>         </x>       </w>   into $data return     let $w := $data/w    let $x := $w/x    let $y := $x/y    let $z := $y/z    return <result>   <w>{namespace-uri-for-prefix("a", $w), namespace-uri-for-prefix("b",$w)}</w>   <x>{namespace-uri-for-prefix("a", $x), namespace-uri-for-prefix("b",$x)}</x>   <y>{namespace-uri-for-prefix("a", $y), namespace-uri-for-prefix("b",$y)}</y>   <z>{namespace-uri-for-prefix("a", $z), namespace-uri-for-prefix("b",$z)}</z> </result>
propagateNamespaces05,Error: XPST0003: Unable to parse XPath: "declare copy-namespaces preserve, inherit; declare boundary-space preserve;  declare default element namespace "http://example.org";  copy $x := <x xmlns="foo" xmlns:a="a-ns"/> modify    insert node <y/> into $x return <result>   <x>{namespace-uri-for-prefix("", $x), namespace-uri-for-prefix("a", $x)}</x>   <y>{namespace-uri-for-prefix("", $x/y), namespace-uri-for-prefix("a", $x/y)}</y> </result>". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. declare copy-namespaces preserve, inherit; declare boundary-space preserve;  declare default element namespace "http://example.org";  copy $x := <x xmlns="foo" xmlns:a="a-ns"/> modify    insert [Error is around here]node <y/> into $x return <result>   <x>{namespace-uri-for-prefix("", $x), namespace-uri-for-prefix("a", $x)}</x>   <y>{namespace-uri-for-prefix("", $x/y), namespace-uri-for-prefix("a", $x/y)}</y> </result>
propagateNamespaces06,Error: XPST0003: Unable to parse XPath: "declare copy-namespaces preserve, no-inherit; declare boundary-space preserve;  declare default element namespace "http://example.org";  copy $x := <x xmlns="foo" xmlns:a="a-ns"/> modify    insert node <y/> into $x return <result>   <x>{namespace-uri-for-prefix("", $x), namespace-uri-for-prefix("a", $x)}</x>   <y>{namespace-uri-for-prefix("", $x/y), namespace-uri-for-prefix("a", $x/y)}</y> </result>". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. declare copy-namespaces preserve, no-inherit; declare boundary-space preserve;  declare default element namespace "http://example.org";  copy $x := <x xmlns="foo" xmlns:a="a-ns"/> modify    insert [Error is around here]node <y/> into $x return <result>   <x>{namespace-uri-for-prefix("", $x), namespace-uri-for-prefix("a", $x)}</x>   <y>{namespace-uri-for-prefix("", $x/y), namespace-uri-for-prefix("a", $x/y)}</y> </result>
statictyp-xqupd-01,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-1 :) (: Description: Evaluation of static typing feature with delete expression. :) (: XUTY0007 :)  delete node 1 ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-1 :) (: Description: Evaluation of static typing feature with delete expression. :) (: XUTY0007 :)  delete [Error is around here]node 1
statictyp-xqupd-02,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-2 :) (: Description: Evaluation of static typing feature with delete expression. :) (: XUTY0007 :)  delete node (1,"abc") ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-2 :) (: Description: Evaluation of static typing feature with delete expression. :) (: XUTY0007 :)  delete [Error is around here]node (1,"abc")
statictyp-xqupd-03,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-3 :) (: Description: Evaluation of static typing feature with insert into expression. :) (: XUTY0005 :)  insert node <b/> into (<a/>, <a/>) ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-3 :) (: Description: Evaluation of static typing feature with insert into expression. :) (: XUTY0005 :)  insert [Error is around here]node <b/> into (<a/>, <a/>)
statictyp-xqupd-04,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-4 :) (: Description: Evaluation of static typing feature with insert into expression. :) (: XUTY0005 :)  insert node <a/> into <!-- this is comment node--> ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-4 :) (: Description: Evaluation of static typing feature with insert into expression. :) (: XUTY0005 :)  insert [Error is around here]node <a/> into <!-- this is comment node-->
statictyp-xqupd-05,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-5 :) (: Description: Evaluation of static typing feature with insert into expression. :) (: XUTY0005 :)  insert node <a/> into text {45} ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-5 :) (: Description: Evaluation of static typing feature with insert into expression. :) (: XUTY0005 :)  insert [Error is around here]node <a/> into text {45}
statictyp-xqupd-06,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-6 :) (: Description: Evaluation of static typing feature with insert into expression. :) (: XUTY0005 :)  insert node <a/> into attribute size {7} ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-6 :) (: Description: Evaluation of static typing feature with insert into expression. :) (: XUTY0005 :)  insert [Error is around here]node <a/> into attribute size {7}
statictyp-xqupd-07,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-7 :) (: Description: Evaluation of static typing feature with insert into expression. :) (: XUTY0005 :)  insert node <a/> into processing-instruction {"foo"} {"bar"} ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-7 :) (: Description: Evaluation of static typing feature with insert into expression. :) (: XUTY0005 :)  insert [Error is around here]node <a/> into processing-instruction {"foo"} {"bar"}
statictyp-xqupd-08,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-8 :) (: Description: Evaluation of static typing feature with insert into expression. :) (: XUTY0005 :)  insert node <a/> into 56 ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-8 :) (: Description: Evaluation of static typing feature with insert into expression. :) (: XUTY0005 :)  insert [Error is around here]node <a/> into 56
statictyp-xqupd-09,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-9 :) (: Description: Evaluation of static typing feature with insert into expression. :) (: XUTY0022 :)  insert node attribute size {7} into document {<a/>} ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-9 :) (: Description: Evaluation of static typing feature with insert into expression. :) (: XUTY0022 :)  insert [Error is around here]node attribute size {7} into document {<a/>}
statictyp-xqupd-10,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-10 :) (: Description: Evaluation of static typing feature with insert before expression. :) (: XUTY0006 :)  insert node attribute size {7} before document {<a/>} ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-10 :) (: Description: Evaluation of static typing feature with insert before expression. :) (: XUTY0006 :)  insert [Error is around here]node attribute size {7} before document {<a/>}
statictyp-xqupd-11,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-11 :) (: Description: Evaluation of static typing feature with insert before expression. :) (: XUTY0006 :)  insert node attribute size {7} before attribute sizet {8} ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-11 :) (: Description: Evaluation of static typing feature with insert before expression. :) (: XUTY0006 :)  insert [Error is around here]node attribute size {7} before attribute sizet {8}
statictyp-xqupd-12,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-12 :) (: Description: Evaluation of static typing feature with insert before expression. :) (: XUTY0006 :)  insert node attribute size {7} before 4 ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-12 :) (: Description: Evaluation of static typing feature with insert before expression. :) (: XUTY0006 :)  insert [Error is around here]node attribute size {7} before 4
statictyp-xqupd-13,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-13 :) (: Description: Evaluation of static typing feature with insert before expression. :) (: XUTY0006 :)  insert node attribute size {7} before (<a/>, <a/>) ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-13 :) (: Description: Evaluation of static typing feature with insert before expression. :) (: XUTY0006 :)  insert [Error is around here]node attribute size {7} before (<a/>, <a/>)
statictyp-xqupd-14,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-14 :) (: Description: Evaluation of static typing feature with insert before expression. :) (: XUTY0006 :)  insert node attribute size {7} before (<!-- comment1 -->, <!-- comment2 -->) ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-14 :) (: Description: Evaluation of static typing feature with insert before expression. :) (: XUTY0006 :)  insert [Error is around here]node attribute size {7} before (<!-- comment1 -->, <!-- comment2 -->)
statictyp-xqupd-15,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-15 :) (: Description: Evaluation of static typing feature with insert before expression. :) (: XUTY0006 :)  insert node attribute size {7} before (processing-instruction {"foo"} {"bar"}, processing-instruction {"foo"} {"bar"})  ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-15 :) (: Description: Evaluation of static typing feature with insert before expression. :) (: XUTY0006 :)  insert [Error is around here]node attribute size {7} before (processing-instruction {"foo"} {"bar"}, processing-instruction {"foo"} {"bar"})
statictyp-xqupd-16,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-16 :) (: Description: Evaluation of static typing feature with insert before expression. :) (: XUTY0006 :)  insert node attribute size {7} before (text {3}, text {4}) ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-16 :) (: Description: Evaluation of static typing feature with insert before expression. :) (: XUTY0006 :)  insert [Error is around here]node attribute size {7} before (text {3}, text {4})
statictyp-xqupd-17,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-17 :) (: Description: Evaluation of static typing feature with insert after expression. :) (: XUTY0006 :)  insert node attribute size {7} after document {<a/>} ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-17 :) (: Description: Evaluation of static typing feature with insert after expression. :) (: XUTY0006 :)  insert [Error is around here]node attribute size {7} after document {<a/>}
statictyp-xqupd-18,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-18 :) (: Description: Evaluation of static typing feature with insert after expression. :) (: XUTY0006 :)  insert node attribute size {7} after document {<a/>} ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-18 :) (: Description: Evaluation of static typing feature with insert after expression. :) (: XUTY0006 :)  insert [Error is around here]node attribute size {7} after document {<a/>}
statictyp-xqupd-19,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-19 :) (: Description: Evaluation of static typing feature with insert after expression. :) (: XUTY0006 :)  insert node attribute size {7} after attribute sizet {8} ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-19 :) (: Description: Evaluation of static typing feature with insert after expression. :) (: XUTY0006 :)  insert [Error is around here]node attribute size {7} after attribute sizet {8}
statictyp-xqupd-20,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-20 :) (: Description: Evaluation of static typing feature with insert after expression. :) (: XUTY0006 :)  insert node attribute size {7} after 4 ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-20 :) (: Description: Evaluation of static typing feature with insert after expression. :) (: XUTY0006 :)  insert [Error is around here]node attribute size {7} after 4
statictyp-xqupd-21,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-21 :) (: Description: Evaluation of static typing feature with insert after expression. :) (: XUTY0006 :)  insert node attribute size {7} before (<a/>, <a/>) ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-21 :) (: Description: Evaluation of static typing feature with insert after expression. :) (: XUTY0006 :)  insert [Error is around here]node attribute size {7} before (<a/>, <a/>)
statictyp-xqupd-22,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-22 :) (: Description: Evaluation of static typing feature with insert after expression. :) (: XUTY0006 :)  insert node attribute size {7} after (<!-- comment1 -->, <!-- comment2 -->) ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-22 :) (: Description: Evaluation of static typing feature with insert after expression. :) (: XUTY0006 :)  insert [Error is around here]node attribute size {7} after (<!-- comment1 -->, <!-- comment2 -->)
statictyp-xqupd-23,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-23 :) (: Description: Evaluation of static typing feature with insert after expression. :) (: XUTY0006 :)  insert node attribute size {7} after (processing-instruction {"foo"} {"bar"}, processing-instruction {"foo"} {"bar"})  ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-23 :) (: Description: Evaluation of static typing feature with insert after expression. :) (: XUTY0006 :)  insert [Error is around here]node attribute size {7} after (processing-instruction {"foo"} {"bar"}, processing-instruction {"foo"} {"bar"})
statictyp-xqupd-24,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-24 :) (: Description: Evaluation of static typing feature with insert after expression. :) (: XUTY0006 :)  insert node attribute size {7} after (text {3}, text {4}) ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-24 :) (: Description: Evaluation of static typing feature with insert after expression. :) (: XUTY0006 :)  insert [Error is around here]node attribute size {7} after (text {3}, text {4})
statictyp-xqupd-25,Error: XPST0003: Unable to parse XPath: "(: Name: statictyp-xqupd-25 :) (: Description: Evaluation of static typing feature with insert into expression. :) (: XUTY0022 :)  insert node attribute size {7} into document {<a/>} ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: statictyp-xqupd-25 :) (: Description: Evaluation of static typing feature with insert into expression. :) (: XUTY0022 :)  insert [Error is around here]node attribute size {7} into document {<a/>}
statictyp-xqupd-26,Error: Should throw error XUTY0008.: expected 'No selector counterpart for: computedDocumentConstructor.' to equal 'XUTY0008'
statictyp-xqupd-27,Error: Should throw error XUTY0010.: expected 'No selector counterpart for: computedTextConstructor.' to equal 'XUTY0010'
statictyp-xqupd-32,Error: Should throw error XUTY0010.: expected 'No selector counterpart for: computedTextConstructor.' to equal 'XUTY0010'
statictyp-xqupd-36,Error: Should throw error XUTY0010.: expected 'No selector counterpart for: computedTextConstructor.' to equal 'XUTY0010'
statictyp-xqupd-43,Error: Should throw error XUTY0011.: expected 'No selector counterpart for: computedTextConstructor.' to equal 'XUTY0011'
statictyp-xqupd-49,Error: Should throw error XUTY0008.: expected 'No selector counterpart for: computedTextConstructor.' to equal 'XUTY0008'
statictyp-xqupd-50,Error: Should throw error XUTY0008.: expected 'No selector counterpart for: computedDocumentConstructor.' to equal 'XUTY0008'
statictyp-xqupd-51,Error: Should throw error XUTY0012.: expected 'No selector counterpart for: computedTextConstructor.' to equal 'XUTY0012'
update10keywords,Error: Not implemented: Intermediate clauses in flwor expressions are not implemented yet
revalidation-declaration-01,Error: XPST0003: Unable to parse XPath: "(: Name: revalidation-declaration-01 :) (: Description: One declare validation specifying strict :)  declare revalidation strict;  (: insert-start :) declare variable $input-context external; (: insert-end :)  12 ". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: revalidation-declaration-01 :) (: Description: One declare validation specifying strict :)  declare [Error is around here]revalidation strict;  (: insert-start :) declare variable $input-context external; (: insert-end :)  12
revalidation-declaration-02,Error: XPST0003: Unable to parse XPath: "(: Name: revalidation-declaration-02 :) (: Description: Two declare validation specifying strict :)  declare revalidation strict; declare revalidation strict;  (: insert-start :) declare variable $input-context external; (: insert-end :)  12 ". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: revalidation-declaration-02 :) (: Description: Two declare validation specifying strict :)  declare [Error is around here]revalidation strict; declare revalidation strict;  (: insert-start :) declare variable $input-context external; (: insert-end :)  12
revalidate-valstrict-del-001,Error: XPST0003: Unable to parse XPath: "(: Name: valstrict-del-001 :) (: Description: deleting a mandatory element is bad news :)  declare construction strip; declare revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   delete node ($books//AUTHOR)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valstrict-del-001 :) (: Description: deleting a mandatory element is bad news :)  declare construction strip; declare [Error is around here]revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   delete node ($books//AUTHOR)[1]
revalidate-valstrict-del-002,Error: XPST0003: Unable to parse XPath: "(: Name: valstrict-del-002 :) (: Description: deleting an optional element is perfectly OK :)  declare construction strip; declare revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   delete node ($books//PRICE)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valstrict-del-002 :) (: Description: deleting an optional element is perfectly OK :)  declare construction strip; declare [Error is around here]revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   delete node ($books//PRICE)[1]
revalidate-valstrict-del-003,Error: XPST0003: Unable to parse XPath: "(: Name: valstrict-del-003 :) (: Description: deleting a mandatory attribute is bad news :)  declare construction strip; declare revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   delete node ($books//ITEM[1]/@CAT)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valstrict-del-003 :) (: Description: deleting a mandatory attribute is bad news :)  declare construction strip; declare [Error is around here]revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   delete node ($books//ITEM[1]/@CAT)[1]
revalidate-valstrict-del-004,Error: XPST0003: Unable to parse XPath: "(: Name: valstrict-del-004 :) (: Description: deleting an optional attribute is fine :)  declare construction strip; declare revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   delete node ($books//ITEM/@TAX)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valstrict-del-004 :) (: Description: deleting an optional attribute is fine :)  declare construction strip; declare [Error is around here]revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   delete node ($books//ITEM/@TAX)[1]
revalidate-valstrict-ins-001,Error: XPST0003: Unable to parse XPath: "(: Name: valstrict-ins-001 :) (: Description: inserting a disallowed element is bad news :)  declare construction strip; declare revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <garbage>rubbish</garbage> as first into ($books/BOOKLIST/BOOKS/ITEM)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valstrict-ins-001 :) (: Description: inserting a disallowed element is bad news :)  declare construction strip; declare [Error is around here]revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <garbage>rubbish</garbage> as first into ($books/BOOKLIST/BOOKS/ITEM)[1]
revalidate-valstrict-ins-002,Error: XPST0003: Unable to parse XPath: "(: Name: valstrict-ins-002 :) (: Description: inserting a element that exceeds maxOccurs is bad news :)  declare construction strip; declare revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <TITLE xmlns="http://ns.example.com/books">rubbish</TITLE> as first into ($books/BOOKLIST/BOOKS/ITEM)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valstrict-ins-002 :) (: Description: inserting a element that exceeds maxOccurs is bad news :)  declare construction strip; declare [Error is around here]revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <TITLE xmlns="http://ns.example.com/books">rubbish</TITLE> as first into ($books/BOOKLIST/BOOKS/ITEM)[1]
revalidate-valstrict-ins-003,Error: XPST0003: Unable to parse XPath: "(: Name: valstrict-ins-003 :) (: Description: inserting a second AUTHOR is OK :)  declare construction strip; declare revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <AUTHOR xmlns="http://ns.example.com/books">Thursday Next</AUTHOR> after ($books/BOOKLIST/BOOKS/ITEM/AUTHOR)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valstrict-ins-003 :) (: Description: inserting a second AUTHOR is OK :)  declare construction strip; declare [Error is around here]revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <AUTHOR xmlns="http://ns.example.com/books">Thursday Next</AUTHOR> after ($books/BOOKLIST/BOOKS/ITEM/AUTHOR)[1]
revalidate-valstrict-ins-004,Error: XPST0003: Unable to parse XPath: "(: Name: valstrict-ins-004 :) (: Description: inserting a disallowed attribute is bad news :)  declare construction strip; declare revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <garbage trash="waste">rubbish</garbage>/@* as first into ($books/BOOKLIST/BOOKS/ITEM)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valstrict-ins-004 :) (: Description: inserting a disallowed attribute is bad news :)  declare construction strip; declare [Error is around here]revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <garbage trash="waste">rubbish</garbage>/@* as first into ($books/BOOKLIST/BOOKS/ITEM)[1]
revalidate-valstrict-ins-005,Error: XPST0003: Unable to parse XPath: "(: Name: valstrict-ins-005 :) (: Description: inserting an allowed attribute is fine :)  declare construction strip; declare revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <garbage xml:id="waste">rubbish</garbage>/@* as first into ($books/BOOKLIST/BOOKS/ITEM)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valstrict-ins-005 :) (: Description: inserting an allowed attribute is fine :)  declare construction strip; declare [Error is around here]revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <garbage xml:id="waste">rubbish</garbage>/@* as first into ($books/BOOKLIST/BOOKS/ITEM)[1]
revalidate-valstrict-ins-006,Error: XPST0003: Unable to parse XPath: "(: Name: valstrict-ins-006 :) (: Description: inserting an xml:id doesn't work unless it's unique :)  declare construction strip; declare revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <garbage xml:id="jff001">rubbish</garbage>/@* as first into ($books/BOOKLIST/BOOKS/ITEM)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valstrict-ins-006 :) (: Description: inserting an xml:id doesn't work unless it's unique :)  declare construction strip; declare [Error is around here]revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <garbage xml:id="jff001">rubbish</garbage>/@* as first into ($books/BOOKLIST/BOOKS/ITEM)[1]
revalidate-valstrict-ins-007,Error: XPST0003: Unable to parse XPath: "(: Name: valstrict-ins-007 :) (: Description: inserting a duplicate xml:id is fine if we get rid of the old one :)  declare construction strip; declare revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <garbage xml:id="jff001">rubbish</garbage>/@* as first into ($books/BOOKLIST/BOOKS/ITEM)[1], replace value of node id('jff001', $books)/@xml:id with "jff002"". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valstrict-ins-007 :) (: Description: inserting a duplicate xml:id is fine if we get rid of the old one :)  declare construction strip; declare [Error is around here]revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <garbage xml:id="jff001">rubbish</garbage>/@* as first into ($books/BOOKLIST/BOOKS/ITEM)[1], replace value of node id('jff001', $books)/@xml:id with "jff002"
revalidate-valstrict-ren-001,Error: XPST0003: Unable to parse XPath: "(: Name: valstrict-ren-001 :) (: Description: renaming an element is bad news if the new name is not allowed :)  declare construction strip; declare revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   rename node ($books//AUTHOR)[1] as "WRITER"". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valstrict-ren-001 :) (: Description: renaming an element is bad news if the new name is not allowed :)  declare construction strip; declare [Error is around here]revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   rename node ($books//AUTHOR)[1] as "WRITER"
revalidate-valstrict-ren-002,Error: XPST0003: Unable to parse XPath: "(: Name: valstrict-ren-002 :) (: Description: renaming an attribute is bad news if the new name is not allowed :)  declare construction strip; declare revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   rename node ($books//ITEM)[1]/@CAT as "cat"". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valstrict-ren-002 :) (: Description: renaming an attribute is bad news if the new name is not allowed :)  declare construction strip; declare [Error is around here]revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   rename node ($books//ITEM)[1]/@CAT as "cat"
revalidate-valstrict-ren-003,Error: XPST0003: Unable to parse XPath: "(: Name: valstrict-ren-003 :) (: Description: renaming an element is OK if the new name is in the substitution group :)  declare construction strip; declare revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   for $e in $books//ITEM   return rename node $e as "SUBITEM"". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valstrict-ren-003 :) (: Description: renaming an element is OK if the new name is in the substitution group :)  declare construction strip; declare [Error is around here]revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   for $e in $books//ITEM   return rename node $e as "SUBITEM"
revalidate-valstrict-repnode-001,Error: XPST0003: Unable to parse XPath: "(: Name: valstrict-repnode-001 :) (: Description: replace element fails if the new node is invalid :)  declare construction strip; declare revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   replace node ($books//AUTHOR)[1] with <WRITER>Jasper Fforde</WRITER>". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valstrict-repnode-001 :) (: Description: replace element fails if the new node is invalid :)  declare construction strip; declare [Error is around here]revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   replace node ($books//AUTHOR)[1] with <WRITER>Jasper Fforde</WRITER>
revalidate-valstrict-repnode-002,Error: XPST0003: Unable to parse XPath: "(: Name: valstrict-repnode-002 :) (: Description: replace attribute fails if the new node is invalid :)  declare construction strip; declare revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   replace node ($books//ITEM)[1]/@CAT with <A cat="mmc"/>/@cat". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valstrict-repnode-002 :) (: Description: replace attribute fails if the new node is invalid :)  declare construction strip; declare [Error is around here]revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   replace node ($books//ITEM)[1]/@CAT with <A cat="mmc"/>/@cat
revalidate-valstrict-repnode-003,Error: XPST0003: Unable to parse XPath: "(: Name: valstrict-repnode-003 :) (: Description: replace element is OK if the new node is valid :)  declare construction strip; declare revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   replace node ($books//AUTHOR)[1] with <AUTHOR>Thursday Next</AUTHOR>". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valstrict-repnode-003 :) (: Description: replace element is OK if the new node is valid :)  declare construction strip; declare [Error is around here]revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   replace node ($books//AUTHOR)[1] with <AUTHOR>Thursday Next</AUTHOR>
revalidate-valtrans-ins-001,Error: XPST0003: Unable to parse XPath: "(: Name: valstrict-ins-001 :) (: Description: inserting a disallowed element is bad news :)  declare construction strip; declare revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  let $book1 := ($books/BOOKLIST/BOOKS/ITEM)[1] return    copy $book1copy := $book1   modify insert node <garbage>rubbish</garbage> as first into $book1copy   return $book1copy       ". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valstrict-ins-001 :) (: Description: inserting a disallowed element is bad news :)  declare construction strip; declare [Error is around here]revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  let $book1 := ($books/BOOKLIST/BOOKS/ITEM)[1] return    copy $book1copy := $book1   modify insert node <garbage>rubbish</garbage> as first into $book1copy   return $book1copy
revalidate-valtrans-ins-002,Error: XPST0003: Unable to parse XPath: "(: Name: valstrict-ins-002 :) (: Description: inserting a permitted element is fine :)  declare construction strip; declare revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  let $book1 := ($books/BOOKLIST/BOOKS/ITEM)[1] return    copy $book1copy := $book1   modify insert node <AUTHOR xmlns="http://ns.example.com/books">Thursday Next</AUTHOR>                  after ($book1copy/AUTHOR)[1]    return $book1copy       ". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valstrict-ins-002 :) (: Description: inserting a permitted element is fine :)  declare construction strip; declare [Error is around here]revalidation strict; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  let $book1 := ($books/BOOKLIST/BOOKS/ITEM)[1] return    copy $book1copy := $book1   modify insert node <AUTHOR xmlns="http://ns.example.com/books">Thursday Next</AUTHOR>                  after ($book1copy/AUTHOR)[1]    return $book1copy
revalidation-declaration-01-fail,Error: XPST0003: Unable to parse XPath: "(: Name: revalidation-declaration-01 :) (: Description: One declare validation specifying strict :)  declare revalidation strict;  (: insert-start :) declare variable $input-context external; (: insert-end :)  12 ". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: revalidation-declaration-01 :) (: Description: One declare validation specifying strict :)  declare [Error is around here]revalidation strict;  (: insert-start :) declare variable $input-context external; (: insert-end :)  12
revalidation-declaration-03,Error: XPST0003: Unable to parse XPath: "(: Name: revalidation-declaration-03 :) (: Description: One declare validation specifying lax :)  declare revalidation lax;  (: insert-start :) declare variable $input-context external; (: insert-end :)  12 ". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: revalidation-declaration-03 :) (: Description: One declare validation specifying lax :)  declare [Error is around here]revalidation lax;  (: insert-start :) declare variable $input-context external; (: insert-end :)  12
revalidation-declaration-04,Error: XPST0003: Unable to parse XPath: "(: Name: revalidation-declaration-04 :) (: Description: Two declare validation specifying lax :)  declare revalidation lax; declare revalidation lax;  (: insert-start :) declare variable $input-context external; (: insert-end :)  12 ". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: revalidation-declaration-04 :) (: Description: Two declare validation specifying lax :)  declare [Error is around here]revalidation lax; declare revalidation lax;  (: insert-start :) declare variable $input-context external; (: insert-end :)  12
revalidate-vallax-del-001,Error: XPST0003: Unable to parse XPath: "(: Name: vallax-del-001 :) (: Description: deleting a mandatory element is bad news :)  declare construction strip; declare revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   delete node ($books//AUTHOR)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: vallax-del-001 :) (: Description: deleting a mandatory element is bad news :)  declare construction strip; declare [Error is around here]revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   delete node ($books//AUTHOR)[1]
revalidate-vallax-del-002,Error: XPST0003: Unable to parse XPath: "(: Name: vallax-del-002 :) (: Description: deleting an optional element is perfectly OK :)  declare construction strip; declare revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   delete node ($books//PRICE)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: vallax-del-002 :) (: Description: deleting an optional element is perfectly OK :)  declare construction strip; declare [Error is around here]revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   delete node ($books//PRICE)[1]
revalidate-vallax-del-003,Error: XPST0003: Unable to parse XPath: "(: Name: vallax-del-003 :) (: Description: deleting a mandatory attribute is bad news :)  declare construction strip; declare revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   delete node ($books//ITEM[1]/@CAT)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: vallax-del-003 :) (: Description: deleting a mandatory attribute is bad news :)  declare construction strip; declare [Error is around here]revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   delete node ($books//ITEM[1]/@CAT)[1]
revalidate-vallax-del-004,Error: XPST0003: Unable to parse XPath: "(: Name: vallax-del-004 :) (: Description: deleting an optional attribute is fine :)  declare construction strip; declare revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   delete node ($books//ITEM/@TAX)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: vallax-del-004 :) (: Description: deleting an optional attribute is fine :)  declare construction strip; declare [Error is around here]revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   delete node ($books//ITEM/@TAX)[1]
revalidate-vallax-ins-001,Error: XPST0003: Unable to parse XPath: "(: Name: vallax-ins-001 :) (: Description: inserting a disallowed element is bad news :)  declare construction strip; declare revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <garbage>rubbish</garbage> as first into ($books/BOOKLIST/BOOKS/ITEM)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: vallax-ins-001 :) (: Description: inserting a disallowed element is bad news :)  declare construction strip; declare [Error is around here]revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <garbage>rubbish</garbage> as first into ($books/BOOKLIST/BOOKS/ITEM)[1]
revalidate-vallax-ins-002,Error: XPST0003: Unable to parse XPath: "(: Name: vallax-ins-002 :) (: Description: inserting a element that exceeds maxOccurs is bad news :)  declare construction strip; declare revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <TITLE xmlns="http://ns.example.com/books">rubbish</TITLE> as first into ($books/BOOKLIST/BOOKS/ITEM)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: vallax-ins-002 :) (: Description: inserting a element that exceeds maxOccurs is bad news :)  declare construction strip; declare [Error is around here]revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <TITLE xmlns="http://ns.example.com/books">rubbish</TITLE> as first into ($books/BOOKLIST/BOOKS/ITEM)[1]
revalidate-vallax-ins-003,Error: XPST0003: Unable to parse XPath: "(: Name: vallax-ins-003 :) (: Description: inserting a second AUTHOR is OK :)  declare construction strip; declare revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <AUTHOR xmlns="http://ns.example.com/books">Thursday Next</AUTHOR> after ($books/BOOKLIST/BOOKS/ITEM/AUTHOR)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: vallax-ins-003 :) (: Description: inserting a second AUTHOR is OK :)  declare construction strip; declare [Error is around here]revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <AUTHOR xmlns="http://ns.example.com/books">Thursday Next</AUTHOR> after ($books/BOOKLIST/BOOKS/ITEM/AUTHOR)[1]
revalidate-vallax-ins-004,Error: XPST0003: Unable to parse XPath: "(: Name: vallax-ins-004 :) (: Description: inserting a disallowed attribute is bad news :)  declare construction strip; declare revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <garbage trash="waste">rubbish</garbage>/@* as first into ($books/BOOKLIST/BOOKS/ITEM)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: vallax-ins-004 :) (: Description: inserting a disallowed attribute is bad news :)  declare construction strip; declare [Error is around here]revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <garbage trash="waste">rubbish</garbage>/@* as first into ($books/BOOKLIST/BOOKS/ITEM)[1]
revalidate-vallax-ins-005,Error: XPST0003: Unable to parse XPath: "(: Name: vallax-ins-005 :) (: Description: inserting an allowed attribute is fine :)  declare construction strip; declare revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <garbage xml:id="waste">rubbish</garbage>/@* as first into ($books/BOOKLIST/BOOKS/ITEM)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: vallax-ins-005 :) (: Description: inserting an allowed attribute is fine :)  declare construction strip; declare [Error is around here]revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <garbage xml:id="waste">rubbish</garbage>/@* as first into ($books/BOOKLIST/BOOKS/ITEM)[1]
revalidate-vallax-ins-006,Error: XPST0003: Unable to parse XPath: "(: Name: vallax-ins-006 :) (: Description: inserting an xml:id doesn't work unless it's unique :)  declare construction strip; declare revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <garbage xml:id="jff001">rubbish</garbage>/@* as first into ($books/BOOKLIST/BOOKS/ITEM)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: vallax-ins-006 :) (: Description: inserting an xml:id doesn't work unless it's unique :)  declare construction strip; declare [Error is around here]revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <garbage xml:id="jff001">rubbish</garbage>/@* as first into ($books/BOOKLIST/BOOKS/ITEM)[1]
revalidate-vallax-ins-007,Error: XPST0003: Unable to parse XPath: "(: Name: vallax-ins-007 :) (: Description: inserting a duplicate xml:id is fine if we get rid of the old one :)  declare construction strip; declare revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <garbage xml:id="jff001">rubbish</garbage>/@* as first into ($books/BOOKLIST/BOOKS/ITEM)[1], replace value of node id('jff001', $books)/@xml:id with "jff002"". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: vallax-ins-007 :) (: Description: inserting a duplicate xml:id is fine if we get rid of the old one :)  declare construction strip; declare [Error is around here]revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <garbage xml:id="jff001">rubbish</garbage>/@* as first into ($books/BOOKLIST/BOOKS/ITEM)[1], replace value of node id('jff001', $books)/@xml:id with "jff002"
revalidate-vallax-ren-001,Error: XPST0003: Unable to parse XPath: "(: Name: vallax-ren-001 :) (: Description: renaming an element is bad news if the new name is not allowed :)  declare construction strip; declare revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   rename node ($books//AUTHOR)[1] as "WRITER"". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: vallax-ren-001 :) (: Description: renaming an element is bad news if the new name is not allowed :)  declare construction strip; declare [Error is around here]revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   rename node ($books//AUTHOR)[1] as "WRITER"
revalidate-vallax-ren-002,Error: XPST0003: Unable to parse XPath: "(: Name: vallax-ren-002 :) (: Description: renaming an attribute is bad news if the new name is not allowed :)  declare construction strip; declare revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   rename node ($books//ITEM)[1]/@CAT as "cat"". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: vallax-ren-002 :) (: Description: renaming an attribute is bad news if the new name is not allowed :)  declare construction strip; declare [Error is around here]revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   rename node ($books//ITEM)[1]/@CAT as "cat"
revalidate-vallax-ren-003,Error: XPST0003: Unable to parse XPath: "(: Name: vallax-ren-003 :) (: Description: renaming an element is OK if the new name is in the substitution group :)  declare construction strip; declare revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   for $e in $books//ITEM   return rename node $e as "SUBITEM"". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: vallax-ren-003 :) (: Description: renaming an element is OK if the new name is in the substitution group :)  declare construction strip; declare [Error is around here]revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   for $e in $books//ITEM   return rename node $e as "SUBITEM"
revalidate-vallax-repnode-001,Error: XPST0003: Unable to parse XPath: "(: Name: vallax-repnode-001 :) (: Description: replace element fails if the new node is invalid :)  declare construction strip; declare revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   replace node ($books//AUTHOR)[1] with <WRITER>Jasper Fforde</WRITER>". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: vallax-repnode-001 :) (: Description: replace element fails if the new node is invalid :)  declare construction strip; declare [Error is around here]revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   replace node ($books//AUTHOR)[1] with <WRITER>Jasper Fforde</WRITER>
revalidate-vallax-repnode-002,Error: XPST0003: Unable to parse XPath: "(: Name: vallax-repnode-002 :) (: Description: replace attribute fails if the new node is invalid :)  declare construction strip; declare revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   replace node ($books//ITEM)[1]/@CAT with <A cat="mmc"/>/@cat". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: vallax-repnode-002 :) (: Description: replace attribute fails if the new node is invalid :)  declare construction strip; declare [Error is around here]revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   replace node ($books//ITEM)[1]/@CAT with <A cat="mmc"/>/@cat
revalidate-vallax-repnode-003,Error: XPST0003: Unable to parse XPath: "(: Name: vallax-repnode-003 :) (: Description: replace element is OK if the new node is valid :)  declare construction strip; declare revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   replace node ($books//AUTHOR)[1] with <AUTHOR>Thursday Next</AUTHOR>". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: vallax-repnode-003 :) (: Description: replace element is OK if the new node is valid :)  declare construction strip; declare [Error is around here]revalidation lax; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   replace node ($books//AUTHOR)[1] with <AUTHOR>Thursday Next</AUTHOR>
revalidation-declaration-03-fail,Error: XPST0003: Unable to parse XPath: "(: Name: revalidation-declaration-03 :) (: Description: One declare validation specifying lax :)  declare revalidation lax;  (: insert-start :) declare variable $input-context external; (: insert-end :)  12 ". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: revalidation-declaration-03 :) (: Description: One declare validation specifying lax :)  declare [Error is around here]revalidation lax;  (: insert-start :) declare variable $input-context external; (: insert-end :)  12
revalidation-declaration-05,Error: XPST0003: Unable to parse XPath: "(: Name: revalidation-declaration-05 :) (: Description: One declare validation specifying skip :)  declare revalidation skip;  (: insert-start :) declare variable $input-context external; (: insert-end :)  12 ". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: revalidation-declaration-05 :) (: Description: One declare validation specifying skip :)  declare [Error is around here]revalidation skip;  (: insert-start :) declare variable $input-context external; (: insert-end :)  12
revalidation-declaration-06,Error: XPST0003: Unable to parse XPath: "(: Name: revalidation-declaration-06 :) (: Description: Two declare validation specifying skip :)  declare revalidation skip; declare revalidation skip;  (: insert-start :) declare variable $input-context external; (: insert-end :)  12 ". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: revalidation-declaration-06 :) (: Description: Two declare validation specifying skip :)  declare [Error is around here]revalidation skip; declare revalidation skip;  (: insert-start :) declare variable $input-context external; (: insert-end :)  12
removeType-valskip-ins-001,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-ins-001 :) (: Description: insert before removes type from ancestors :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <AUTHOR>Jasper Fforde</AUTHOR> before ($books//AUTHOR)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-ins-001 :) (: Description: insert before removes type from ancestors :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <AUTHOR>Jasper Fforde</AUTHOR> before ($books//AUTHOR)[1]
removeType-valskip-ins-002,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-ins-002 :) (: Description: insert after removes type from ancestors :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <AUTHOR>Jasper Fforde</AUTHOR> after ($books//AUTHOR)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-ins-002 :) (: Description: insert after removes type from ancestors :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <AUTHOR>Jasper Fforde</AUTHOR> after ($books//AUTHOR)[1]
removeType-valskip-ins-003,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-ins-003 :) (: Description: insert into removes type from ancestors :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node "abc" into ($books//AUTHOR)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-ins-003 :) (: Description: insert into removes type from ancestors :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node "abc" into ($books//AUTHOR)[1]
removeType-valskip-ins-004,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-ins-004 :) (: Description: insert as first into (of element node) removes type from ancestors :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <by/> as first into ($books//AUTHOR)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-ins-004 :) (: Description: insert as first into (of element node) removes type from ancestors :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <by/> as first into ($books//AUTHOR)[1]
removeType-valskip-ins-005,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-ins-005 :) (: Description: insert as last into (of comment node) doesn't remove type from ancestors :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <!-- yes, really --> as last into ($books//AUTHOR)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-ins-005 :) (: Description: insert as last into (of comment node) doesn't remove type from ancestors :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node <!-- yes, really --> as last into ($books//AUTHOR)[1]
removeType-valskip-ins-006,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-ins-006 :) (: Description: insert attribute removes type from ancestors :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node attribute famous {"yes"} into ($books//AUTHOR)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-ins-006 :) (: Description: insert attribute removes type from ancestors :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node attribute famous {"yes"} into ($books//AUTHOR)[1]
removeType-valskip-ins-007,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-ins-007 :) (: Description: with no validation, adding xsi:nil is not an error :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node attribute xsi:nil {"true"} into ($books//AUTHOR)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-ins-007 :) (: Description: with no validation, adding xsi:nil is not an error :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   insert node attribute xsi:nil {"true"} into ($books//AUTHOR)[1]
removeType-valskip-ins-008,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-ins-008 :) (: Description: with no validation, adding xml:id has is-ID property but not xs:ID type :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  (: we call the id() function in case the implementation builds ID indexes lazily :) insert node attribute ids {count($books/id('jff001'))} into $books/BOOKLIST, insert node attribute xml:id {"unique"} into ($books//AUTHOR)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-ins-008 :) (: Description: with no validation, adding xml:id has is-ID property but not xs:ID type :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  (: we call the id() function in case the implementation builds ID indexes lazily :) insert node attribute ids {count($books/id('jff001'))} into $books/BOOKLIST, insert node attribute xml:id {"unique"} into ($books//AUTHOR)[1]
removeType-valskip-ins-009,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-ins-009 :) (: Description: with no validation, but construction mode preserve, inserted elements retain their type :)  declare construction preserve; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  insert node $books//ITEM[1] as last into $books//BOOKS". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-ins-009 :) (: Description: with no validation, but construction mode preserve, inserted elements retain their type :)  declare construction preserve; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  insert node $books//ITEM[1] as last into $books//BOOKS
removeType-valskip-ins-010,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-ins-010 :) (: Description: with no validation, but construction mode strip, inserted elements lose their type :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  insert node $books//ITEM[1] as last into $books//BOOKS". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-ins-010 :) (: Description: with no validation, but construction mode strip, inserted elements lose their type :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  insert node $books//ITEM[1] as last into $books//BOOKS
removeType-valskip-ins-011,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-ins-011 :) (: Description: with no validation, but construction mode preserve, inserted attributes retain their type :)  declare construction preserve; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  insert node $books//ITEM[1]/DIMENSIONS/@UNIT into $books//ITEM[1]/PRICE". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-ins-011 :) (: Description: with no validation, but construction mode preserve, inserted attributes retain their type :)  declare construction preserve; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  insert node $books//ITEM[1]/DIMENSIONS/@UNIT into $books//ITEM[1]/PRICE
removeType-valskip-ins-012,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-ins-012 :) (: Description: with no validation, but construction mode strip, inserted attributes lose their type :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  insert node $books//ITEM[1]/DIMENSIONS/@UNIT into $books//ITEM[1]/PRICE". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-ins-012 :) (: Description: with no validation, but construction mode strip, inserted attributes lose their type :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  insert node $books//ITEM[1]/DIMENSIONS/@UNIT into $books//ITEM[1]/PRICE
removeType-valskip-ins-013,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-ins-013 :) (: Description: with no validation, but construction mode preserve, adding an IDREF attribute affects result of idref() :)  declare construction preserve; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  (: evaluate idref() in case index is built lazily :) insert node attribute iii {count($books/idref('P'))} into $books/BOOKLIST, insert node $books//ITEM[1]/@CAT into $books//ITEM[1]/PRICE". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-ins-013 :) (: Description: with no validation, but construction mode preserve, adding an IDREF attribute affects result of idref() :)  declare construction preserve; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  (: evaluate idref() in case index is built lazily :) insert node attribute iii {count($books/idref('P'))} into $books/BOOKLIST, insert node $books//ITEM[1]/@CAT into $books//ITEM[1]/PRICE
removeType-valskip-ins-014,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-ins-014 :) (: Description: if input is untyped, it remains untyped after update :)  declare construction preserve; declare revalidation skip;  (: insert-start :) declare variable $users as document-node(element(users, xs:untyped)) external; (: insert-end :)  insert node <zzz/> into $users/users/user_tuple[1]/name". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-ins-014 :) (: Description: if input is untyped, it remains untyped after update :)  declare construction preserve; declare [Error is around here]revalidation skip;  (: insert-start :) declare variable $users as document-node(element(users, xs:untyped)) external; (: insert-end :)  insert node <zzz/> into $users/users/user_tuple[1]/name
removeType-valskip-del-001,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-del-001 :) (: Description: deleting an element removes type from ancestors :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   delete node ($books//AUTHOR)[1]". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-del-001 :) (: Description: deleting an element removes type from ancestors :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   delete node ($books//AUTHOR)[1]
removeType-valskip-del-002,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-del-002 :) (: Description: deleting an attribute removes type from ancestors :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   delete node ($books//@UNIT)". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-del-002 :) (: Description: deleting an attribute removes type from ancestors :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   delete node ($books//@UNIT)
removeType-valskip-del-003,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-del-003 :) (: Description: deleting an xml:id attribute affects result of id() function :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  (: we call the id() function in case the implementation builds ID indexes lazily :) insert node attribute ids {count($books/id('jff001'))} into $books/BOOKLIST, delete node ($books//@xml:id)". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-del-003 :) (: Description: deleting an xml:id attribute affects result of id() function :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  (: we call the id() function in case the implementation builds ID indexes lazily :) insert node attribute ids {count($books/id('jff001'))} into $books/BOOKLIST, delete node ($books//@xml:id)
removeType-valskip-del-004,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-del-004 :) (: Description: deleting a text node removes type from ancestors :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   delete node ($books//AUTHOR)[1]/text()". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-del-004 :) (: Description: deleting a text node removes type from ancestors :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   delete node ($books//AUTHOR)[1]/text()
removeType-valskip-del-005,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-del-005 :) (: Description: deleting a comment node does not remove type from ancestors :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   delete nodes $books//comment()". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-del-005 :) (: Description: deleting a comment node does not remove type from ancestors :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   delete nodes $books//comment()
removeType-valskip-ren-001,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-ren-001 :) (: Description: renaming an element removes type from self and ancestors :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   rename node ($books//AUTHOR)[1] as "WRITER"". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-ren-001 :) (: Description: renaming an element removes type from self and ancestors :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   rename node ($books//AUTHOR)[1] as "WRITER"
removeType-valskip-ren-002,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-ren-002 :) (: Description: renaming an attribute removes type from self and ancestors :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   for $n in $books//@UNIT return rename node $n as "units"". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-ren-002 :) (: Description: renaming an attribute removes type from self and ancestors :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   for $n in $books//@UNIT return rename node $n as "units"
removeType-valskip-ren-003,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-ren-003 :) (: Description: renaming an xml:id attribute affects result of id() function :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  (: we call the id() function in case the implementation builds ID indexes lazily :) insert node attribute ids {count($books/id('jff001'))} into $books/BOOKLIST, for $a in $books//@xml:id  return rename node $a as "ex-id"". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-ren-003 :) (: Description: renaming an xml:id attribute affects result of id() function :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  (: we call the id() function in case the implementation builds ID indexes lazily :) insert node attribute ids {count($books/id('jff001'))} into $books/BOOKLIST, for $a in $books//@xml:id  return rename node $a as "ex-id"
removeType-valskip-ren-004,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-ren-004 :) (: Description: renaming a text node is an error :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   rename node ($books//AUTHOR)[1]/text() as "text"". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-ren-004 :) (: Description: renaming a text node is an error :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   rename node ($books//AUTHOR)[1]/text() as "text"
removeType-valskip-ren-005,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-ren-005 :) (: Description: renaming a PI node does not remove type from ancestors :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   for $p in $books//processing-instruction(pi) return rename node $p as "theta"". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-ren-005 :) (: Description: renaming a PI node does not remove type from ancestors :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   for $p in $books//processing-instruction(pi) return rename node $p as "theta"
removeType-valskip-ren-006,Error: XPST0003: Unable to parse XPath: "(: valskip-ren-006 - two updates create conflicting namespace bindings, not detected until    upd:insert is executed, at which point it causes XUDY0024 :)     (: original test from Jan Cuypers, DataDirect, integrated by Michael Kay :)     declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   let $a := <ns1:a xmlns:ns1="http://ns1"><b/></ns1:a> return (     rename node $a as node-name(<ns2:a xmlns:ns2="http://ns2"/>),     insert node        <a xmlns:ns2="http://ns3" ns2:b="b"/>/@*:b   after $a/b )  ". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: valskip-ren-006 - two updates create conflicting namespace bindings, not detected until    upd:insert is executed, at which point it causes XUDY0024 :)     (: original test from Jan Cuypers, DataDirect, integrated by Michael Kay :)     declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   let $a := <ns1:a xmlns:ns1="http://ns1"><b/></ns1:a> return (     rename node $a as node-name(<ns2:a xmlns:ns2="http://ns2"/>),     insert node        <a xmlns:ns2="http://ns3" ns2:b="b"/>/@*:b   after $a/b )
removeType-valskip-repnode-001,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-repnode-001 :) (: Description: replace element removes type from ancestors :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   replace node ($books//AUTHOR)[1] with <WRITER>Jasper Fforde</WRITER>". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-repnode-001 :) (: Description: replace element removes type from ancestors :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   replace node ($books//AUTHOR)[1] with <WRITER>Jasper Fforde</WRITER>
removeType-valskip-repnode-002,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-repnode-002 :) (: Description: replace attribute removes type from ancestors :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   replace node ($books//@UNIT)[1] with attribute {"units"} {"furlongs"}". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-repnode-002 :) (: Description: replace attribute removes type from ancestors :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   replace node ($books//@UNIT)[1] with attribute {"units"} {"furlongs"}
removeType-valskip-repnode-003,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-repnode-003 :) (: Description: replace attribute retains type of attribute with construction preserve :)  declare construction preserve; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  let $d := validate strict {<DIMENSIONS UNIT="cm">12.3 1.0 2.0</DIMENSIONS>} return    replace node ($books//@UNIT)[1] with $d/@UNIT". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-repnode-003 :) (: Description: replace attribute retains type of attribute with construction preserve :)  declare construction preserve; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  let $d := validate strict {<DIMENSIONS UNIT="cm">12.3 1.0 2.0</DIMENSIONS>} return    replace node ($books//@UNIT)[1] with $d/@UNIT
removeType-valskip-repnode-004,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-repnode-004 :) (: Description: replacing an ID attribute with construction=strip drops the ID :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  let $old := id("P", $books)/@CODE return replace node ($books//CATEGORY)[1]/@CODE with attribute {"CODE"}{concat($old, "2")}". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-repnode-004 :) (: Description: replacing an ID attribute with construction=strip drops the ID :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  let $old := id("P", $books)/@CODE return replace node ($books//CATEGORY)[1]/@CODE with attribute {"CODE"}{concat($old, "2")}
removeType-valskip-repnode-005,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-repnode-005 :) (: Description: replacing an ID attribute with construction=preserve drops the old ID and creates a new one :)  declare construction preserve; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   let $old := id("P", $books)/@CODE  let $p2 := validate strict {<CATEGORY CODE="{$old}2" DESC=""/>} return replace node ($books//CATEGORY)[1]/@CODE with $p2/@CODE". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-repnode-005 :) (: Description: replacing an ID attribute with construction=preserve drops the old ID and creates a new one :)  declare construction preserve; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   let $old := id("P", $books)/@CODE  let $p2 := validate strict {<CATEGORY CODE="{$old}2" DESC=""/>} return replace node ($books//CATEGORY)[1]/@CODE with $p2/@CODE
removeType-valskip-repnode-006,Error: XPST0003: Unable to parse XPath: "(: Name: valskip-repnode-006 :) (: Description: replacing an IDREF attribute with construction=strip drops the old IDREF :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   let $old := count(idref("P", $books)) let $pref := validate strict {<DUMMYREF CATREF="P"/>} return (replace node ($books//ITEM)[2]/@CAT with $pref/@CATREF,         insert node comment{ $old } as first into $books)". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valskip-repnode-006 :) (: Description: replacing an IDREF attribute with construction=strip drops the old IDREF :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books";  (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)   let $old := count(idref("P", $books)) let $pref := validate strict {<DUMMYREF CATREF="P"/>} return (replace node ($books//ITEM)[2]/@CAT with $pref/@CATREF,         insert node comment{ $old } as first into $books)
revalidation-declaration-05-fail,Error: XPST0003: Unable to parse XPath: "(: Name: revalidation-declaration-05 :) (: Description: One declare validation specifying skip :)  declare revalidation skip;  (: insert-start :) declare variable $input-context external; (: insert-end :)  12 ". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: revalidation-declaration-05 :) (: Description: One declare validation specifying skip :)  declare [Error is around here]revalidation skip;  (: insert-start :) declare variable $input-context external; (: insert-end :)  12
revalidate-valtrans-ins-003,Error: XPST0003: Unable to parse XPath: "(: Name: valtrans-ins-003 :) (: Description: inserting a disallowed element is bad news; detected by revalidation defined    in prolog of library module :)  declare construction strip; declare revalidation skip; import schema default element namespace "http://ns.example.com/books"; import module namespace m1 = "http://www.w3.org/xqupd/tests/ns/valtrans-ins-003" at "valtrans-ins-003-mod1.xq";     (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  m1:update($books)         ". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "base-uri", "boundary-space", "cast", "castable", "construction", "context", "copy-namespaces", "decimal-format", "default", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "namespace", "ne", "option", "or", "ordering", "to", "treat", "union", "variable", "|", "||", or end of input but "r" found. (: Name: valtrans-ins-003 :) (: Description: inserting a disallowed element is bad news; detected by revalidation defined    in prolog of library module :)  declare construction strip; declare [Error is around here]revalidation skip; import schema default element namespace "http://ns.example.com/books"; import module namespace m1 = "http://www.w3.org/xqupd/tests/ns/valtrans-ins-003" at "valtrans-ins-003-mod1.xq";     (: insert-start :) declare variable $books as document-node(schema-element(BOOKLIST)) external; (: insert-end :)  m1:update($books)
stf-insert-01,Error: XPST0003: Unable to parse XPath: "(: Name: stf-insert-01 :) (: Description: insert: ST of SourceExpr is too vague. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $source as node()* := (<status>on leave</status>, <!-- for 6 months -->),     $target := $input-context/works[1]/employee[1] return     insert nodes $source into $target ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: stf-insert-01 :) (: Description: insert: ST of SourceExpr is too vague. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $source as node()* := (<status>on leave</status>, <!-- for 6 months -->),     $target := $input-context/works[1]/employee[1] return     insert [Error is around here]nodes $source into $target
stf-insert-02,Error: XPST0003: Unable to parse XPath: "(: Name: stf-insert-02 :) (: Description: insert: ST of SourceExpr has non-attribute before attribute. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $source := ( element status {'active'}, attribute type {'PT'} ) for $target in $input-context/works/employee[@nonexistent] return     insert nodes $source into $target ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: stf-insert-02 :) (: Description: insert: ST of SourceExpr has non-attribute before attribute. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $source := ( element status {'active'}, attribute type {'PT'} ) for $target in $input-context/works/employee[@nonexistent] return     insert [Error is around here]nodes $source into $target
stf-insert-into-01,Error: XPST0003: Unable to parse XPath: "(: Name: stf-insert-into-01 :) (: Description: insert-into: ST of TargetExpr has cardinality greater than one. :)  (: insert-start :) declare variable $input-context as document-node(element(*, xs:untyped)) external; (: insert-end :)  let $source := <status>active</status>,     $target := $input-context/works/employee[@name='Jane Doe 1'] return     insert node $source into $target ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: stf-insert-into-01 :) (: Description: insert-into: ST of TargetExpr has cardinality greater than one. :)  (: insert-start :) declare variable $input-context as document-node(element(*, xs:untyped)) external; (: insert-end :)  let $source := <status>active</status>,     $target := $input-context/works/employee[@name='Jane Doe 1'] return     insert [Error is around here]node $source into $target
stf-insert-into-02,Error: XPST0003: Unable to parse XPath: "(: Name: stf-insert-into-02 :) (: Description: insert-into: ST of TargetExpr is too vague. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $source := <status>active</status> for $target in $input-context/works/node()[not(self::text())] return     insert node $source into $target ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: stf-insert-into-02 :) (: Description: insert-into: ST of TargetExpr is too vague. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $source := <status>active</status> for $target in $input-context/works/node()[not(self::text())] return     insert [Error is around here]node $source into $target
stf-insert-into-03,Error: XPST0003: Unable to parse XPath: "(: Name: stf-insert-into-03 :) (: Description: insert-into: ST of TargetExpr is attribute(). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $source := <status>active</status> for $target in $input-context/works/employee/@nonexistent return     insert node $source into $target ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: stf-insert-into-03 :) (: Description: insert-into: ST of TargetExpr is attribute(). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $source := <status>active</status> for $target in $input-context/works/employee/@nonexistent return     insert [Error is around here]node $source into $target
stf-insert-into-04,Error: XPST0003: Unable to parse XPath: "(: Name: stf-insert-into-04 :) (: Description: insert-into: ST of TargetExpr is document() but ST of SourceExpr involves attribute(). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $source := $input-context/works/employee[1]/@nonexistent,     $target := $input-context return     insert node $source into $target ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: stf-insert-into-04 :) (: Description: insert-into: ST of TargetExpr is document() but ST of SourceExpr involves attribute(). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $source := $input-context/works/employee[1]/@nonexistent,     $target := $input-context return     insert [Error is around here]node $source into $target
stf-insert-after-01,Error: XPST0003: Unable to parse XPath: "(: Name: stf-insert-after-01 :) (: Description: insert-after: ST of TargetExpr has cardinality greater than one. :)  (: insert-start :) declare variable $input-context as document-node(element(*, xs:untyped)) external; (: insert-end :)  let $source := <employee name="John Q Public"/>,     $target := $input-context/works/employee[@name='Jane Doe 1'] return     insert node $source after $target ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: stf-insert-after-01 :) (: Description: insert-after: ST of TargetExpr has cardinality greater than one. :)  (: insert-start :) declare variable $input-context as document-node(element(*, xs:untyped)) external; (: insert-end :)  let $source := <employee name="John Q Public"/>,     $target := $input-context/works/employee[@name='Jane Doe 1'] return     insert [Error is around here]node $source after $target
stf-insert-after-02,Error: XPST0003: Unable to parse XPath: "(: Name: stf-insert-after-02 :) (: Description: insert-after: ST of TargetExpr is too vague. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $source := <employee name="John Q Public"/>,     $target as node()? := $input-context/works[1]/employee[1] return     insert node $source after $target ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: stf-insert-after-02 :) (: Description: insert-after: ST of TargetExpr is too vague. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $source := <employee name="John Q Public"/>,     $target as node()? := $input-context/works[1]/employee[1] return     insert [Error is around here]node $source after $target
stf-insert-after-03,Error: XPST0003: Unable to parse XPath: "(: Name: stf-insert-after-03 :) (: Description: insert-after: ST of TargetExpr is attribute(). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $source := attribute type {'PT'} for $target in $input-context/works/employee/@nonexistent return     insert node $source after $target ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: stf-insert-after-03 :) (: Description: insert-after: ST of TargetExpr is attribute(). :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $source := attribute type {'PT'} for $target in $input-context/works/employee/@nonexistent return     insert [Error is around here]node $source after $target
stf-delete-01,Error: XPST0003: Unable to parse XPath: "(: Name: stf-delete-01 :) (: Description: delete: ST of TargetExpr is too vague. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $target as item()* := $input-context/works/employee return     delete nodes $target ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: stf-delete-01 :) (: Description: delete: ST of TargetExpr is too vague. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $target as item()* := $input-context/works/employee return     delete [Error is around here]nodes $target
stf-delete-02,Error: XPST0003: Unable to parse XPath: "(: Name: stf-delete-02 :) (: Description: delete: ST of TargetExpr is atomic type. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  for $target in $input-context/works/employee/@nonexistent/fn:string() return     delete node $target ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: stf-delete-02 :) (: Description: delete: ST of TargetExpr is atomic type. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  for $target in $input-context/works/employee/@nonexistent/fn:string() return     delete [Error is around here]node $target
stf-replace-node-01,Error: Should throw error XUTY0008.
stf-replace-node-02,Error: Should throw error XUTY0008.
stf-replace-node-03,Error: Should throw error XUTY0008.
stf-replace-node-04,Error: Should throw error XUTY0010.
stf-replace-node-05,Error: Should throw error XUTY0010.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUTY0010'
stf-replace-node-06,Error: Should throw error XUTY0011.
stf-replace-node-07,Error: Should throw error XUTY0011.: expected 'Not implemented: Intermediate clauses in flwor expressions are not implemented yet' to equal 'XUTY0011'
stf-replace-value-of-node-01,Error: Should throw error XUTY0008.
stf-replace-value-of-node-02,Error: Should throw error XUTY0008.
stf-rename-01,Error: Should throw error XUTY0012.
stf-rename-02,Error: Should throw error XUTY0012.
stf-rename-03,Error: Should throw error XUTY0012.
stf-rename-04,Error: Should throw error XPTY0004.
stf-transform-01,Error: XPST0003: Unable to parse XPath: "(: Name: stf-transform-01 :) (: Description: transform: ST of source expression has cardinality greater than one. :)  (: insert-start :) declare variable $input-context as document-node(element(*, xs:untyped)) external; (: insert-end :)  copy $employee := $input-context/works/employee[@name='Jane Doe 1'] modify delete node $employee/hours return $employee ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: stf-transform-01 :) (: Description: transform: ST of source expression has cardinality greater than one. :)  (: insert-start :) declare variable $input-context as document-node(element(*, xs:untyped)) external; (: insert-end :)  copy $employee := $input-context/works/employee[@name='Jane Doe 1'] modify delete [Error is around here]node $employee/hours return $employee
stf-transform-02,Error: XPST0003: Unable to parse XPath: "(: Name: stf-transform-02 :) (: Description: transform: ST of source expression is too vague. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $item as item() := <employee name='John Q Public'/> return     copy $i := $item     modify delete node $i/@name     return $i ". Expected " ", "!", "!=", "(", "(:", "*", "+", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "return", "to", "treat", "union", "|", or "||" but "n" found. (: Name: stf-transform-02 :) (: Description: transform: ST of source expression is too vague. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  let $item as item() := <employee name='John Q Public'/> return     copy $i := $item     modify delete [Error is around here]node $i/@name     return $i
stf-transform-03,Error: Should throw error XUTY0013.
complex-deletes-q1,Error: XPST0003: Unable to parse XPath: "(: Name: complex-deletes-q1 :) (: Description: Delete leading comments of document element. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete nodes $input-context/comment()[. << $input-context/*] ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: complex-deletes-q1 :) (: Description: Delete leading comments of document element. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete [Error is around here]nodes $input-context/comment()[. << $input-context/*]
complex-deletes-q2,Error: XPST0003: Unable to parse XPath: "(: Name: complex-deletes-q2 :) (: Description: Delete trailing comments of document element. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete nodes $input-context/comment()[. >> $input-context/*] ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: complex-deletes-q2 :) (: Description: Delete trailing comments of document element. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete [Error is around here]nodes $input-context/comment()[. >> $input-context/*]
complex-deletes-q6,Error: XPST0003: Unable to parse XPath: "(: Name: complex-deletes-q6 :) (: Description: Delete the text node child of element "east". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete nodes $input-context//east/text() ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: complex-deletes-q6 :) (: Description: Delete the text node child of element "east". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete [Error is around here]nodes $input-context//east/text()
complex-deletes-q7,Error: XPST0003: Unable to parse XPath: "(: Name: complex-deletes-q7 :) (: Description: Delete all text nodes that come directly after a comment or PI. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete nodes $input-context//text()[preceding-sibling::node()[1]/(self::comment() | self::processing-instruction())] ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: complex-deletes-q7 :) (: Description: Delete all text nodes that come directly after a comment or PI. :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete [Error is around here]nodes $input-context//text()[preceding-sibling::node()[1]/(self::comment() | self::processing-instruction())]
complex-deletes-q8,Error: XPST0003: Unable to parse XPath: "(: Name: complex-deletes-q8 :) (: Description: Delete all elements called "south-east". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete nodes $input-context//south-east ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: complex-deletes-q8 :) (: Description: Delete all elements called "south-east". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete [Error is around here]nodes $input-context//south-east
complex-deletes-q9,Error: XPST0003: Unable to parse XPath: "(: Name: complex-deletes-q9 :) (: Description: Delete the element called "center". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete nodes $input-context/far-north/north/near-north/center ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Name: complex-deletes-q9 :) (: Description: Delete the element called "center". :)  (: insert-start :) declare variable $input-context external; (: insert-end :)  delete [Error is around here]nodes $input-context/far-north/north/near-north/center
complex-replacevalues-q1,Error: XPTY0004 Unable to cast xs:string to type xs:string while calling substring
complex-replacevalues-q7,Error: expected '<root><result count="16"> text-1A\n     text-2A\n       text-3A\n       text-3B\n       text-3C\n       text-3D\n       text-4A\n         text-4B\n             text-5A\n           text-6A\n            </result><result count="13"> text-6B\n           text-5B\n         text-4E\n             text-4G\n         text-4H\n       text-3E\n       text-3F\n      Text in east text-3G\n       text-3H\n     text-2D\n   text-1D\n</result></root>' to equal '<root><result count="10"> text-1A\n     text-2A\n       text-3A\n       text-3B\n       text-3C\n       text-3D\n       text-4A\n         text-4B\n             text-5A\n           text-6A\n            </result><result count="12"> text-6B\n           text-5B\n         text-4E\n             text-4G\n         text-4H\n       text-3E\n       text-3F\n      Text in east text-3G\n       text-3H\n     text-2D\n   text-1D\n</result></root>'
fn-put-003,Error: A non-updating expression without an expected value is not supported in the test framework.
fn-put-003-fail,Error: Should throw error FOUP0001.: expected 'XPST0017: Function fn:put with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}put (array(*)null, xs:integernull, item()*)" or "Q{http://www.w3.org/2005/xpath-functions/map}put (map(*)null, xs:anyAtomicTypenull, item()*)"?' to equal 'FOUP0001'
fn-put-004,Error: A non-updating expression without an expected value is not supported in the test framework.
fn-put-004-fail,Error: Should throw error FOUP0001.: expected 'XPST0017: Function fn:put with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}put (array(*)null, xs:integernull, item()*)" or "Q{http://www.w3.org/2005/xpath-functions/map}put (map(*)null, xs:anyAtomicTypenull, item()*)"?' to equal 'FOUP0001'
fn-put-005,Error: A non-updating expression without an expected value is not supported in the test framework.
fn-put-005-fail,Error: Should throw error FOUP0001.: expected 'XPST0017: Function fn:put with arity of 2 not registered. Did you mean "Q{http://www.w3.org/2005/xpath-functions/array}put (array(*)null, xs:integernull, item()*)" or "Q{http://www.w3.org/2005/xpath-functions/map}put (map(*)null, xs:anyAtomicTypenull, item()*)"?' to equal 'FOUP0001'
fn-put-006,Error: A non-updating expression without an expected value is not supported in the test framework.
fn-put-006-fail,Error: Should throw error FOUP0001.: expected 'No selector counterpart for: computedTextConstructor.' to equal 'FOUP0001'
relational-data-q1,Error: XPST0003: Unable to parse XPath: "(: Test - relational-data-q1 :) (: Description - Update Use Case #1  :)  (: insert-start :) declare variable $users external; (: insert-end :)  (:state-1-start :)  insert node   <user_tuple>     <userid>U07</userid>     <name>Annabel Lee</name>   </user_tuple> into $users/users  (:state-1-end :)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Test - relational-data-q1 :) (: Description - Update Use Case #1  :)  (: insert-start :) declare variable $users external; (: insert-end :)  (:state-1-start :)  insert [Error is around here]node   <user_tuple>     <userid>U07</userid>     <name>Annabel Lee</name>   </user_tuple> into $users/users  (:state-1-end :)
relational-data-q2,Error: XPST0003: Unable to parse XPath: "(: Test - relational-data-q2 :) (: Description - Update Use Case #2  :)  (: insert-start :) declare variable $users external; declare variable $bids external; (: insert-end :)  (:state-1-start :)  let $uid :=  $users/users/user_tuple[name="Annabel Lee"]/userid return    insert node      <bid_tuple>        <userid>{data($uid)}</userid>        <itemno>1001</itemno>        <bid>60</bid>        <bid_date>1999-02-01</bid_date>      </bid_tuple>   into $bids/bids    (:state-1-end :)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Test - relational-data-q2 :) (: Description - Update Use Case #2  :)  (: insert-start :) declare variable $users external; declare variable $bids external; (: insert-end :)  (:state-1-start :)  let $uid :=  $users/users/user_tuple[name="Annabel Lee"]/userid return    insert [Error is around here]node      <bid_tuple>        <userid>{data($uid)}</userid>        <itemno>1001</itemno>        <bid>60</bid>        <bid_date>1999-02-01</bid_date>      </bid_tuple>   into $bids/bids    (:state-1-end :)
relational-data-q3,Error: XPST0003: Unable to parse XPath: "(: Test - relational-data-q3 :) (: Description - Update Use Case #3  :)  (: insert-start :) declare variable $users external; declare variable $bids external; (: insert-end :)  (:state-1-start :)  let $uid :=  $users/users/user_tuple[name="Annabel Lee"]/userid let $topbid :=  max($bids/bids/bid_tuple[itemno=1002]/bid) return    insert node      <bid_tuple>        <userid>{data($uid)}</userid>        <itemno>1002</itemno>        <bid>{$topbid*1.1}</bid>       <bid_date>1999-02-01</bid_date>      </bid_tuple>   into $bids/bids    (:state-1-end :)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Test - relational-data-q3 :) (: Description - Update Use Case #3  :)  (: insert-start :) declare variable $users external; declare variable $bids external; (: insert-end :)  (:state-1-start :)  let $uid :=  $users/users/user_tuple[name="Annabel Lee"]/userid let $topbid :=  max($bids/bids/bid_tuple[itemno=1002]/bid) return    insert [Error is around here]node      <bid_tuple>        <userid>{data($uid)}</userid>        <itemno>1002</itemno>        <bid>{$topbid*1.1}</bid>       <bid_date>1999-02-01</bid_date>      </bid_tuple>   into $bids/bids    (:state-1-end :)
relational-data-q4,Error: XPST0003: Unable to parse XPath: "(: Test - relational-data-q4 :) (: Description - Update Use Case #4  :)  (: insert-start :) declare variable $users external; (: insert-end :)  (:state-1-start :)  let $user := $users/users/user_tuple[name="Annabel Lee"] return    if($user/rating)   then replace value of node $user/rating with "B"   else insert node <rating>B</rating> into $user  (:state-1-end :)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Test - relational-data-q4 :) (: Description - Update Use Case #4  :)  (: insert-start :) declare variable $users external; (: insert-end :)  (:state-1-start :)  let $user := $users/users/user_tuple[name="Annabel Lee"] return    if($user/rating)   then replace value of node $user/rating with "B"   else insert [Error is around here]node <rating>B</rating> into $user  (:state-1-end :)
relational-data-q5-1,Error: XPST0003: Unable to parse XPath: "(: Test - relational-data-q5-1 :) (: Description - Update Use Case #5  :)  (: insert-start :) declare variable $users external; declare variable $bids external; (: insert-end :)  (:state-1-start :)  let $uid :=  $users/users/user_tuple[name="Annabel Lee"]/userid let $topbid :=  max($bids/bids/bid_tuple[itemno=1007]/bid) where $topbid*1.1 <= 200 return    insert node      <bid_tuple>        <userid>{data($uid)}</userid>        <itemno>1007</itemno>        <bid>{$topbid*1.1}</bid>        <bid_date>1999-02-01</bid_date>      </bid_tuple>   into $bids/bids    (:state-1-end :)  ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Test - relational-data-q5-1 :) (: Description - Update Use Case #5  :)  (: insert-start :) declare variable $users external; declare variable $bids external; (: insert-end :)  (:state-1-start :)  let $uid :=  $users/users/user_tuple[name="Annabel Lee"]/userid let $topbid :=  max($bids/bids/bid_tuple[itemno=1007]/bid) where $topbid*1.1 <= 200 return    insert [Error is around here]node      <bid_tuple>        <userid>{data($uid)}</userid>        <itemno>1007</itemno>        <bid>{$topbid*1.1}</bid>        <bid_date>1999-02-01</bid_date>      </bid_tuple>   into $bids/bids    (:state-1-end :)
relational-data-q5-2,Error: XPST0003: Unable to parse XPath: "(: Test - relational-data-q5-2 :) (: Description - Update Use Case #5  :)  (: insert-start :) declare variable $users external; declare variable $bids external; (: insert-end :)  (:state-1-start :)  let $uid := $users/users/user_tuple[name="Annabel Lee"]/userid let $topbid := max($bids/bids/bid_tuple[itemno=1007]/bid/xs:decimal(.)) where $topbid*1.1 <= 500 return    insert nodes      <bid_tuple>        <userid>{data($uid)}</userid>        <itemno>1007</itemno>        <bid>{$topbid*1.1}</bid>        <bid_date>1999-02-01</bid_date>      </bid_tuple>   into $bids/bids      (:state-1-end :)  ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Test - relational-data-q5-2 :) (: Description - Update Use Case #5  :)  (: insert-start :) declare variable $users external; declare variable $bids external; (: insert-end :)  (:state-1-start :)  let $uid := $users/users/user_tuple[name="Annabel Lee"]/userid let $topbid := max($bids/bids/bid_tuple[itemno=1007]/bid/xs:decimal(.)) where $topbid*1.1 <= 500 return    insert [Error is around here]nodes      <bid_tuple>        <userid>{data($uid)}</userid>        <itemno>1007</itemno>        <bid>{$topbid*1.1}</bid>        <bid_date>1999-02-01</bid_date>      </bid_tuple>   into $bids/bids      (:state-1-end :)
relational-data-q6-1,Error: XPST0003: Unable to parse XPath: "(: Test - relational-data-q6-1 :) (: Description - Update Use Case #6  :)  (: insert-start :) declare variable $users external; declare variable $items external; declare variable $bids external; (: insert-end :)  (:state-1-start :) let $user :=  $users/users/user_tuple[name="Dee Linquent"] let $items :=  $items/items/item_tuple[offered_by=$user/userid] let $bids :=  $bids/bids/bid_tuple[userid=$user/userid] return (   delete nodes $user,   delete nodes $items,   delete nodes $bids )  (:state-1-end :)  ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Test - relational-data-q6-1 :) (: Description - Update Use Case #6  :)  (: insert-start :) declare variable $users external; declare variable $items external; declare variable $bids external; (: insert-end :)  (:state-1-start :) let $user :=  $users/users/user_tuple[name="Dee Linquent"] let $items :=  $items/items/item_tuple[offered_by=$user/userid] let $bids :=  $bids/bids/bid_tuple[userid=$user/userid] return (   delete [Error is around here]nodes $user,   delete nodes $items,   delete nodes $bids )  (:state-1-end :)
relational-data-q6-2,Error: XPST0003: Unable to parse XPath: "(: Test - relational-data-q6-2 :) (: Description - Update Use Case #6- Alternate Solution  :)  (: insert-start :) declare variable $users external; declare variable $items external; declare variable $bids external; (: insert-end :)  (:state-1-start :)  let $user :=  $users/users/user_tuple[name="Dee Linquent"] let $items :=  $items/items/item_tuple[offered_by=$user/userid] let $bids :=  $bids/bids/bid_tuple[userid=$user/userid] return    delete nodes ($user, $items, $bids)  (:state-1-end :)  ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Test - relational-data-q6-2 :) (: Description - Update Use Case #6- Alternate Solution  :)  (: insert-start :) declare variable $users external; declare variable $items external; declare variable $bids external; (: insert-end :)  (:state-1-start :)  let $user :=  $users/users/user_tuple[name="Dee Linquent"] let $items :=  $items/items/item_tuple[offered_by=$user/userid] let $bids :=  $bids/bids/bid_tuple[userid=$user/userid] return    delete [Error is around here]nodes ($user, $items, $bids)  (:state-1-end :)
relational-data-q7,Error: XPST0003: Unable to parse XPath: "(: Test - relational-data-q7 :) (: Description - Update Use Case #7   :)  (: insert-start :) declare variable $items external; (: insert-end :)  (:state-1-start :)  insert nodes   <comment>This is a bargain !</comment> as last into $items/items/item_tuple[itemno=1002]   (:state-1-end :) ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Test - relational-data-q7 :) (: Description - Update Use Case #7   :)  (: insert-start :) declare variable $items external; (: insert-end :)  (:state-1-start :)  insert [Error is around here]nodes   <comment>This is a bargain !</comment> as last into $items/items/item_tuple[itemno=1002]   (:state-1-end :)
relational-data-q8,Error: XPST0003: Unable to parse XPath: "(: Test - relational-data-q8 :) (: Description - Update Use Case #8   :)  (: insert-start :) declare variable $users external; declare variable $bids external; (: insert-end :)  (:state-1-start :)  let $uid :=  $users/users/user_tuple[name="Annabel Lee"]/userid return    insert nodes     <bid_tuple>        <userid>{data($uid)}</userid>        <itemno>1010</itemno>        <bid>60</bid>        <bid_date>2006-04-23</bid_date>      </bid_tuple>   into $bids/bids    (:state-1-end :)  ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Test - relational-data-q8 :) (: Description - Update Use Case #8   :)  (: insert-start :) declare variable $users external; declare variable $bids external; (: insert-end :)  (:state-1-start :)  let $uid :=  $users/users/user_tuple[name="Annabel Lee"]/userid return    insert [Error is around here]nodes     <bid_tuple>        <userid>{data($uid)}</userid>        <itemno>1010</itemno>        <bid>60</bid>        <bid_date>2006-04-23</bid_date>      </bid_tuple>   into $bids/bids    (:state-1-end :)
relational-data-q9,Error: XPST0003: Unable to parse XPath: "(: Test - relational-data-q9 :) (: Description - Update Use Case #9   :)  (: insert-start :) declare variable $users external; declare variable $bids external; (: insert-end :)  (:state-1-start :)  let $uid :=  $users/users/user_tuple[name="Annabel Lee"]/userid let $topbid :=  max($bids//bid_tuple[itemno=1002]/bid) return    insert nodes      <bid_tuple>        <userid>{data($uid)}</userid>        <itemno>1002</itemno>        <bid>{$topbid - 5.00}</bid>        <bid_date>2006-04-23</bid_date>      </bid_tuple>   into $bids/bids     (:state-1-end :)  ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Test - relational-data-q9 :) (: Description - Update Use Case #9   :)  (: insert-start :) declare variable $users external; declare variable $bids external; (: insert-end :)  (:state-1-start :)  let $uid :=  $users/users/user_tuple[name="Annabel Lee"]/userid let $topbid :=  max($bids//bid_tuple[itemno=1002]/bid) return    insert [Error is around here]nodes      <bid_tuple>        <userid>{data($uid)}</userid>        <itemno>1002</itemno>        <bid>{$topbid - 5.00}</bid>        <bid_date>2006-04-23</bid_date>      </bid_tuple>   into $bids/bids     (:state-1-end :)
address-book-q1,Error: XPST0003: Unable to parse XPath: "(: Test - address-book-q1 :) (: Description - Update Use Case Address book   :)  (: insert-start :) declare variable $archive external; declare variable $copy1 external; declare variable $copy2 external; declare variable $log external; (: insert-end :)  (:state-1-start :)  for $a in $archive/archived-agenda/entry,      $v1 in $copy1/agenda-version/entry,      $v2 in $copy2/agenda-version/entry where $a/name = $v1/name   and $v1/name = $v2/name return    if ($a/contact = $v1/contact and $v1/contact=$v2/contact)   then ()   else      if ($v1/contact = $v2/contact)     then ( replace value of node $a/contact with $v1/contact,            replace value of node               $archive/*/last-synch-time             with "2006-04-23T12:00"          )     else        if ($a/contact = $v1/contact)       then (             replace value of node $a/contact with $v2/contact,             replace value of node $v1/contact with $v2/contact,             replace value of node                 $archive/*/last-synch-time             with "2006-04-23T12:00"             )       else          if ($a/contact = $v2/contact)         then (               replace value of node $a/contact with $v1/contact,               replace value of node $v2/contact with $v1/contact,               replace value of node                   $archive/*/last-synch-time               with "2006-04-23T12:00"              )         else (            insert node              <fail>                <arch>{ $a }</arch>                <v1>{ $v1 }</v1>                <v2>{ $v2 }</v2>             </fail>           into $log/log         ) (:state-1-end :)". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Test - address-book-q1 :) (: Description - Update Use Case Address book   :)  (: insert-start :) declare variable $archive external; declare variable $copy1 external; declare variable $copy2 external; declare variable $log external; (: insert-end :)  (:state-1-start :)  for $a in $archive/archived-agenda/entry,      $v1 in $copy1/agenda-version/entry,      $v2 in $copy2/agenda-version/entry where $a/name = $v1/name   and $v1/name = $v2/name return    if ($a/contact = $v1/contact and $v1/contact=$v2/contact)   then ()   else      if ($v1/contact = $v2/contact)     then ( replace value of node $a/contact with $v1/contact,            replace value of node               $archive/*/last-synch-time             with "2006-04-23T12:00"          )     else        if ($a/contact = $v1/contact)       then (             replace value of node $a/contact with $v2/contact,             replace value of node $v1/contact with $v2/contact,             replace value of node                 $archive/*/last-synch-time             with "2006-04-23T12:00"             )       else          if ($a/contact = $v2/contact)         then (               replace value of node $a/contact with $v1/contact,               replace value of node $v2/contact with $v1/contact,               replace value of node                   $archive/*/last-synch-time               with "2006-04-23T12:00"              )         else (            insert [Error is around here]node              <fail>                <arch>{ $a }</arch>                <v1>{ $v1 }</v1>                <v2>{ $v2 }</v2>             </fail>           into $log/log         ) (:state-1-end :)
soap-q1,Error: Not implemented: Intermediate clauses in flwor expressions are not implemented yet
namespaces-q1,Error: Not implemented: Intermediate clauses in flwor expressions are not implemented yet
parts-q1,Error: XPST0003: Unable to parse XPath: "(: Test - parts-q1 :) (: Description - Update Use Case Parts :)  (: insert-start :) declare variable $part-tree external; (: insert-end :)  (:state-1-start :)  delete node $part-tree//part  (:state-1-end :)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Test - parts-q1 :) (: Description - Update Use Case Parts :)  (: insert-start :) declare variable $part-tree external; (: insert-end :)  (:state-1-start :)  delete [Error is around here]node $part-tree//part  (:state-1-end :)
parts-q2,Error: XPST0003: Unable to parse XPath: "(: Test - parts-q2 :) (: Description - Update Use Case Parts Q2:)  (: insert-start :) declare variable $part-tree external; (: insert-end :)  (:state-1-start :)  delete node $part-tree//part[@name="car"]/part  (:state-1-end :)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Test - parts-q2 :) (: Description - Update Use Case Parts Q2:)  (: insert-start :) declare variable $part-tree external; (: insert-end :)  (:state-1-start :)  delete [Error is around here]node $part-tree//part[@name="car"]/part  (:state-1-end :)
parts-q3-1,Error: XPST0003: Unable to parse XPath: "(: Test - parts-q3-1 :) (: Description - Update Use Case Parts Q3:)  (: insert-start :) declare variable $part-tree external; declare variable $part-list external; (: insert-end :)  (:state-1-start :)  for $pt in $part-tree//part[@name="car"]//part,      $pl in $part-list//part where $pt/@partid eq $pl/@partid return    delete node $pl      (:state-1-end :)". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Test - parts-q3-1 :) (: Description - Update Use Case Parts Q3:)  (: insert-start :) declare variable $part-tree external; declare variable $part-list external; (: insert-end :)  (:state-1-start :)  for $pt in $part-tree//part[@name="car"]//part,      $pl in $part-list//part where $pt/@partid eq $pl/@partid return    delete [Error is around here]node $pl      (:state-1-end :)
parts-q3-2,Error: XPST0003: Unable to parse XPath: "(: Test - parts-q3-2 :) (: Description - Update Use Case Parts Q3 - Alternate Solution:)  (: insert-start :) declare variable $part-tree external; declare variable $part-list external; (: insert-end :)  (:state-1-start :)  declare updating function               local:delete-subtree($p as element(part))   {       for $child in $part-list//part       where $p/@partid eq $child/@partof       return (         local:delete-subtree($child),         delete node $child       )   };  for $p in $part-list//part[@name="car"] return    local:delete-subtree($p)    (:state-1-end :)  ". Expected " ", "!", "!=", "%", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "context", "div", "eq", "except", "function", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "option", "or", "to", "treat", "union", "variable", "|", "||", or end of input but "u" found. (: Test - parts-q3-2 :) (: Description - Update Use Case Parts Q3 - Alternate Solution:)  (: insert-start :) declare variable $part-tree external; declare variable $part-list external; (: insert-end :)  (:state-1-start :)  declare [Error is around here]updating function               local:delete-subtree($p as element(part))   {       for $child in $part-list//part       where $p/@partid eq $child/@partof       return (         local:delete-subtree($child),         delete node $child       )   };  for $p in $part-list//part[@name="car"] return    local:delete-subtree($p)    (:state-1-end :)
parts-q4-1,Error: XPST0003: Unable to parse XPath: "(: Test - parts-q4-1 :) (: Description - Update Use Case Parts Q4 - :)  (: insert-start :) declare variable $part-tree external; (: insert-end :)  (:state-1-start :)  let $next := max($part-tree//@partid) + 1   return     insert node <part partid="{$next}" name="radio"/>        into         $part-tree//part[@partid=0 and @name="car"]         (:state-1-end :)       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Test - parts-q4-1 :) (: Description - Update Use Case Parts Q4 - :)  (: insert-start :) declare variable $part-tree external; (: insert-end :)  (:state-1-start :)  let $next := max($part-tree//@partid) + 1   return     insert [Error is around here]node <part partid="{$next}" name="radio"/>        into         $part-tree//part[@partid=0 and @name="car"]         (:state-1-end :)
parts-q4-2,Error: XPST0003: Unable to parse XPath: "(: Test - parts-q4-2 :) (: Description - Update Use Case Parts Q4 - Alternate solution :)  (: insert-start :) declare variable $part-tree external; (: insert-end :)  (:state-1-start :)  let $next := max($part-tree//@partid) + 1   return     insert node <part partid="{$next}" name="radio"/>        as last        into $part-tree//part[@partid=0 and @name="car"]         (:state-1-end :)       ". Expected " ", "!", "!=", "(", "(:", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", "||", or end of input but "n" found. (: Test - parts-q4-2 :) (: Description - Update Use Case Parts Q4 - Alternate solution :)  (: insert-start :) declare variable $part-tree external; (: insert-end :)  (:state-1-start :)  let $next := max($part-tree//@partid) + 1   return     insert [Error is around here]node <part partid="{$next}" name="radio"/>        as last        into $part-tree//part[@partid=0 and @name="car"]         (:state-1-end :)
parts-q6,Error: Not implemented: Intermediate clauses in flwor expressions are not implemented yet
nil-q1,Error: XPST0003: Unable to parse XPath: "(: Test - nil-q1 :) (: Description - Update Use Case nill Q1:)  (: insert-start :) declare variable $employees external; (: insert-end :)  (:state-1-start :)  for $e in $employees//employee where $e/@mgr = true() return      copy $emp := $e       modify (           replace value of node $emp/salary with "" ,           insert node (attribute xsi:nil {"true"})               into $emp/salary           )       return $emp        (:state-1-end :)  ". Expected " ", "!", "!=", "(", "(:", ")", "*", "+", ",", "-", "/", "//", "<", "<<", "<=", "=", "=>", ">", ">=", ">>", "[", "\n", "\r", "\t", "and", "cast", "castable", "div", "eq", "except", "ge", "gt", "idiv", "instance", "intersect", "is", "le", "lt", "mod", "ne", "or", "to", "treat", "union", "|", or "||" but "n" found. (: Test - nil-q1 :) (: Description - Update Use Case nill Q1:)  (: insert-start :) declare variable $employees external; (: insert-end :)  (:state-1-start :)  for $e in $employees//employee where $e/@mgr = true() return      copy $emp := $e       modify (           replace value of node $emp/salary with "" ,           insert [Error is around here]node (attribute xsi:nil {"true"})               into $emp/salary           )       return $emp        (:state-1-end :)